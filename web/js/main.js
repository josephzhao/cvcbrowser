/*
 Leaflet, a JavaScript library for mobile-friendly interactive maps. http://leafletjs.com
 (c) 2010-2013, Vladimir Agafonkin
 (c) 2010-2011, CloudMade
 */
(function (window, document, undefined) {
    var oldL = window.L,
            L = {};

    L.version = '0.7.3';

// define Leaflet for Node module pattern loaders, including Browserify
    if (typeof module === 'object' && typeof module.exports === 'object') {
        module.exports = L;

// define Leaflet as an AMD module
    } else if (typeof define === 'function' && define.amd) {
        define(L);
    }

// define Leaflet as a global L variable, saving the original L to restore later if needed

    L.noConflict = function () {
        window.L = oldL;
        return this;
    };

    window.L = L;


    /*
     * L.Util contains various utility functions used throughout Leaflet code.
     */

    L.Util = {
        extend: function (dest) { // (Object[, Object, ...]) ->
            var sources = Array.prototype.slice.call(arguments, 1),
                    i, j, len, src;

            for (j = 0, len = sources.length; j < len; j++) {
                src = sources[j] || {};
                for (i in src) {
                    if (src.hasOwnProperty(i)) {
                        dest[i] = src[i];
                    }
                }
            }
            return dest;
        },
        bind: function (fn, obj) { // (Function, Object) -> Function
            var args = arguments.length > 2 ? Array.prototype.slice.call(arguments, 2) : null;
            return function () {
                return fn.apply(obj, args || arguments);
            };
        },
        stamp: (function () {
            var lastId = 0,
                    key = '_leaflet_id';
            return function (obj) {
                obj[key] = obj[key] || ++lastId;
                return obj[key];
            };
        }()),
        invokeEach: function (obj, method, context) {
            var i, args;

            if (typeof obj === 'object') {
                args = Array.prototype.slice.call(arguments, 3);

                for (i in obj) {
                    method.apply(context, [i, obj[i]].concat(args));
                }
                return true;
            }

            return false;
        },
        limitExecByInterval: function (fn, time, context) {
            var lock, execOnUnlock;

            return function wrapperFn() {
                var args = arguments;

                if (lock) {
                    execOnUnlock = true;
                    return;
                }

                lock = true;

                setTimeout(function () {
                    lock = false;

                    if (execOnUnlock) {
                        wrapperFn.apply(context, args);
                        execOnUnlock = false;
                    }
                }, time);

                fn.apply(context, args);
            };
        },
        falseFn: function () {
            return false;
        },
        formatNum: function (num, digits) {
            var pow = Math.pow(10, digits || 5);
            return Math.round(num * pow) / pow;
        },
        trim: function (str) {
            return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
        },
        splitWords: function (str) {
            return L.Util.trim(str).split(/\s+/);
        },
        setOptions: function (obj, options) {
            obj.options = L.extend({}, obj.options, options);
            return obj.options;
        },
        getParamString: function (obj, existingUrl, uppercase) {
            var params = [];
            for (var i in obj) {
                params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
            }
            return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');
        },
        template: function (str, data) {
            return str.replace(/\{ *([\w_]+) *\}/g, function (str, key) {
                var value = data[key];
                if (value === undefined) {
                    throw new Error('No value provided for variable ' + str);
                } else if (typeof value === 'function') {
                    value = value(data);
                }
                return value;
            });
        },
        isArray: Array.isArray || function (obj) {
            return (Object.prototype.toString.call(obj) === '[object Array]');
        },
        emptyImageUrl: 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='
    };

    (function () {

        // inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/

        function getPrefixed(name) {
            var i, fn,
                    prefixes = ['webkit', 'moz', 'o', 'ms'];

            for (i = 0; i < prefixes.length && !fn; i++) {
                fn = window[prefixes[i] + name];
            }

            return fn;
        }

        var lastTime = 0;

        function timeoutDefer(fn) {
            var time = +new Date(),
                    timeToCall = Math.max(0, 16 - (time - lastTime));

            lastTime = time + timeToCall;
            return window.setTimeout(fn, timeToCall);
        }

        var requestFn = window.requestAnimationFrame ||
                getPrefixed('RequestAnimationFrame') || timeoutDefer;

        var cancelFn = window.cancelAnimationFrame ||
                getPrefixed('CancelAnimationFrame') ||
                getPrefixed('CancelRequestAnimationFrame') ||
                function (id) {
                    window.clearTimeout(id);
                };


        L.Util.requestAnimFrame = function (fn, context, immediate, element) {
            fn = L.bind(fn, context);

            if (immediate && requestFn === timeoutDefer) {
                fn();
            } else {
                return requestFn.call(window, fn, element);
            }
        };

        L.Util.cancelAnimFrame = function (id) {
            if (id) {
                cancelFn.call(window, id);
            }
        };

    }());

// shortcuts for most used utility functions
    L.extend = L.Util.extend;
    L.bind = L.Util.bind;
    L.stamp = L.Util.stamp;
    L.setOptions = L.Util.setOptions;


    /*
     * L.Class powers the OOP facilities of the library.
     * Thanks to John Resig and Dean Edwards for inspiration!
     */

    L.Class = function () {
    };

    L.Class.extend = function (props) {

        // extended class with the new prototype
        var NewClass = function () {

            // call the constructor
            if (this.initialize) {
                this.initialize.apply(this, arguments);
            }

            // call all constructor hooks
            if (this._initHooks) {
                this.callInitHooks();
            }
        };

        // instantiate class without calling constructor
        var F = function () {
        };
        F.prototype = this.prototype;

        var proto = new F();
        proto.constructor = NewClass;

        NewClass.prototype = proto;

        //inherit parent's statics
        for (var i in this) {
            if (this.hasOwnProperty(i) && i !== 'prototype') {
                NewClass[i] = this[i];
            }
        }

        // mix static properties into the class
        if (props.statics) {
            L.extend(NewClass, props.statics);
            delete props.statics;
        }

        // mix includes into the prototype
        if (props.includes) {
            L.Util.extend.apply(null, [proto].concat(props.includes));
            delete props.includes;
        }

        // merge options
        if (props.options && proto.options) {
            props.options = L.extend({}, proto.options, props.options);
        }

        // mix given properties into the prototype
        L.extend(proto, props);

        proto._initHooks = [];

        var parent = this;
        // jshint camelcase: false
        NewClass.__super__ = parent.prototype;

        // add method for calling all hooks
        proto.callInitHooks = function () {

            if (this._initHooksCalled) {
                return;
            }

            if (parent.prototype.callInitHooks) {
                parent.prototype.callInitHooks.call(this);
            }

            this._initHooksCalled = true;

            for (var i = 0, len = proto._initHooks.length; i < len; i++) {
                proto._initHooks[i].call(this);
            }
        };

        return NewClass;
    };


// method for adding properties to prototype
    L.Class.include = function (props) {
        L.extend(this.prototype, props);
    };

// merge new default options to the Class
    L.Class.mergeOptions = function (options) {
        L.extend(this.prototype.options, options);
    };

// add a constructor hook
    L.Class.addInitHook = function (fn) { // (Function) || (String, args...)
        var args = Array.prototype.slice.call(arguments, 1);

        var init = typeof fn === 'function' ? fn : function () {
            this[fn].apply(this, args);
        };

        this.prototype._initHooks = this.prototype._initHooks || [];
        this.prototype._initHooks.push(init);
    };


    /*
     * L.Mixin.Events is used to add custom events functionality to Leaflet classes.
     */

    var eventsKey = '_leaflet_events';

    L.Mixin = {};

    L.Mixin.Events = {
        addEventListener: function (types, fn, context) { // (String, Function[, Object]) or (Object[, Object])

            // types can be a map of types/handlers
            if (L.Util.invokeEach(types, this.addEventListener, this, fn, context)) {
                return this;
            }

            var events = this[eventsKey] = this[eventsKey] || {},
                    contextId = context && context !== this && L.stamp(context),
                    i, len, event, type, indexKey, indexLenKey, typeIndex;

            // types can be a string of space-separated words
            types = L.Util.splitWords(types);

            for (i = 0, len = types.length; i < len; i++) {
                event = {
                    action: fn,
                    context: context || this
                };
                type = types[i];

                if (contextId) {
                    // store listeners of a particular context in a separate hash (if it has an id)
                    // gives a major performance boost when removing thousands of map layers

                    indexKey = type + '_idx';
                    indexLenKey = indexKey + '_len';

                    typeIndex = events[indexKey] = events[indexKey] || {};

                    if (!typeIndex[contextId]) {
                        typeIndex[contextId] = [];

                        // keep track of the number of keys in the index to quickly check if it's empty
                        events[indexLenKey] = (events[indexLenKey] || 0) + 1;
                    }

                    typeIndex[contextId].push(event);


                } else {
                    events[type] = events[type] || [];
                    events[type].push(event);
                }
            }

            return this;
        },
        hasEventListeners: function (type) { // (String) -> Boolean
            var events = this[eventsKey];
            return !!events && ((type in events && events[type].length > 0) ||
                    (type + '_idx' in events && events[type + '_idx_len'] > 0));
        },
        removeEventListener: function (types, fn, context) { // ([String, Function, Object]) or (Object[, Object])

            if (!this[eventsKey]) {
                return this;
            }

            if (!types) {
                return this.clearAllEventListeners();
            }

            if (L.Util.invokeEach(types, this.removeEventListener, this, fn, context)) {
                return this;
            }

            var events = this[eventsKey],
                    contextId = context && context !== this && L.stamp(context),
                    i, len, type, listeners, j, indexKey, indexLenKey, typeIndex, removed;

            types = L.Util.splitWords(types);

            for (i = 0, len = types.length; i < len; i++) {
                type = types[i];
                indexKey = type + '_idx';
                indexLenKey = indexKey + '_len';

                typeIndex = events[indexKey];

                if (!fn) {
                    // clear all listeners for a type if function isn't specified
                    delete events[type];
                    delete events[indexKey];
                    delete events[indexLenKey];

                } else {
                    listeners = contextId && typeIndex ? typeIndex[contextId] : events[type];

                    if (listeners) {
                        for (j = listeners.length - 1; j >= 0; j--) {
                            if ((listeners[j].action === fn) && (!context || (listeners[j].context === context))) {
                                removed = listeners.splice(j, 1);
                                // set the old action to a no-op, because it is possible
                                // that the listener is being iterated over as part of a dispatch
                                removed[0].action = L.Util.falseFn;
                            }
                        }

                        if (context && typeIndex && (listeners.length === 0)) {
                            delete typeIndex[contextId];
                            events[indexLenKey]--;
                        }
                    }
                }
            }

            return this;
        },
        clearAllEventListeners: function () {
            delete this[eventsKey];
            return this;
        },
        fireEvent: function (type, data) { // (String[, Object])
            if (!this.hasEventListeners(type)) {
                return this;
            }

            var event = L.Util.extend({}, data, {type: type, target: this});

            var events = this[eventsKey],
                    listeners, i, len, typeIndex, contextId;

            if (events[type]) {
                // make sure adding/removing listeners inside other listeners won't cause infinite loop
                listeners = events[type].slice();

                for (i = 0, len = listeners.length; i < len; i++) {
                    listeners[i].action.call(listeners[i].context, event);
                }
            }

            // fire event for the context-indexed listeners as well
            typeIndex = events[type + '_idx'];

            for (contextId in typeIndex) {
                listeners = typeIndex[contextId].slice();

                if (listeners) {
                    for (i = 0, len = listeners.length; i < len; i++) {
                        listeners[i].action.call(listeners[i].context, event);
                    }
                }
            }

            return this;
        },
        addOneTimeEventListener: function (types, fn, context) {

            if (L.Util.invokeEach(types, this.addOneTimeEventListener, this, fn, context)) {
                return this;
            }

            var handler = L.bind(function () {
                this
                        .removeEventListener(types, fn, context)
                        .removeEventListener(types, handler, context);
            }, this);

            return this
                    .addEventListener(types, fn, context)
                    .addEventListener(types, handler, context);
        }
    };

    L.Mixin.Events.on = L.Mixin.Events.addEventListener;
    L.Mixin.Events.off = L.Mixin.Events.removeEventListener;
    L.Mixin.Events.once = L.Mixin.Events.addOneTimeEventListener;
    L.Mixin.Events.fire = L.Mixin.Events.fireEvent;


    /*
     * L.Browser handles different browser and feature detections for internal Leaflet use.
     */

    (function () {

        var ie = 'ActiveXObject' in window,
                ielt9 = ie && !document.addEventListener,
                // terrible browser detection to work around Safari / iOS / Android browser bugs
                ua = navigator.userAgent.toLowerCase(),
                webkit = ua.indexOf('webkit') !== -1,
                chrome = ua.indexOf('chrome') !== -1,
                phantomjs = ua.indexOf('phantom') !== -1,
                android = ua.indexOf('android') !== -1,
                android23 = ua.search('android [23]') !== -1,
                gecko = ua.indexOf('gecko') !== -1,
                mobile = typeof orientation !== undefined + '',
                msPointer = window.navigator && window.navigator.msPointerEnabled &&
                window.navigator.msMaxTouchPoints && !window.PointerEvent,
                pointer = (window.PointerEvent && window.navigator.pointerEnabled && window.navigator.maxTouchPoints) ||
                msPointer,
                retina = ('devicePixelRatio' in window && window.devicePixelRatio > 1) ||
                ('matchMedia' in window && window.matchMedia('(min-resolution:144dpi)') &&
                        window.matchMedia('(min-resolution:144dpi)').matches),
                doc = document.documentElement,
                ie3d = ie && ('transition' in doc.style),
                webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23,
                gecko3d = 'MozPerspective' in doc.style,
                opera3d = 'OTransition' in doc.style,
                any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d || opera3d) && !phantomjs;


        // PhantomJS has 'ontouchstart' in document.documentElement, but doesn't actually support touch.
        // https://github.com/Leaflet/Leaflet/pull/1434#issuecomment-13843151

        var touch = !window.L_NO_TOUCH && !phantomjs && (function () {

            var startName = 'ontouchstart';

            // IE10+ (We simulate these into touch* events in L.DomEvent and L.DomEvent.Pointer) or WebKit, etc.
            if (pointer || (startName in doc)) {
                return true;
            }

            // Firefox/Gecko
            var div = document.createElement('div'),
                    supported = false;

            if (!div.setAttribute) {
                return false;
            }
            div.setAttribute(startName, 'return;');

            if (typeof div[startName] === 'function') {
                supported = true;
            }

            div.removeAttribute(startName);
            div = null;

            return supported;
        }());


        L.Browser = {
            ie: ie,
            ielt9: ielt9,
            webkit: webkit,
            gecko: gecko && !webkit && !window.opera && !ie,
            android: android,
            android23: android23,
            chrome: chrome,
            ie3d: ie3d,
            webkit3d: webkit3d,
            gecko3d: gecko3d,
            opera3d: opera3d,
            any3d: any3d,
            mobile: mobile,
            mobileWebkit: mobile && webkit,
            mobileWebkit3d: mobile && webkit3d,
            mobileOpera: mobile && window.opera,
            touch: touch,
            msPointer: msPointer,
            pointer: pointer,
            retina: retina
        };

    }());


    /*
     * L.Point represents a point with x and y coordinates.
     */

    L.Point = function (/*Number*/ x, /*Number*/ y, /*Boolean*/ round) {
        this.x = (round ? Math.round(x) : x);
        this.y = (round ? Math.round(y) : y);
    };

    L.Point.prototype = {
        clone: function () {
            return new L.Point(this.x, this.y);
        },
        // non-destructive, returns a new point
        add: function (point) {
            return this.clone()._add(L.point(point));
        },
        // destructive, used directly for performance in situations where it's safe to modify existing point
        _add: function (point) {
            this.x += point.x;
            this.y += point.y;
            return this;
        },
        subtract: function (point) {
            return this.clone()._subtract(L.point(point));
        },
        _subtract: function (point) {
            this.x -= point.x;
            this.y -= point.y;
            return this;
        },
        divideBy: function (num) {
            return this.clone()._divideBy(num);
        },
        _divideBy: function (num) {
            this.x /= num;
            this.y /= num;
            return this;
        },
        multiplyBy: function (num) {
            return this.clone()._multiplyBy(num);
        },
        _multiplyBy: function (num) {
            this.x *= num;
            this.y *= num;
            return this;
        },
        round: function () {
            return this.clone()._round();
        },
        _round: function () {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            return this;
        },
        floor: function () {
            return this.clone()._floor();
        },
        _floor: function () {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            return this;
        },
        distanceTo: function (point) {
            point = L.point(point);

            var x = point.x - this.x,
                    y = point.y - this.y;

            return Math.sqrt(x * x + y * y);
        },
        equals: function (point) {
            point = L.point(point);

            return point.x === this.x &&
                    point.y === this.y;
        },
        contains: function (point) {
            point = L.point(point);

            return Math.abs(point.x) <= Math.abs(this.x) &&
                    Math.abs(point.y) <= Math.abs(this.y);
        },
        toString: function () {
            return 'Point(' +
                    L.Util.formatNum(this.x) + ', ' +
                    L.Util.formatNum(this.y) + ')';
        }
    };

    L.point = function (x, y, round) {
        if (x instanceof L.Point) {
            return x;
        }
        if (L.Util.isArray(x)) {
            return new L.Point(x[0], x[1]);
        }
        if (x === undefined || x === null) {
            return x;
        }
        return new L.Point(x, y, round);
    };


    /*
     * L.Bounds represents a rectangular area on the screen in pixel coordinates.
     */

    L.Bounds = function (a, b) { //(Point, Point) or Point[]
        if (!a) {
            return;
        }

        var points = b ? [a, b] : a;

        for (var i = 0, len = points.length; i < len; i++) {
            this.extend(points[i]);
        }
    };

    L.Bounds.prototype = {
        // extend the bounds to contain the given point
        extend: function (point) { // (Point)
            point = L.point(point);

            if (!this.min && !this.max) {
                this.min = point.clone();
                this.max = point.clone();
            } else {
                this.min.x = Math.min(point.x, this.min.x);
                this.max.x = Math.max(point.x, this.max.x);
                this.min.y = Math.min(point.y, this.min.y);
                this.max.y = Math.max(point.y, this.max.y);
            }
            return this;
        },
        getCenter: function (round) { // (Boolean) -> Point
            return new L.Point(
                    (this.min.x + this.max.x) / 2,
                    (this.min.y + this.max.y) / 2, round);
        },
        getBottomLeft: function () { // -> Point
            return new L.Point(this.min.x, this.max.y);
        },
        getTopRight: function () { // -> Point
            return new L.Point(this.max.x, this.min.y);
        },
        getSize: function () {
            return this.max.subtract(this.min);
        },
        contains: function (obj) { // (Bounds) or (Point) -> Boolean
            var min, max;

            if (typeof obj[0] === 'number' || obj instanceof L.Point) {
                obj = L.point(obj);
            } else {
                obj = L.bounds(obj);
            }

            if (obj instanceof L.Bounds) {
                min = obj.min;
                max = obj.max;
            } else {
                min = max = obj;
            }

            return (min.x >= this.min.x) &&
                    (max.x <= this.max.x) &&
                    (min.y >= this.min.y) &&
                    (max.y <= this.max.y);
        },
        intersects: function (bounds) { // (Bounds) -> Boolean
            bounds = L.bounds(bounds);

            var min = this.min,
                    max = this.max,
                    min2 = bounds.min,
                    max2 = bounds.max,
                    xIntersects = (max2.x >= min.x) && (min2.x <= max.x),
                    yIntersects = (max2.y >= min.y) && (min2.y <= max.y);

            return xIntersects && yIntersects;
        },
        isValid: function () {
            return !!(this.min && this.max);
        }
    };

    L.bounds = function (a, b) { // (Bounds) or (Point, Point) or (Point[])
        if (!a || a instanceof L.Bounds) {
            return a;
        }
        return new L.Bounds(a, b);
    };


    /*
     * L.Transformation is an utility class to perform simple point transformations through a 2d-matrix.
     */

    L.Transformation = function (a, b, c, d) {
        this._a = a;
        this._b = b;
        this._c = c;
        this._d = d;
    };

    L.Transformation.prototype = {
        transform: function (point, scale) { // (Point, Number) -> Point
            return this._transform(point.clone(), scale);
        },
        // destructive transform (faster)
        _transform: function (point, scale) {
            scale = scale || 1;
            point.x = scale * (this._a * point.x + this._b);
            point.y = scale * (this._c * point.y + this._d);
            return point;
        },
        untransform: function (point, scale) {
            scale = scale || 1;
            return new L.Point(
                    (point.x / scale - this._b) / this._a,
                    (point.y / scale - this._d) / this._c);
        }
    };


    /*
     * L.DomUtil contains various utility functions for working with DOM.
     */

    L.DomUtil = {
        get: function (id) {
            return (typeof id === 'string' ? document.getElementById(id) : id);
        },
        getStyle: function (el, style) {

            var value = el.style[style];

            if (!value && el.currentStyle) {
                value = el.currentStyle[style];
            }

            if ((!value || value === 'auto') && document.defaultView) {
                var css = document.defaultView.getComputedStyle(el, null);
                value = css ? css[style] : null;
            }

            return value === 'auto' ? null : value;
        },
        getViewportOffset: function (element) {

            var top = 0,
                    left = 0,
                    el = element,
                    docBody = document.body,
                    docEl = document.documentElement,
                    pos;

            do {
                top += el.offsetTop || 0;
                left += el.offsetLeft || 0;

                //add borders
                top += parseInt(L.DomUtil.getStyle(el, 'borderTopWidth'), 10) || 0;
                left += parseInt(L.DomUtil.getStyle(el, 'borderLeftWidth'), 10) || 0;

                pos = L.DomUtil.getStyle(el, 'position');

                if (el.offsetParent === docBody && pos === 'absolute') {
                    break;
                }

                if (pos === 'fixed') {
                    top += docBody.scrollTop || docEl.scrollTop || 0;
                    left += docBody.scrollLeft || docEl.scrollLeft || 0;
                    break;
                }

                if (pos === 'relative' && !el.offsetLeft) {
                    var width = L.DomUtil.getStyle(el, 'width'),
                            maxWidth = L.DomUtil.getStyle(el, 'max-width'),
                            r = el.getBoundingClientRect();

                    if (width !== 'none' || maxWidth !== 'none') {
                        left += r.left + el.clientLeft;
                    }

                    //calculate full y offset since we're breaking out of the loop
                    top += r.top + (docBody.scrollTop || docEl.scrollTop || 0);

                    break;
                }

                el = el.offsetParent;

            } while (el);

            el = element;

            do {
                if (el === docBody) {
                    break;
                }

                top -= el.scrollTop || 0;
                left -= el.scrollLeft || 0;

                el = el.parentNode;
            } while (el);

            return new L.Point(left, top);
        },
        documentIsLtr: function () {
            if (!L.DomUtil._docIsLtrCached) {
                L.DomUtil._docIsLtrCached = true;
                L.DomUtil._docIsLtr = L.DomUtil.getStyle(document.body, 'direction') === 'ltr';
            }
            return L.DomUtil._docIsLtr;
        },
        create: function (tagName, className, container) {

            var el = document.createElement(tagName);
            el.className = className;

            if (container) {
                container.appendChild(el);
            }

            return el;
        },
        hasClass: function (el, name) {
            if (el.classList !== undefined) {
                return el.classList.contains(name);
            }
            var className = L.DomUtil._getClass(el);
            return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
        },
        addClass: function (el, name) {
            if (el.classList !== undefined) {
                var classes = L.Util.splitWords(name);
                for (var i = 0, len = classes.length; i < len; i++) {
                    el.classList.add(classes[i]);
                }
            } else if (!L.DomUtil.hasClass(el, name)) {
                var className = L.DomUtil._getClass(el);
                L.DomUtil._setClass(el, (className ? className + ' ' : '') + name);
            }
        },
        removeClass: function (el, name) {
            if (el.classList !== undefined) {
                el.classList.remove(name);
            } else {
                L.DomUtil._setClass(el, L.Util.trim((' ' + L.DomUtil._getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
            }
        },
        _setClass: function (el, name) {
            if (el.className.baseVal === undefined) {
                el.className = name;
            } else {
                // in case of SVG element
                el.className.baseVal = name;
            }
        },
        _getClass: function (el) {
            return el.className.baseVal === undefined ? el.className : el.className.baseVal;
        },
        setOpacity: function (el, value) {

            if ('opacity' in el.style) {
                el.style.opacity = value;

            } else if ('filter' in el.style) {

                var filter = false,
                        filterName = 'DXImageTransform.Microsoft.Alpha';

                // filters collection throws an error if we try to retrieve a filter that doesn't exist
                try {
                    filter = el.filters.item(filterName);
                } catch (e) {
                    // don't set opacity to 1 if we haven't already set an opacity,
                    // it isn't needed and breaks transparent pngs.
                    if (value === 1) {
                        return;
                    }
                }

                value = Math.round(value * 100);

                if (filter) {
                    filter.Enabled = (value !== 100);
                    filter.Opacity = value;
                } else {
                    el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
                }
            }
        },
        testProp: function (props) {

            var style = document.documentElement.style;

            for (var i = 0; i < props.length; i++) {
                if (props[i] in style) {
                    return props[i];
                }
            }
            return false;
        },
        getTranslateString: function (point) {
            // on WebKit browsers (Chrome/Safari/iOS Safari/Android) using translate3d instead of translate
            // makes animation smoother as it ensures HW accel is used. Firefox 13 doesn't care
            // (same speed either way), Opera 12 doesn't support translate3d

            var is3d = L.Browser.webkit3d,
                    open = 'translate' + (is3d ? '3d' : '') + '(',
                    close = (is3d ? ',0' : '') + ')';

            return open + point.x + 'px,' + point.y + 'px' + close;
        },
        getScaleString: function (scale, origin) {

            var preTranslateStr = L.DomUtil.getTranslateString(origin.add(origin.multiplyBy(-1 * scale))),
                    scaleStr = ' scale(' + scale + ') ';

            return preTranslateStr + scaleStr;
        },
        setPosition: function (el, point, disable3D) { // (HTMLElement, Point[, Boolean])

            // jshint camelcase: false
            el._leaflet_pos = point;

            if (!disable3D && L.Browser.any3d) {
                el.style[L.DomUtil.TRANSFORM] = L.DomUtil.getTranslateString(point);
            } else {
                el.style.left = point.x + 'px';
                el.style.top = point.y + 'px';
            }
        },
        getPosition: function (el) {
            // this method is only used for elements previously positioned using setPosition,
            // so it's safe to cache the position for performance

            // jshint camelcase: false
            return el._leaflet_pos;
        }
    };


// prefix style property names

    L.DomUtil.TRANSFORM = L.DomUtil.testProp(
            ['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);

// webkitTransition comes first because some browser versions that drop vendor prefix don't do
// the same for the transitionend event, in particular the Android 4.1 stock browser

    L.DomUtil.TRANSITION = L.DomUtil.testProp(
            ['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);

    L.DomUtil.TRANSITION_END =
            L.DomUtil.TRANSITION === 'webkitTransition' || L.DomUtil.TRANSITION === 'OTransition' ?
            L.DomUtil.TRANSITION + 'End' : 'transitionend';

    (function () {
        if ('onselectstart' in document) {
            L.extend(L.DomUtil, {
                disableTextSelection: function () {
                    L.DomEvent.on(window, 'selectstart', L.DomEvent.preventDefault);
                },
                enableTextSelection: function () {
                    L.DomEvent.off(window, 'selectstart', L.DomEvent.preventDefault);
                }
            });
        } else {
            var userSelectProperty = L.DomUtil.testProp(
                    ['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);

            L.extend(L.DomUtil, {
                disableTextSelection: function () {
                    if (userSelectProperty) {
                        var style = document.documentElement.style;
                        this._userSelect = style[userSelectProperty];
                        style[userSelectProperty] = 'none';
                    }
                },
                enableTextSelection: function () {
                    if (userSelectProperty) {
                        document.documentElement.style[userSelectProperty] = this._userSelect;
                        delete this._userSelect;
                    }
                }
            });
        }

        L.extend(L.DomUtil, {
            disableImageDrag: function () {
                L.DomEvent.on(window, 'dragstart', L.DomEvent.preventDefault);
            },
            enableImageDrag: function () {
                L.DomEvent.off(window, 'dragstart', L.DomEvent.preventDefault);
            }
        });
    })();


    /*
     * L.LatLng represents a geographical point with latitude and longitude coordinates.
     */

    L.LatLng = function (lat, lng, alt) { // (Number, Number, Number)
        lat = parseFloat(lat);
        lng = parseFloat(lng);

        if (isNaN(lat) || isNaN(lng)) {
            throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
        }

        this.lat = lat;
        this.lng = lng;

        if (alt !== undefined) {
            this.alt = parseFloat(alt);
        }
    };

    L.extend(L.LatLng, {
        DEG_TO_RAD: Math.PI / 180,
        RAD_TO_DEG: 180 / Math.PI,
        MAX_MARGIN: 1.0E-9 // max margin of error for the "equals" check
    });

    L.LatLng.prototype = {
        equals: function (obj) { // (LatLng) -> Boolean
            if (!obj) {
                return false;
            }

            obj = L.latLng(obj);

            var margin = Math.max(
                    Math.abs(this.lat - obj.lat),
                    Math.abs(this.lng - obj.lng));

            return margin <= L.LatLng.MAX_MARGIN;
        },
        toString: function (precision) { // (Number) -> String
            return 'LatLng(' +
                    L.Util.formatNum(this.lat, precision) + ', ' +
                    L.Util.formatNum(this.lng, precision) + ')';
        },
        // Haversine distance formula, see http://en.wikipedia.org/wiki/Haversine_formula
        // TODO move to projection code, LatLng shouldn't know about Earth
        distanceTo: function (other) { // (LatLng) -> Number
            other = L.latLng(other);

            var R = 6378137, // earth radius in meters
                    d2r = L.LatLng.DEG_TO_RAD,
                    dLat = (other.lat - this.lat) * d2r,
                    dLon = (other.lng - this.lng) * d2r,
                    lat1 = this.lat * d2r,
                    lat2 = other.lat * d2r,
                    sin1 = Math.sin(dLat / 2),
                    sin2 = Math.sin(dLon / 2);

            var a = sin1 * sin1 + sin2 * sin2 * Math.cos(lat1) * Math.cos(lat2);

            return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        },
        wrap: function (a, b) { // (Number, Number) -> LatLng
            var lng = this.lng;

            a = a || -180;
            b = b || 180;

            lng = (lng + b) % (b - a) + (lng < a || lng === b ? b : a);

            return new L.LatLng(this.lat, lng);
        }
    };

    L.latLng = function (a, b) { // (LatLng) or ([Number, Number]) or (Number, Number)
        if (a instanceof L.LatLng) {
            return a;
        }
        if (L.Util.isArray(a)) {
            if (typeof a[0] === 'number' || typeof a[0] === 'string') {
                return new L.LatLng(a[0], a[1], a[2]);
            } else {
                return null;
            }
        }
        if (a === undefined || a === null) {
            return a;
        }
        if (typeof a === 'object' && 'lat' in a) {
            return new L.LatLng(a.lat, 'lng' in a ? a.lng : a.lon);
        }
        if (b === undefined) {
            return null;
        }
        return new L.LatLng(a, b);
    };



    /*
     * L.LatLngBounds represents a rectangular area on the map in geographical coordinates.
     */

    L.LatLngBounds = function (southWest, northEast) { // (LatLng, LatLng) or (LatLng[])
        if (!southWest) {
            return;
        }

        var latlngs = northEast ? [southWest, northEast] : southWest;

        for (var i = 0, len = latlngs.length; i < len; i++) {
            this.extend(latlngs[i]);
        }
    };

    L.LatLngBounds.prototype = {
        // extend the bounds to contain the given point or bounds
        extend: function (obj) { // (LatLng) or (LatLngBounds)
            if (!obj) {
                return this;
            }

            var latLng = L.latLng(obj);
            if (latLng !== null) {
                obj = latLng;
            } else {
                obj = L.latLngBounds(obj);
            }

            if (obj instanceof L.LatLng) {
                if (!this._southWest && !this._northEast) {
                    this._southWest = new L.LatLng(obj.lat, obj.lng);
                    this._northEast = new L.LatLng(obj.lat, obj.lng);
                } else {
                    this._southWest.lat = Math.min(obj.lat, this._southWest.lat);
                    this._southWest.lng = Math.min(obj.lng, this._southWest.lng);

                    this._northEast.lat = Math.max(obj.lat, this._northEast.lat);
                    this._northEast.lng = Math.max(obj.lng, this._northEast.lng);
                }
            } else if (obj instanceof L.LatLngBounds) {
                this.extend(obj._southWest);
                this.extend(obj._northEast);
            }
            return this;
        },
        // extend the bounds by a percentage
        pad: function (bufferRatio) { // (Number) -> LatLngBounds
            var sw = this._southWest,
                    ne = this._northEast,
                    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
                    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;

            return new L.LatLngBounds(
                    new L.LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
                    new L.LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
        },
        getCenter: function () { // -> LatLng
            return new L.LatLng(
                    (this._southWest.lat + this._northEast.lat) / 2,
                    (this._southWest.lng + this._northEast.lng) / 2);
        },
        getSouthWest: function () {
            return this._southWest;
        },
        getNorthEast: function () {
            return this._northEast;
        },
        getNorthWest: function () {
            return new L.LatLng(this.getNorth(), this.getWest());
        },
        getSouthEast: function () {
            return new L.LatLng(this.getSouth(), this.getEast());
        },
        getWest: function () {
            return this._southWest.lng;
        },
        getSouth: function () {
            return this._southWest.lat;
        },
        getEast: function () {
            return this._northEast.lng;
        },
        getNorth: function () {
            return this._northEast.lat;
        },
        contains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean
            if (typeof obj[0] === 'number' || obj instanceof L.LatLng) {
                obj = L.latLng(obj);
            } else {
                obj = L.latLngBounds(obj);
            }

            var sw = this._southWest,
                    ne = this._northEast,
                    sw2, ne2;

            if (obj instanceof L.LatLngBounds) {
                sw2 = obj.getSouthWest();
                ne2 = obj.getNorthEast();
            } else {
                sw2 = ne2 = obj;
            }

            return (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&
                    (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);
        },
        intersects: function (bounds) { // (LatLngBounds)
            bounds = L.latLngBounds(bounds);

            var sw = this._southWest,
                    ne = this._northEast,
                    sw2 = bounds.getSouthWest(),
                    ne2 = bounds.getNorthEast(),
                    latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),
                    lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);

            return latIntersects && lngIntersects;
        },
        toBBoxString: function () {
            return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');
        },
        equals: function (bounds) { // (LatLngBounds)
            if (!bounds) {
                return false;
            }

            bounds = L.latLngBounds(bounds);

            return this._southWest.equals(bounds.getSouthWest()) &&
                    this._northEast.equals(bounds.getNorthEast());
        },
        isValid: function () {
            return !!(this._southWest && this._northEast);
        }
    };

//TODO International date line?

    L.latLngBounds = function (a, b) { // (LatLngBounds) or (LatLng, LatLng)
        if (!a || a instanceof L.LatLngBounds) {
            return a;
        }
        return new L.LatLngBounds(a, b);
    };


    /*
     * L.Projection contains various geographical projections used by CRS classes.
     */

    L.Projection = {};


    /*
     * Spherical Mercator is the most popular map projection, used by EPSG:3857 CRS used by default.
     */

    L.Projection.SphericalMercator = {
        MAX_LATITUDE: 85.0511287798,
        project: function (latlng) { // (LatLng) -> Point
            var d = L.LatLng.DEG_TO_RAD,
                    max = this.MAX_LATITUDE,
                    lat = Math.max(Math.min(max, latlng.lat), -max),
                    x = latlng.lng * d,
                    y = lat * d;

            y = Math.log(Math.tan((Math.PI / 4) + (y / 2)));

            return new L.Point(x, y);
        },
        unproject: function (point) { // (Point, Boolean) -> LatLng
            var d = L.LatLng.RAD_TO_DEG,
                    lng = point.x * d,
                    lat = (2 * Math.atan(Math.exp(point.y)) - (Math.PI / 2)) * d;

            return new L.LatLng(lat, lng);
        }
    };


    /*
     * Simple equirectangular (Plate Carree) projection, used by CRS like EPSG:4326 and Simple.
     */

    L.Projection.LonLat = {
        project: function (latlng) {
            return new L.Point(latlng.lng, latlng.lat);
        },
        unproject: function (point) {
            return new L.LatLng(point.y, point.x);
        }
    };


    /*
     * L.CRS is a base object for all defined CRS (Coordinate Reference Systems) in Leaflet.
     */

    L.CRS = {
        latLngToPoint: function (latlng, zoom) { // (LatLng, Number) -> Point
            var projectedPoint = this.projection.project(latlng),
                    scale = this.scale(zoom);

            return this.transformation._transform(projectedPoint, scale);
        },
        pointToLatLng: function (point, zoom) { // (Point, Number[, Boolean]) -> LatLng
            var scale = this.scale(zoom),
                    untransformedPoint = this.transformation.untransform(point, scale);

            return this.projection.unproject(untransformedPoint);
        },
        project: function (latlng) {
            return this.projection.project(latlng);
        },
        scale: function (zoom) {
            return 256 * Math.pow(2, zoom);
        },
        getSize: function (zoom) {
            var s = this.scale(zoom);
            return L.point(s, s);
        }
    };


    /*
     * A simple CRS that can be used for flat non-Earth maps like panoramas or game maps.
     */

    L.CRS.Simple = L.extend({}, L.CRS, {
        projection: L.Projection.LonLat,
        transformation: new L.Transformation(1, 0, -1, 0),
        scale: function (zoom) {
            return Math.pow(2, zoom);
        }
    });


    /*
     * L.CRS.EPSG3857 (Spherical Mercator) is the most common CRS for web mapping
     * and is used by Leaflet by default.
     */

    L.CRS.EPSG3857 = L.extend({}, L.CRS, {
        code: 'EPSG:3857',
        projection: L.Projection.SphericalMercator,
        transformation: new L.Transformation(0.5 / Math.PI, 0.5, -0.5 / Math.PI, 0.5),
        project: function (latlng) { // (LatLng) -> Point
            var projectedPoint = this.projection.project(latlng),
                    earthRadius = 6378137;
            return projectedPoint.multiplyBy(earthRadius);
        }
    });

    L.CRS.EPSG900913 = L.extend({}, L.CRS.EPSG3857, {
        code: 'EPSG:900913'
    });


    /*
     * L.CRS.EPSG4326 is a CRS popular among advanced GIS specialists.
     */

    L.CRS.EPSG4326 = L.extend({}, L.CRS, {
        code: 'EPSG:4326',
        projection: L.Projection.LonLat,
        transformation: new L.Transformation(1 / 360, 0.5, -1 / 360, 0.5)
    });


    /*
     * L.Map is the central class of the API - it is used to create a map.
     */

    L.Map = L.Class.extend({
        includes: L.Mixin.Events,
        options: {
            crs: L.CRS.EPSG3857,
            /*
             center: LatLng,
             zoom: Number,
             layers: Array,
             */

            fadeAnimation: L.DomUtil.TRANSITION && !L.Browser.android23,
            trackResize: true,
            markerZoomAnimation: L.DomUtil.TRANSITION && L.Browser.any3d
        },
        initialize: function (id, options) { // (HTMLElement or String, Object)
            options = L.setOptions(this, options);


            this._initContainer(id);
            this._initLayout();

            // hack for https://github.com/Leaflet/Leaflet/issues/1980
            this._onResize = L.bind(this._onResize, this);

            this._initEvents();

            if (options.maxBounds) {
                this.setMaxBounds(options.maxBounds);
            }

            if (options.center && options.zoom !== undefined) {
                this.setView(L.latLng(options.center), options.zoom, {reset: true});
            }

            this._handlers = [];

            this._layers = {};
            this._zoomBoundLayers = {};
            this._tileLayersNum = 0;

            this.callInitHooks();

            this._addLayers(options.layers);
        },
        // public methods that modify map state

        // replaced by animation-powered implementation in Map.PanAnimation.js
        setView: function (center, zoom) {
            zoom = zoom === undefined ? this.getZoom() : zoom;
            this._resetView(L.latLng(center), this._limitZoom(zoom));
            return this;
        },
        setZoom: function (zoom, options) {
            if (!this._loaded) {
                this._zoom = this._limitZoom(zoom);
                return this;
            }
            return this.setView(this.getCenter(), zoom, {zoom: options});
        },
        zoomIn: function (delta, options) {
            return this.setZoom(this._zoom + (delta || 1), options);
        },
        zoomOut: function (delta, options) {
            return this.setZoom(this._zoom - (delta || 1), options);
        },
        setZoomAround: function (latlng, zoom, options) {
            var scale = this.getZoomScale(zoom),
                    viewHalf = this.getSize().divideBy(2),
                    containerPoint = latlng instanceof L.Point ? latlng : this.latLngToContainerPoint(latlng),
                    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),
                    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));

            return this.setView(newCenter, zoom, {zoom: options});
        },
        fitBounds: function (bounds, options) {

            options = options || {};
            bounds = bounds.getBounds ? bounds.getBounds() : L.latLngBounds(bounds);

            var paddingTL = L.point(options.paddingTopLeft || options.padding || [0, 0]),
                    paddingBR = L.point(options.paddingBottomRight || options.padding || [0, 0]),
                    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR)),
                    paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),
                    swPoint = this.project(bounds.getSouthWest(), zoom),
                    nePoint = this.project(bounds.getNorthEast(), zoom),
                    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);

            zoom = options && options.maxZoom ? Math.min(options.maxZoom, zoom) : zoom;

            return this.setView(center, zoom, options);
        },
        fitWorld: function (options) {
            return this.fitBounds([[-90, -180], [90, 180]], options);
        },
        panTo: function (center, options) { // (LatLng)
            return this.setView(center, this._zoom, {pan: options});
        },
        panBy: function (offset) { // (Point)
            // replaced with animated panBy in Map.PanAnimation.js
            this.fire('movestart');

            this._rawPanBy(L.point(offset));

            this.fire('move');
            return this.fire('moveend');
        },
        setMaxBounds: function (bounds) {
            bounds = L.latLngBounds(bounds);

            this.options.maxBounds = bounds;

            if (!bounds) {
                return this.off('moveend', this._panInsideMaxBounds, this);
            }

            if (this._loaded) {
                this._panInsideMaxBounds();
            }

            return this.on('moveend', this._panInsideMaxBounds, this);
        },
        panInsideBounds: function (bounds, options) {
            var center = this.getCenter(),
                    newCenter = this._limitCenter(center, this._zoom, bounds);

            if (center.equals(newCenter)) {
                return this;
            }

            return this.panTo(newCenter, options);
        },
        addLayer: function (layer) {
            // TODO method is too big, refactor

            var id = L.stamp(layer);

            if (this._layers[id]) {
                return this;
            }

            this._layers[id] = layer;

            // TODO getMaxZoom, getMinZoom in ILayer (instead of options)
            if (layer.options && (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom))) {
                this._zoomBoundLayers[id] = layer;
                this._updateZoomLevels();
            }

            // TODO looks ugly, refactor!!!
            if (this.options.zoomAnimation && L.TileLayer && (layer instanceof L.TileLayer)) {
                this._tileLayersNum++;
                this._tileLayersToLoad++;
                layer.on('load', this._onTileLayerLoad, this);
            }

            if (this._loaded) {
                this._layerAdd(layer);
            }

            return this;
        },
        removeLayer: function (layer) {
            var id = L.stamp(layer);

            if (!this._layers[id]) {
                return this;
            }

            if (this._loaded) {
                layer.onRemove(this);
            }

            delete this._layers[id];

            if (this._loaded) {
                this.fire('layerremove', {layer: layer});
            }

            if (this._zoomBoundLayers[id]) {
                delete this._zoomBoundLayers[id];
                this._updateZoomLevels();
            }

            // TODO looks ugly, refactor
            if (this.options.zoomAnimation && L.TileLayer && (layer instanceof L.TileLayer)) {
                this._tileLayersNum--;
                this._tileLayersToLoad--;
                layer.off('load', this._onTileLayerLoad, this);
            }

            return this;
        },
        hasLayer: function (layer) {
            if (!layer) {
                return false;
            }

            return (L.stamp(layer) in this._layers);
        },
        eachLayer: function (method, context) {
            for (var i in this._layers) {
                method.call(context, this._layers[i]);
            }
            return this;
        },
        invalidateSize: function (options) {
            if (!this._loaded) {
                return this;
            }

            options = L.extend({
                animate: false,
                pan: true
            }, options === true ? {animate: true} : options);

            var oldSize = this.getSize();
            this._sizeChanged = true;
            this._initialCenter = null;

            var newSize = this.getSize(),
                    oldCenter = oldSize.divideBy(2).round(),
                    newCenter = newSize.divideBy(2).round(),
                    offset = oldCenter.subtract(newCenter);

            if (!offset.x && !offset.y) {
                return this;
            }

            if (options.animate && options.pan) {
                this.panBy(offset);

            } else {
                if (options.pan) {
                    this._rawPanBy(offset);
                }

                this.fire('move');

                if (options.debounceMoveend) {
                    clearTimeout(this._sizeTimer);
                    this._sizeTimer = setTimeout(L.bind(this.fire, this, 'moveend'), 200);
                } else {
                    this.fire('moveend');
                }
            }

            return this.fire('resize', {
                oldSize: oldSize,
                newSize: newSize
            });
        },
        // TODO handler.addTo
        addHandler: function (name, HandlerClass) {
            if (!HandlerClass) {
                return this;
            }

            var handler = this[name] = new HandlerClass(this);

            this._handlers.push(handler);

            if (this.options[name]) {
                handler.enable();
            }

            return this;
        },
        remove: function () {
            if (this._loaded) {
                this.fire('unload');
            }

            this._initEvents('off');

            try {
                // throws error in IE6-8
                delete this._container._leaflet;
            } catch (e) {
                this._container._leaflet = undefined;
            }

            this._clearPanes();
            if (this._clearControlPos) {
                this._clearControlPos();
            }

            this._clearHandlers();

            return this;
        },
        // public methods for getting map state

        getCenter: function () { // (Boolean) -> LatLng
            this._checkIfLoaded();

            if (this._initialCenter && !this._moved()) {
                return this._initialCenter;
            }
            return this.layerPointToLatLng(this._getCenterLayerPoint());
        },
        getZoom: function () {
            return this._zoom;
        },
        getBounds: function () {
            var bounds = this.getPixelBounds(),
                    sw = this.unproject(bounds.getBottomLeft()),
                    ne = this.unproject(bounds.getTopRight());

            return new L.LatLngBounds(sw, ne);
        },
        getMinZoom: function () {
            return this.options.minZoom === undefined ?
                    (this._layersMinZoom === undefined ? 0 : this._layersMinZoom) :
                    this.options.minZoom;
        },
        getMaxZoom: function () {
            return this.options.maxZoom === undefined ?
                    (this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :
                    this.options.maxZoom;
        },
        getBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number
            bounds = L.latLngBounds(bounds);

            var zoom = this.getMinZoom() - (inside ? 1 : 0),
                    maxZoom = this.getMaxZoom(),
                    size = this.getSize(),
                    nw = bounds.getNorthWest(),
                    se = bounds.getSouthEast(),
                    zoomNotFound = true,
                    boundsSize;

            padding = L.point(padding || [0, 0]);

            do {
                zoom++;
                boundsSize = this.project(se, zoom).subtract(this.project(nw, zoom)).add(padding);
                zoomNotFound = !inside ? size.contains(boundsSize) : boundsSize.x < size.x || boundsSize.y < size.y;

            } while (zoomNotFound && zoom <= maxZoom);

            if (zoomNotFound && inside) {
                return null;
            }

            return inside ? zoom : zoom - 1;
        },
        getSize: function () {
            if (!this._size || this._sizeChanged) {
                this._size = new L.Point(
                        this._container.clientWidth,
                        this._container.clientHeight);

                this._sizeChanged = false;
            }
            return this._size.clone();
        },
        getPixelBounds: function () {
            var topLeftPoint = this._getTopLeftPoint();
            return new L.Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
        },
        getPixelOrigin: function () {
            this._checkIfLoaded();
            return this._initialTopLeftPoint;
        },
        getPanes: function () {
            return this._panes;
        },
        getContainer: function () {
            return this._container;
        },
        // TODO replace with universal implementation after refactoring projections

        getZoomScale: function (toZoom) {
            var crs = this.options.crs;
            return crs.scale(toZoom) / crs.scale(this._zoom);
        },
        getScaleZoom: function (scale) {
            return this._zoom + (Math.log(scale) / Math.LN2);
        },
        // conversion methods

        project: function (latlng, zoom) { // (LatLng[, Number]) -> Point
            zoom = zoom === undefined ? this._zoom : zoom;
            return this.options.crs.latLngToPoint(L.latLng(latlng), zoom);
        },
        unproject: function (point, zoom) { // (Point[, Number]) -> LatLng
            zoom = zoom === undefined ? this._zoom : zoom;
            return this.options.crs.pointToLatLng(L.point(point), zoom);
        },
        layerPointToLatLng: function (point) { // (Point)
            var projectedPoint = L.point(point).add(this.getPixelOrigin());
            return this.unproject(projectedPoint);
        },
        latLngToLayerPoint: function (latlng) { // (LatLng)
            var projectedPoint = this.project(L.latLng(latlng))._round();
            return projectedPoint._subtract(this.getPixelOrigin());
        },
        containerPointToLayerPoint: function (point) { // (Point)
            return L.point(point).subtract(this._getMapPanePos());
        },
        layerPointToContainerPoint: function (point) { // (Point)
            return L.point(point).add(this._getMapPanePos());
        },
        containerPointToLatLng: function (point) {
            var layerPoint = this.containerPointToLayerPoint(L.point(point));
            return this.layerPointToLatLng(layerPoint);
        },
        latLngToContainerPoint: function (latlng) {
            return this.layerPointToContainerPoint(this.latLngToLayerPoint(L.latLng(latlng)));
        },
        mouseEventToContainerPoint: function (e) { // (MouseEvent)
            return L.DomEvent.getMousePosition(e, this._container);
        },
        mouseEventToLayerPoint: function (e) { // (MouseEvent)
            return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
        },
        mouseEventToLatLng: function (e) { // (MouseEvent)
            return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
        },
        // map initialization methods

        _initContainer: function (id) {
            var container = this._container = L.DomUtil.get(id);

            if (!container) {
                throw new Error('Map container not found.');
            } else if (container._leaflet) {
                throw new Error('Map container is already initialized.');
            }

            container._leaflet = true;
        },
        _initLayout: function () {
            var container = this._container;

            L.DomUtil.addClass(container, 'leaflet-container' +
                    (L.Browser.touch ? ' leaflet-touch' : '') +
                    (L.Browser.retina ? ' leaflet-retina' : '') +
                    (L.Browser.ielt9 ? ' leaflet-oldie' : '') +
                    (this.options.fadeAnimation ? ' leaflet-fade-anim' : ''));

            var position = L.DomUtil.getStyle(container, 'position');

            if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {
                container.style.position = 'relative';
            }

            this._initPanes();

            if (this._initControlPos) {
                this._initControlPos();
            }
        },
        _initPanes: function () {
            var panes = this._panes = {};

            this._mapPane = panes.mapPane = this._createPane('leaflet-map-pane', this._container);

            this._tilePane = panes.tilePane = this._createPane('leaflet-tile-pane', this._mapPane);
            panes.objectsPane = this._createPane('leaflet-objects-pane', this._mapPane);
            panes.shadowPane = this._createPane('leaflet-shadow-pane');
            panes.overlayPane = this._createPane('leaflet-overlay-pane');
            panes.markerPane = this._createPane('leaflet-marker-pane');
            panes.popupPane = this._createPane('leaflet-popup-pane');

            var zoomHide = ' leaflet-zoom-hide';

            if (!this.options.markerZoomAnimation) {
                L.DomUtil.addClass(panes.markerPane, zoomHide);
                L.DomUtil.addClass(panes.shadowPane, zoomHide);
                L.DomUtil.addClass(panes.popupPane, zoomHide);
            }
        },
        _createPane: function (className, container) {
            return L.DomUtil.create('div', className, container || this._panes.objectsPane);
        },
        _clearPanes: function () {
            this._container.removeChild(this._mapPane);
        },
        _addLayers: function (layers) {
            layers = layers ? (L.Util.isArray(layers) ? layers : [layers]) : [];

            for (var i = 0, len = layers.length; i < len; i++) {
                this.addLayer(layers[i]);
            }
        },
        // private methods that modify map state

        _resetView: function (center, zoom, preserveMapOffset, afterZoomAnim) {

            var zoomChanged = (this._zoom !== zoom);

            if (!afterZoomAnim) {
                this.fire('movestart');

                if (zoomChanged) {
                    this.fire('zoomstart');
                }
            }

            this._zoom = zoom;
            this._initialCenter = center;

            this._initialTopLeftPoint = this._getNewTopLeftPoint(center);

            if (!preserveMapOffset) {
                L.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));
            } else {
                this._initialTopLeftPoint._add(this._getMapPanePos());
            }

            this._tileLayersToLoad = this._tileLayersNum;

            var loading = !this._loaded;
            this._loaded = true;

            this.fire('viewreset', {hard: !preserveMapOffset});

            if (loading) {
                this.fire('load');
                this.eachLayer(this._layerAdd, this);
            }

            this.fire('move');

            if (zoomChanged || afterZoomAnim) {
                this.fire('zoomend');
            }

            this.fire('moveend', {hard: !preserveMapOffset});
        },
        _rawPanBy: function (offset) {
            L.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
        },
        _getZoomSpan: function () {
            return this.getMaxZoom() - this.getMinZoom();
        },
        _updateZoomLevels: function () {
            var i,
                    minZoom = Infinity,
                    maxZoom = -Infinity,
                    oldZoomSpan = this._getZoomSpan();

            for (i in this._zoomBoundLayers) {
                var layer = this._zoomBoundLayers[i];
                if (!isNaN(layer.options.minZoom)) {
                    minZoom = Math.min(minZoom, layer.options.minZoom);
                }
                if (!isNaN(layer.options.maxZoom)) {
                    maxZoom = Math.max(maxZoom, layer.options.maxZoom);
                }
            }

            if (i === undefined) { // we have no tilelayers
                this._layersMaxZoom = this._layersMinZoom = undefined;
            } else {
                this._layersMaxZoom = maxZoom;
                this._layersMinZoom = minZoom;
            }

            if (oldZoomSpan !== this._getZoomSpan()) {
                this.fire('zoomlevelschange');
            }
        },
        _panInsideMaxBounds: function () {
            this.panInsideBounds(this.options.maxBounds);
        },
        _checkIfLoaded: function () {
            if (!this._loaded) {
                throw new Error('Set map center and zoom first.');
            }
        },
        // map events

        _initEvents: function (onOff) {
            if (!L.DomEvent) {
                return;
            }

            onOff = onOff || 'on';

            L.DomEvent[onOff](this._container, 'click', this._onMouseClick, this);

            var events = ['dblclick', 'mousedown', 'mouseup', 'mouseenter',
                'mouseleave', 'mousemove', 'contextmenu'],
                    i, len;

            for (i = 0, len = events.length; i < len; i++) {
                L.DomEvent[onOff](this._container, events[i], this._fireMouseEvent, this);
            }

            if (this.options.trackResize) {
                L.DomEvent[onOff](window, 'resize', this._onResize, this);
            }
        },
        _onResize: function () {
            L.Util.cancelAnimFrame(this._resizeRequest);
            this._resizeRequest = L.Util.requestAnimFrame(
                    function () {
                        this.invalidateSize({debounceMoveend: true});
                    }, this, false, this._container);
        },
        _onMouseClick: function (e) {
            if (!this._loaded || (!e._simulated &&
                    ((this.dragging && this.dragging.moved()) ||
                            (this.boxZoom && this.boxZoom.moved()))) ||
                    L.DomEvent._skipped(e)) {
                return;
            }

            this.fire('preclick');
            this._fireMouseEvent(e);
        },
        _fireMouseEvent: function (e) {
            if (!this._loaded || L.DomEvent._skipped(e)) {
                return;
            }

            var type = e.type;

            type = (type === 'mouseenter' ? 'mouseover' : (type === 'mouseleave' ? 'mouseout' : type));

            if (!this.hasEventListeners(type)) {
                return;
            }

            if (type === 'contextmenu') {
                L.DomEvent.preventDefault(e);
            }

            var containerPoint = this.mouseEventToContainerPoint(e),
                    layerPoint = this.containerPointToLayerPoint(containerPoint),
                    latlng = this.layerPointToLatLng(layerPoint);

            this.fire(type, {
                latlng: latlng,
                layerPoint: layerPoint,
                containerPoint: containerPoint,
                originalEvent: e
            });
        },
        _onTileLayerLoad: function () {
            this._tileLayersToLoad--;
            if (this._tileLayersNum && !this._tileLayersToLoad) {
                this.fire('tilelayersload');
            }
        },
        _clearHandlers: function () {
            for (var i = 0, len = this._handlers.length; i < len; i++) {
                this._handlers[i].disable();
            }
        },
        whenReady: function (callback, context) {
            if (this._loaded) {
                callback.call(context || this, this);
            } else {
                this.on('load', callback, context);
            }
            return this;
        },
        _layerAdd: function (layer) {
            layer.onAdd(this);
            this.fire('layeradd', {layer: layer});
        },
        // private methods for getting map state

        _getMapPanePos: function () {
            return L.DomUtil.getPosition(this._mapPane);
        },
        _moved: function () {
            var pos = this._getMapPanePos();
            return pos && !pos.equals([0, 0]);
        },
        _getTopLeftPoint: function () {
            return this.getPixelOrigin().subtract(this._getMapPanePos());
        },
        _getNewTopLeftPoint: function (center, zoom) {
            var viewHalf = this.getSize()._divideBy(2);
            // TODO round on display, not calculation to increase precision?
            return this.project(center, zoom)._subtract(viewHalf)._round();
        },
        _latLngToNewLayerPoint: function (latlng, newZoom, newCenter) {
            var topLeft = this._getNewTopLeftPoint(newCenter, newZoom).add(this._getMapPanePos());
            return this.project(latlng, newZoom)._subtract(topLeft);
        },
        // layer point of the current center
        _getCenterLayerPoint: function () {
            return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
        },
        // offset of the specified place to the current center in pixels
        _getCenterOffset: function (latlng) {
            return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
        },
        // adjust center for view to get inside bounds
        _limitCenter: function (center, zoom, bounds) {

            if (!bounds) {
                return center;
            }

            var centerPoint = this.project(center, zoom),
                    viewHalf = this.getSize().divideBy(2),
                    viewBounds = new L.Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
                    offset = this._getBoundsOffset(viewBounds, bounds, zoom);

            return this.unproject(centerPoint.add(offset), zoom);
        },
        // adjust offset for view to get inside bounds
        _limitOffset: function (offset, bounds) {
            if (!bounds) {
                return offset;
            }

            var viewBounds = this.getPixelBounds(),
                    newBounds = new L.Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));

            return offset.add(this._getBoundsOffset(newBounds, bounds));
        },
        // returns offset needed for pxBounds to get inside maxBounds at a specified zoom
        _getBoundsOffset: function (pxBounds, maxBounds, zoom) {
            var nwOffset = this.project(maxBounds.getNorthWest(), zoom).subtract(pxBounds.min),
                    seOffset = this.project(maxBounds.getSouthEast(), zoom).subtract(pxBounds.max),
                    dx = this._rebound(nwOffset.x, -seOffset.x),
                    dy = this._rebound(nwOffset.y, -seOffset.y);

            return new L.Point(dx, dy);
        },
        _rebound: function (left, right) {
            return left + right > 0 ?
                    Math.round(left - right) / 2 :
                    Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
        },
        _limitZoom: function (zoom) {
            var min = this.getMinZoom(),
                    max = this.getMaxZoom();

            return Math.max(min, Math.min(max, zoom));
        }
    });

    L.map = function (id, options) {
        return new L.Map(id, options);
    };


    /*
     * Mercator projection that takes into account that the Earth is not a perfect sphere.
     * Less popular than spherical mercator; used by projections like EPSG:3395.
     */

    L.Projection.Mercator = {
        MAX_LATITUDE: 85.0840591556,
        R_MINOR: 6356752.314245179,
        R_MAJOR: 6378137,
        project: function (latlng) { // (LatLng) -> Point
            var d = L.LatLng.DEG_TO_RAD,
                    max = this.MAX_LATITUDE,
                    lat = Math.max(Math.min(max, latlng.lat), -max),
                    r = this.R_MAJOR,
                    r2 = this.R_MINOR,
                    x = latlng.lng * d * r,
                    y = lat * d,
                    tmp = r2 / r,
                    eccent = Math.sqrt(1.0 - tmp * tmp),
                    con = eccent * Math.sin(y);

            con = Math.pow((1 - con) / (1 + con), eccent * 0.5);

            var ts = Math.tan(0.5 * ((Math.PI * 0.5) - y)) / con;
            y = -r * Math.log(ts);

            return new L.Point(x, y);
        },
        unproject: function (point) { // (Point, Boolean) -> LatLng
            var d = L.LatLng.RAD_TO_DEG,
                    r = this.R_MAJOR,
                    r2 = this.R_MINOR,
                    lng = point.x * d / r,
                    tmp = r2 / r,
                    eccent = Math.sqrt(1 - (tmp * tmp)),
                    ts = Math.exp(-point.y / r),
                    phi = (Math.PI / 2) - 2 * Math.atan(ts),
                    numIter = 15,
                    tol = 1e-7,
                    i = numIter,
                    dphi = 0.1,
                    con;

            while ((Math.abs(dphi) > tol) && (--i > 0)) {
                con = eccent * Math.sin(phi);
                dphi = (Math.PI / 2) - 2 * Math.atan(ts *
                        Math.pow((1.0 - con) / (1.0 + con), 0.5 * eccent)) - phi;
                phi += dphi;
            }

            return new L.LatLng(phi * d, lng);
        }
    };



    L.CRS.EPSG3395 = L.extend({}, L.CRS, {
        code: 'EPSG:3395',
        projection: L.Projection.Mercator,
        transformation: (function () {
            var m = L.Projection.Mercator,
                    r = m.R_MAJOR,
                    scale = 0.5 / (Math.PI * r);

            return new L.Transformation(scale, 0.5, -scale, 0.5);
        }())
    });


    /*
     * L.TileLayer is used for standard xyz-numbered tile layers.
     */

    L.TileLayer = L.Class.extend({
        includes: L.Mixin.Events,
        options: {
            minZoom: 0,
            maxZoom: 18,
            tileSize: 256,
            subdomains: 'abc',
            errorTileUrl: '',
            attribution: '',
            zoomOffset: 0,
            opacity: 1,
            /*
             maxNativeZoom: null,
             zIndex: null,
             tms: false,
             continuousWorld: false,
             noWrap: false,
             zoomReverse: false,
             detectRetina: false,
             reuseTiles: false,
             bounds: false,
             */
            unloadInvisibleTiles: L.Browser.mobile,
            updateWhenIdle: L.Browser.mobile
        },
        initialize: function (url, options) {
            options = L.setOptions(this, options);

            // detecting retina displays, adjusting tileSize and zoom levels
            if (options.detectRetina && L.Browser.retina && options.maxZoom > 0) {

                options.tileSize = Math.floor(options.tileSize / 2);
                options.zoomOffset++;

                if (options.minZoom > 0) {
                    options.minZoom--;
                }
                this.options.maxZoom--;
            }

            if (options.bounds) {
                options.bounds = L.latLngBounds(options.bounds);
            }

            this._url = url;

            var subdomains = this.options.subdomains;

            if (typeof subdomains === 'string') {
                this.options.subdomains = subdomains.split('');
            }
        },
        onAdd: function (map) {
            this._map = map;
            this._animated = map._zoomAnimated;

            // create a container div for tiles
            this._initContainer();

            // set up events
            map.on({
                'viewreset': this._reset,
                'moveend': this._update
            }, this);

            if (this._animated) {
                map.on({
                    'zoomanim': this._animateZoom,
                    'zoomend': this._endZoomAnim
                }, this);
            }

            if (!this.options.updateWhenIdle) {
                this._limitedUpdate = L.Util.limitExecByInterval(this._update, 150, this);
                map.on('move', this._limitedUpdate, this);
            }

            this._reset();
            this._update();
        },
        addTo: function (map) {
            map.addLayer(this);
            return this;
        },
        onRemove: function (map) {
            this._container.parentNode.removeChild(this._container);

            map.off({
                'viewreset': this._reset,
                'moveend': this._update
            }, this);

            if (this._animated) {
                map.off({
                    'zoomanim': this._animateZoom,
                    'zoomend': this._endZoomAnim
                }, this);
            }

            if (!this.options.updateWhenIdle) {
                map.off('move', this._limitedUpdate, this);
            }

            this._container = null;
            this._map = null;
        },
        bringToFront: function () {
            var pane = this._map._panes.tilePane;

            if (this._container) {
                pane.appendChild(this._container);
                this._setAutoZIndex(pane, Math.max);
            }

            return this;
        },
        bringToBack: function () {
            var pane = this._map._panes.tilePane;

            if (this._container) {
                pane.insertBefore(this._container, pane.firstChild);
                this._setAutoZIndex(pane, Math.min);
            }

            return this;
        },
        getAttribution: function () {
            return this.options.attribution;
        },
        getContainer: function () {
            return this._container;
        },
        setOpacity: function (opacity) {
            this.options.opacity = opacity;

            if (this._map) {
                this._updateOpacity();
            }

            return this;
        },
        setZIndex: function (zIndex) {
            this.options.zIndex = zIndex;
            this._updateZIndex();

            return this;
        },
        setUrl: function (url, noRedraw) {
            this._url = url;

            if (!noRedraw) {
                this.redraw();
            }

            return this;
        },
        redraw: function () {
            if (this._map) {
                this._reset({hard: true});
                this._update();
            }
            return this;
        },
        _updateZIndex: function () {
            if (this._container && this.options.zIndex !== undefined) {
                this._container.style.zIndex = this.options.zIndex;
            }
        },
        _setAutoZIndex: function (pane, compare) {

            var layers = pane.children,
                    edgeZIndex = -compare(Infinity, -Infinity), // -Infinity for max, Infinity for min
                    zIndex, i, len;

            for (i = 0, len = layers.length; i < len; i++) {

                if (layers[i] !== this._container) {
                    zIndex = parseInt(layers[i].style.zIndex, 10);

                    if (!isNaN(zIndex)) {
                        edgeZIndex = compare(edgeZIndex, zIndex);
                    }
                }
            }

            this.options.zIndex = this._container.style.zIndex =
                    (isFinite(edgeZIndex) ? edgeZIndex : 0) + compare(1, -1);
        },
        _updateOpacity: function () {
            var i,
                    tiles = this._tiles;

            if (L.Browser.ielt9) {
                for (i in tiles) {
                    L.DomUtil.setOpacity(tiles[i], this.options.opacity);
                }
            } else {
                L.DomUtil.setOpacity(this._container, this.options.opacity);
            }
        },
        _initContainer: function () {
            var tilePane = this._map._panes.tilePane;

            if (!this._container) {
                this._container = L.DomUtil.create('div', 'leaflet-layer');

                this._updateZIndex();

                if (this._animated) {
                    var className = 'leaflet-tile-container';

                    this._bgBuffer = L.DomUtil.create('div', className, this._container);
                    this._tileContainer = L.DomUtil.create('div', className, this._container);

                } else {
                    this._tileContainer = this._container;
                }

                tilePane.appendChild(this._container);

                if (this.options.opacity < 1) {
                    this._updateOpacity();
                }
            }
        },
        _reset: function (e) {
            for (var key in this._tiles) {
                this.fire('tileunload', {tile: this._tiles[key]});
            }

            this._tiles = {};
            this._tilesToLoad = 0;

            if (this.options.reuseTiles) {
                this._unusedTiles = [];
            }

            this._tileContainer.innerHTML = '';

            if (this._animated && e && e.hard) {
                this._clearBgBuffer();
            }

            this._initContainer();
        },
        _getTileSize: function () {
            var map = this._map,
                    zoom = map.getZoom() + this.options.zoomOffset,
                    zoomN = this.options.maxNativeZoom,
                    tileSize = this.options.tileSize;

            if (zoomN && zoom > zoomN) {
                tileSize = Math.round(map.getZoomScale(zoom) / map.getZoomScale(zoomN) * tileSize);
            }

            return tileSize;
        },
        _update: function () {

            if (!this._map) {
                return;
            }

            var map = this._map,
                    bounds = map.getPixelBounds(),
                    zoom = map.getZoom(),
                    tileSize = this._getTileSize();

            if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
                return;
            }

            var tileBounds = L.bounds(
                    bounds.min.divideBy(tileSize)._floor(),
                    bounds.max.divideBy(tileSize)._floor());

            this._addTilesFromCenterOut(tileBounds);

            if (this.options.unloadInvisibleTiles || this.options.reuseTiles) {
                this._removeOtherTiles(tileBounds);
            }
        },
        _addTilesFromCenterOut: function (bounds) {
            var queue = [],
                    center = bounds.getCenter();

            var j, i, point;

            for (j = bounds.min.y; j <= bounds.max.y; j++) {
                for (i = bounds.min.x; i <= bounds.max.x; i++) {
                    point = new L.Point(i, j);

                    if (this._tileShouldBeLoaded(point)) {
                        queue.push(point);
                    }
                }
            }

            var tilesToLoad = queue.length;

            if (tilesToLoad === 0) {
                return;
            }

            // load tiles in order of their distance to center
            queue.sort(function (a, b) {
                return a.distanceTo(center) - b.distanceTo(center);
            });

            var fragment = document.createDocumentFragment();

            // if its the first batch of tiles to load
            if (!this._tilesToLoad) {
                this.fire('loading');
            }

            this._tilesToLoad += tilesToLoad;

            for (i = 0; i < tilesToLoad; i++) {
                this._addTile(queue[i], fragment);
            }

            this._tileContainer.appendChild(fragment);
        },
        _tileShouldBeLoaded: function (tilePoint) {
            if ((tilePoint.x + ':' + tilePoint.y) in this._tiles) {
                return false; // already loaded
            }

            var options = this.options;

            if (!options.continuousWorld) {
                var limit = this._getWrapTileNum();

                // don't load if exceeds world bounds
                if ((options.noWrap && (tilePoint.x < 0 || tilePoint.x >= limit.x)) ||
                        tilePoint.y < 0 || tilePoint.y >= limit.y) {
                    return false;
                }
            }

            if (options.bounds) {
                var tileSize = options.tileSize,
                        nwPoint = tilePoint.multiplyBy(tileSize),
                        sePoint = nwPoint.add([tileSize, tileSize]),
                        nw = this._map.unproject(nwPoint),
                        se = this._map.unproject(sePoint);

                // TODO temporary hack, will be removed after refactoring projections
                // https://github.com/Leaflet/Leaflet/issues/1618
                if (!options.continuousWorld && !options.noWrap) {
                    nw = nw.wrap();
                    se = se.wrap();
                }

                if (!options.bounds.intersects([nw, se])) {
                    return false;
                }
            }

            return true;
        },
        _removeOtherTiles: function (bounds) {
            var kArr, x, y, key;

            for (key in this._tiles) {
                kArr = key.split(':');
                x = parseInt(kArr[0], 10);
                y = parseInt(kArr[1], 10);

                // remove tile if it's out of bounds
                if (x < bounds.min.x || x > bounds.max.x || y < bounds.min.y || y > bounds.max.y) {
                    this._removeTile(key);
                }
            }
        },
        _removeTile: function (key) {
            var tile = this._tiles[key];

            this.fire('tileunload', {tile: tile, url: tile.src});

            if (this.options.reuseTiles) {
                L.DomUtil.removeClass(tile, 'leaflet-tile-loaded');
                this._unusedTiles.push(tile);

            } else if (tile.parentNode === this._tileContainer) {
                this._tileContainer.removeChild(tile);
            }

            // for https://github.com/CloudMade/Leaflet/issues/137
            if (!L.Browser.android) {
                tile.onload = null;
                tile.src = L.Util.emptyImageUrl;
            }

            delete this._tiles[key];
        },
        _addTile: function (tilePoint, container) {
            var tilePos = this._getTilePos(tilePoint);

            // get unused tile - or create a new tile
            var tile = this._getTile();

            /*
             Chrome 20 layouts much faster with top/left (verify with timeline, frames)
             Android 4 browser has display issues with top/left and requires transform instead
             (other browsers don't currently care) - see debug/hacks/jitter.html for an example
             */
            L.DomUtil.setPosition(tile, tilePos, L.Browser.chrome);

            this._tiles[tilePoint.x + ':' + tilePoint.y] = tile;

            this._loadTile(tile, tilePoint);

            if (tile.parentNode !== this._tileContainer) {
                container.appendChild(tile);
            }
        },
        _getZoomForUrl: function () {

            var options = this.options,
                    zoom = this._map.getZoom();

            if (options.zoomReverse) {
                zoom = options.maxZoom - zoom;
            }

            zoom += options.zoomOffset;

            return options.maxNativeZoom ? Math.min(zoom, options.maxNativeZoom) : zoom;
        },
        _getTilePos: function (tilePoint) {
            var origin = this._map.getPixelOrigin(),
                    tileSize = this._getTileSize();

            return tilePoint.multiplyBy(tileSize).subtract(origin);
        },
        // image-specific code (override to implement e.g. Canvas or SVG tile layer)

        getTileUrl: function (tilePoint) {
            return L.Util.template(this._url, L.extend({
                s: this._getSubdomain(tilePoint),
                z: tilePoint.z,
                x: tilePoint.x,
                y: tilePoint.y
            }, this.options));
        },
        _getWrapTileNum: function () {
            var crs = this._map.options.crs,
                    size = crs.getSize(this._map.getZoom());
            return size.divideBy(this._getTileSize())._floor();
        },
        _adjustTilePoint: function (tilePoint) {

            var limit = this._getWrapTileNum();

            // wrap tile coordinates
            if (!this.options.continuousWorld && !this.options.noWrap) {
                tilePoint.x = ((tilePoint.x % limit.x) + limit.x) % limit.x;
            }

            if (this.options.tms) {
                tilePoint.y = limit.y - tilePoint.y - 1;
            }

            tilePoint.z = this._getZoomForUrl();
        },
        _getSubdomain: function (tilePoint) {
            var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
            return this.options.subdomains[index];
        },
        _getTile: function () {
            if (this.options.reuseTiles && this._unusedTiles.length > 0) {
                var tile = this._unusedTiles.pop();
                this._resetTile(tile);
                return tile;
            }
            return this._createTile();
        },
        // Override if data stored on a tile needs to be cleaned up before reuse
        _resetTile: function (/*tile*/) {
        },
        _createTile: function () {
            var tile = L.DomUtil.create('img', 'leaflet-tile');
            tile.style.width = tile.style.height = this._getTileSize() + 'px';
            tile.galleryimg = 'no';

            tile.onselectstart = tile.onmousemove = L.Util.falseFn;

            if (L.Browser.ielt9 && this.options.opacity !== undefined) {
                L.DomUtil.setOpacity(tile, this.options.opacity);
            }
            // without this hack, tiles disappear after zoom on Chrome for Android
            // https://github.com/Leaflet/Leaflet/issues/2078
            if (L.Browser.mobileWebkit3d) {
                tile.style.WebkitBackfaceVisibility = 'hidden';
            }
            return tile;
        },
        _loadTile: function (tile, tilePoint) {
            tile._layer = this;
            tile.onload = this._tileOnLoad;
            tile.onerror = this._tileOnError;

            this._adjustTilePoint(tilePoint);
            tile.src = this.getTileUrl(tilePoint);

            this.fire('tileloadstart', {
                tile: tile,
                url: tile.src
            });
        },
        _tileLoaded: function () {
            this._tilesToLoad--;

            if (this._animated) {
                L.DomUtil.addClass(this._tileContainer, 'leaflet-zoom-animated');
            }

            if (!this._tilesToLoad) {
                this.fire('load');

                if (this._animated) {
                    // clear scaled tiles after all new tiles are loaded (for performance)
                    clearTimeout(this._clearBgBufferTimer);
                    this._clearBgBufferTimer = setTimeout(L.bind(this._clearBgBuffer, this), 500);
                }
            }
        },
        _tileOnLoad: function () {
            var layer = this._layer;

            //Only if we are loading an actual image
            if (this.src !== L.Util.emptyImageUrl) {
                L.DomUtil.addClass(this, 'leaflet-tile-loaded');

                layer.fire('tileload', {
                    tile: this,
                    url: this.src
                });
            }

            layer._tileLoaded();
        },
        _tileOnError: function () {
            var layer = this._layer;

            layer.fire('tileerror', {
                tile: this,
                url: this.src
            });

            var newUrl = layer.options.errorTileUrl;
            if (newUrl) {
                this.src = newUrl;
            }

            layer._tileLoaded();
        }
    });

    L.tileLayer = function (url, options) {
        return new L.TileLayer(url, options);
    };


    /*
     * L.TileLayer.WMS is used for putting WMS tile layers on the map.
     */

    L.TileLayer.WMS = L.TileLayer.extend({
        defaultWmsParams: {
            service: 'WMS',
            request: 'GetMap',
            version: '1.1.1',
            layers: '',
            styles: '',
            format: 'image/jpeg',
            transparent: false
        },
        initialize: function (url, options) { // (String, Object)

            this._url = url;

            var wmsParams = L.extend({}, this.defaultWmsParams),
                    tileSize = options.tileSize || this.options.tileSize;

            if (options.detectRetina && L.Browser.retina) {
                wmsParams.width = wmsParams.height = tileSize * 2;
            } else {
                wmsParams.width = wmsParams.height = tileSize;
            }

            for (var i in options) {
                // all keys that are not TileLayer options go to WMS params
                if (!this.options.hasOwnProperty(i) && i !== 'crs') {
                    wmsParams[i] = options[i];
                }
            }

            this.wmsParams = wmsParams;

            L.setOptions(this, options);
        },
        onAdd: function (map) {
            if (this.options.srs && this.options.srs === 'EPSG:4326')
                this._crs = L.CRS.EPSG4326;
            else
                this._crs = this.options.crs || map.options.crs;

            this._wmsVersion = parseFloat(this.wmsParams.version);

            var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
            this.wmsParams[projectionKey] = this._crs.code;

            L.TileLayer.prototype.onAdd.call(this, map);
        },
        getTileUrl: function (tilePoint) { // (Point, Number) -> String

            var map = this._map,
                    tileSize = this.options.tileSize,
                    nwPoint = tilePoint.multiplyBy(tileSize),
                    sePoint = nwPoint.add([tileSize, tileSize]),
                    nw = this._crs.project(map.unproject(nwPoint, tilePoint.z)),
                    se = this._crs.project(map.unproject(sePoint, tilePoint.z)),
                    bbox = this._wmsVersion >= 1.3 && this._crs === L.CRS.EPSG4326 ?
                    [se.y, nw.x, nw.y, se.x].join(',') :
                    [nw.x, se.y, se.x, nw.y].join(','),
                    url = L.Util.template(this._url, {s: this._getSubdomain(tilePoint)});

            return url + L.Util.getParamString(this.wmsParams, url, true) + '&BBOX=' + bbox;
        },
        setParams: function (params, noRedraw) {

            L.extend(this.wmsParams, params);

            if (!noRedraw) {
                this.redraw();
            }

            return this;
        }
    });

    L.tileLayer.wms = function (url, options) {
        return new L.TileLayer.WMS(url, options);
    };


    /*
     * L.TileLayer.Canvas is a class that you can use as a base for creating
     * dynamically drawn Canvas-based tile layers.
     */

    L.TileLayer.Canvas = L.TileLayer.extend({
        options: {
            async: false
        },
        initialize: function (options) {
            L.setOptions(this, options);
        },
        redraw: function () {
            if (this._map) {
                this._reset({hard: true});
                this._update();
            }

            for (var i in this._tiles) {
                this._redrawTile(this._tiles[i]);
            }
            return this;
        },
        _redrawTile: function (tile) {
            this.drawTile(tile, tile._tilePoint, this._map._zoom);
        },
        _createTile: function () {
            var tile = L.DomUtil.create('canvas', 'leaflet-tile');
            tile.width = tile.height = this.options.tileSize;
            tile.onselectstart = tile.onmousemove = L.Util.falseFn;
            return tile;
        },
        _loadTile: function (tile, tilePoint) {
            tile._layer = this;
            tile._tilePoint = tilePoint;

            this._redrawTile(tile);

            if (!this.options.async) {
                this.tileDrawn(tile);
            }
        },
        drawTile: function (/*tile, tilePoint*/) {
            // override with rendering code
        },
        tileDrawn: function (tile) {
            this._tileOnLoad.call(tile);
        }
    });


    L.tileLayer.canvas = function (options) {
        return new L.TileLayer.Canvas(options);
    };


    /*
     * L.ImageOverlay is used to overlay images over the map (to specific geographical bounds).
     */

    L.ImageOverlay = L.Class.extend({
        includes: L.Mixin.Events,
        options: {
            opacity: 1
        },
        initialize: function (url, bounds, options) { // (String, LatLngBounds, Object)
            this._url = url;
            this._bounds = L.latLngBounds(bounds);

            L.setOptions(this, options);
        },
        onAdd: function (map) {
            this._map = map;

            if (!this._image) {
                this._initImage();
            }

            map._panes.overlayPane.appendChild(this._image);

            map.on('viewreset', this._reset, this);

            if (map.options.zoomAnimation && L.Browser.any3d) {
                map.on('zoomanim', this._animateZoom, this);
            }

            this._reset();
        },
        onRemove: function (map) {
            map.getPanes().overlayPane.removeChild(this._image);

            map.off('viewreset', this._reset, this);

            if (map.options.zoomAnimation) {
                map.off('zoomanim', this._animateZoom, this);
            }
        },
        addTo: function (map) {
            map.addLayer(this);
            return this;
        },
        setOpacity: function (opacity) {
            this.options.opacity = opacity;
            this._updateOpacity();
            return this;
        },
        // TODO remove bringToFront/bringToBack duplication from TileLayer/Path
        bringToFront: function () {
            if (this._image) {
                this._map._panes.overlayPane.appendChild(this._image);
            }
            return this;
        },
        bringToBack: function () {
            var pane = this._map._panes.overlayPane;
            if (this._image) {
                pane.insertBefore(this._image, pane.firstChild);
            }
            return this;
        },
        setUrl: function (url) {
            this._url = url;
            this._image.src = this._url;
        },
        getAttribution: function () {
            return this.options.attribution;
        },
        _initImage: function () {
            this._image = L.DomUtil.create('img', 'leaflet-image-layer');

            if (this._map.options.zoomAnimation && L.Browser.any3d) {
                L.DomUtil.addClass(this._image, 'leaflet-zoom-animated');
            } else {
                L.DomUtil.addClass(this._image, 'leaflet-zoom-hide');
            }

            this._updateOpacity();

            //TODO createImage util method to remove duplication
            L.extend(this._image, {
                galleryimg: 'no',
                onselectstart: L.Util.falseFn,
                onmousemove: L.Util.falseFn,
                onload: L.bind(this._onImageLoad, this),
                src: this._url
            });
        },
        _animateZoom: function (e) {
            var map = this._map,
                    image = this._image,
                    scale = map.getZoomScale(e.zoom),
                    nw = this._bounds.getNorthWest(),
                    se = this._bounds.getSouthEast(),
                    topLeft = map._latLngToNewLayerPoint(nw, e.zoom, e.center),
                    size = map._latLngToNewLayerPoint(se, e.zoom, e.center)._subtract(topLeft),
                    origin = topLeft._add(size._multiplyBy((1 / 2) * (1 - 1 / scale)));

            image.style[L.DomUtil.TRANSFORM] =
                    L.DomUtil.getTranslateString(origin) + ' scale(' + scale + ') ';
        },
        _reset: function () {
            var image = this._image,
                    topLeft = this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
                    size = this._map.latLngToLayerPoint(this._bounds.getSouthEast())._subtract(topLeft);

            L.DomUtil.setPosition(image, topLeft);

            image.style.width = size.x + 'px';
            image.style.height = size.y + 'px';
        },
        _onImageLoad: function () {
            this.fire('load');
        },
        _updateOpacity: function () {
            L.DomUtil.setOpacity(this._image, this.options.opacity);
        }
    });

    L.imageOverlay = function (url, bounds, options) {
        return new L.ImageOverlay(url, bounds, options);
    };


    /*
     * L.Icon is an image-based icon class that you can use with L.Marker for custom markers.
     */

    L.Icon = L.Class.extend({
        options: {
            /*
             iconUrl: (String) (required)
             iconRetinaUrl: (String) (optional, used for retina devices if detected)
             iconSize: (Point) (can be set through CSS)
             iconAnchor: (Point) (centered by default, can be set in CSS with negative margins)
             popupAnchor: (Point) (if not specified, popup opens in the anchor point)
             shadowUrl: (String) (no shadow by default)
             shadowRetinaUrl: (String) (optional, used for retina devices if detected)
             shadowSize: (Point)
             shadowAnchor: (Point)
             */
            className: ''
        },
        initialize: function (options) {
            L.setOptions(this, options);
        },
        createIcon: function (oldIcon) {
            return this._createIcon('icon', oldIcon);
        },
        createShadow: function (oldIcon) {
            return this._createIcon('shadow', oldIcon);
        },
        _createIcon: function (name, oldIcon) {
            var src = this._getIconUrl(name);

            if (!src) {
                if (name === 'icon') {
                    throw new Error('iconUrl not set in Icon options (see the docs).');
                }
                return null;
            }

            var img;
            if (!oldIcon || oldIcon.tagName !== 'IMG') {
                img = this._createImg(src);
            } else {
                img = this._createImg(src, oldIcon);
            }
            this._setIconStyles(img, name);

            return img;
        },
        _setIconStyles: function (img, name) {
            var options = this.options,
                    size = L.point(options[name + 'Size']),
                    anchor;

            if (name === 'shadow') {
                anchor = L.point(options.shadowAnchor || options.iconAnchor);
            } else {
                anchor = L.point(options.iconAnchor);
            }

            if (!anchor && size) {
                anchor = size.divideBy(2, true);
            }

            img.className = 'leaflet-marker-' + name + ' ' + options.className;

            if (anchor) {
                img.style.marginLeft = (-anchor.x) + 'px';
                img.style.marginTop = (-anchor.y) + 'px';
            }

            if (size) {
                img.style.width = size.x + 'px';
                img.style.height = size.y + 'px';
            }
        },
        _createImg: function (src, el) {
            el = el || document.createElement('img');
            el.src = src;
            return el;
        },
        _getIconUrl: function (name) {
            if (L.Browser.retina && this.options[name + 'RetinaUrl']) {
                return this.options[name + 'RetinaUrl'];
            }
            return this.options[name + 'Url'];
        }
    });

    L.icon = function (options) {
        return new L.Icon(options);
    };


    /*
     * L.Icon.Default is the blue marker icon used by default in Leaflet.
     */

    L.Icon.Default = L.Icon.extend({
        options: {
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41]
        },
        _getIconUrl: function (name) {
            var key = name + 'Url';

            if (this.options[key]) {
                return this.options[key];
            }

            if (L.Browser.retina && name === 'icon') {
                name += '-2x';
            }

            var path = L.Icon.Default.imagePath;

            if (!path) {
                throw new Error('Couldn\'t autodetect L.Icon.Default.imagePath, set it manually.');
            }

            return path + '/marker-' + name + '.png';
        }
    });

    L.Icon.Default.imagePath = (function () {
        var scripts = document.getElementsByTagName('script'),
                leafletRe = /[\/^]leaflet[\-\._]?([\w\-\._]*)\.js\??/;

        var i, len, src, matches, path;

        for (i = 0, len = scripts.length; i < len; i++) {
            src = scripts[i].src;
            matches = src.match(leafletRe);

            if (matches) {
                path = src.split(leafletRe)[0];
                return (path ? path + '/' : '') + 'images';
            }
        }
    }());


    /*
     * L.Marker is used to display clickable/draggable icons on the map.
     */

    L.Marker = L.Class.extend({
        includes: L.Mixin.Events,
        options: {
            icon: new L.Icon.Default(),
            title: '',
            alt: '',
            clickable: true,
            draggable: false,
            keyboard: true,
            zIndexOffset: 0,
            opacity: 1,
            riseOnHover: false,
            riseOffset: 250
        },
        initialize: function (latlng, options) {
            L.setOptions(this, options);
            this._latlng = L.latLng(latlng);
        },
        onAdd: function (map) {
            this._map = map;

            map.on('viewreset', this.update, this);

            this._initIcon();
            this.update();
            this.fire('add');

            if (map.options.zoomAnimation && map.options.markerZoomAnimation) {
                map.on('zoomanim', this._animateZoom, this);
            }
        },
        addTo: function (map) {
            map.addLayer(this);
            return this;
        },
        onRemove: function (map) {
            if (this.dragging) {
                this.dragging.disable();
            }

            this._removeIcon();
            this._removeShadow();

            this.fire('remove');

            map.off({
                'viewreset': this.update,
                'zoomanim': this._animateZoom
            }, this);

            this._map = null;
        },
        getLatLng: function () {
            return this._latlng;
        },
        setLatLng: function (latlng) {
            this._latlng = L.latLng(latlng);

            this.update();

            return this.fire('move', {latlng: this._latlng});
        },
        setZIndexOffset: function (offset) {
            this.options.zIndexOffset = offset;
            this.update();

            return this;
        },
        setIcon: function (icon) {

            this.options.icon = icon;

            if (this._map) {
                this._initIcon();
                this.update();
            }

            if (this._popup) {
                this.bindPopup(this._popup);
            }

            return this;
        },
        update: function () {
            if (this._icon) {
                var pos = this._map.latLngToLayerPoint(this._latlng).round();
                this._setPos(pos);
            }

            return this;
        },
        _initIcon: function () {
            var options = this.options,
                    map = this._map,
                    animation = (map.options.zoomAnimation && map.options.markerZoomAnimation),
                    classToAdd = animation ? 'leaflet-zoom-animated' : 'leaflet-zoom-hide';

            var icon = options.icon.createIcon(this._icon),
                    addIcon = false;

            // if we're not reusing the icon, remove the old one and init new one
            if (icon !== this._icon) {
                if (this._icon) {
                    this._removeIcon();
                }
                addIcon = true;

                if (options.title) {
                    icon.title = options.title;
                }

                if (options.alt) {
                    icon.alt = options.alt;
                }
            }

            L.DomUtil.addClass(icon, classToAdd);

            if (options.keyboard) {
                icon.tabIndex = '0';
            }

            this._icon = icon;

            this._initInteraction();

            if (options.riseOnHover) {
                L.DomEvent
                        .on(icon, 'mouseover', this._bringToFront, this)
                        .on(icon, 'mouseout', this._resetZIndex, this);
            }

            var newShadow = options.icon.createShadow(this._shadow),
                    addShadow = false;

            if (newShadow !== this._shadow) {
                this._removeShadow();
                addShadow = true;
            }

            if (newShadow) {
                L.DomUtil.addClass(newShadow, classToAdd);
            }
            this._shadow = newShadow;


            if (options.opacity < 1) {
                this._updateOpacity();
            }


            var panes = this._map._panes;

            if (addIcon) {
                panes.markerPane.appendChild(this._icon);
            }

            if (newShadow && addShadow) {
                panes.shadowPane.appendChild(this._shadow);
            }
        },
        _removeIcon: function () {
            if (this.options.riseOnHover) {
                L.DomEvent
                        .off(this._icon, 'mouseover', this._bringToFront)
                        .off(this._icon, 'mouseout', this._resetZIndex);
            }

            this._map._panes.markerPane.removeChild(this._icon);

            this._icon = null;
        },
        _removeShadow: function () {
            if (this._shadow) {
                this._map._panes.shadowPane.removeChild(this._shadow);
            }
            this._shadow = null;
        },
        _setPos: function (pos) {
            L.DomUtil.setPosition(this._icon, pos);

            if (this._shadow) {
                L.DomUtil.setPosition(this._shadow, pos);
            }

            this._zIndex = pos.y + this.options.zIndexOffset;

            this._resetZIndex();
        },
        _updateZIndex: function (offset) {
            this._icon.style.zIndex = this._zIndex + offset;
        },
        _animateZoom: function (opt) {
            var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();

            this._setPos(pos);
        },
        _initInteraction: function () {

            if (!this.options.clickable) {
                return;
            }

            // TODO refactor into something shared with Map/Path/etc. to DRY it up

            var icon = this._icon,
                    events = ['dblclick', 'mousedown', 'mouseover', 'mouseout', 'contextmenu'];

            L.DomUtil.addClass(icon, 'leaflet-clickable');
            L.DomEvent.on(icon, 'click', this._onMouseClick, this);
            L.DomEvent.on(icon, 'keypress', this._onKeyPress, this);

            for (var i = 0; i < events.length; i++) {
                L.DomEvent.on(icon, events[i], this._fireMouseEvent, this);
            }

            if (L.Handler.MarkerDrag) {
                this.dragging = new L.Handler.MarkerDrag(this);

                if (this.options.draggable) {
                    this.dragging.enable();
                }
            }
        },
        _onMouseClick: function (e) {
            var wasDragged = this.dragging && this.dragging.moved();

            if (this.hasEventListeners(e.type) || wasDragged) {
                L.DomEvent.stopPropagation(e);
            }

            if (wasDragged) {
                return;
            }

            if ((!this.dragging || !this.dragging._enabled) && this._map.dragging && this._map.dragging.moved()) {
                return;
            }

            this.fire(e.type, {
                originalEvent: e,
                latlng: this._latlng
            });
        },
        _onKeyPress: function (e) {
            if (e.keyCode === 13) {
                this.fire('click', {
                    originalEvent: e,
                    latlng: this._latlng
                });
            }
        },
        _fireMouseEvent: function (e) {

            this.fire(e.type, {
                originalEvent: e,
                latlng: this._latlng
            });

            // TODO proper custom event propagation
            // this line will always be called if marker is in a FeatureGroup
            if (e.type === 'contextmenu' && this.hasEventListeners(e.type)) {
                L.DomEvent.preventDefault(e);
            }
            if (e.type !== 'mousedown') {
                L.DomEvent.stopPropagation(e);
            } else {
                L.DomEvent.preventDefault(e);
            }
        },
        setOpacity: function (opacity) {
            this.options.opacity = opacity;
            if (this._map) {
                this._updateOpacity();
            }

            return this;
        },
        _updateOpacity: function () {
            L.DomUtil.setOpacity(this._icon, this.options.opacity);
            if (this._shadow) {
                L.DomUtil.setOpacity(this._shadow, this.options.opacity);
            }
        },
        _bringToFront: function () {
            this._updateZIndex(this.options.riseOffset);
        },
        _resetZIndex: function () {
            this._updateZIndex(0);
        }
    });

    L.marker = function (latlng, options) {
        return new L.Marker(latlng, options);
    };


    /*
     * L.DivIcon is a lightweight HTML-based icon class (as opposed to the image-based L.Icon)
     * to use with L.Marker.
     */

    L.DivIcon = L.Icon.extend({
        options: {
            iconSize: [12, 12], // also can be set through CSS
            /*
             iconAnchor: (Point)
             popupAnchor: (Point)
             html: (String)
             bgPos: (Point)
             */
            className: 'leaflet-div-icon',
            html: false
        },
        createIcon: function (oldIcon) {
            var div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),
                    options = this.options;

            if (options.html !== false) {
                div.innerHTML = options.html;
            } else {
                div.innerHTML = '';
            }

            if (options.bgPos) {
                div.style.backgroundPosition =
                        (-options.bgPos.x) + 'px ' + (-options.bgPos.y) + 'px';
            }

            this._setIconStyles(div, 'icon');
            return div;
        },
        createShadow: function () {
            return null;
        }
    });

    L.divIcon = function (options) {
        return new L.DivIcon(options);
    };


    /*
     * L.Popup is used for displaying popups on the map.
     */

    L.Map.mergeOptions({
        closePopupOnClick: true
    });

    L.Popup = L.Class.extend({
        includes: L.Mixin.Events,
        options: {
            minWidth: 50,
            maxWidth: 300,
            // maxHeight: null,
            autoPan: true,
            closeButton: true,
            offset: [0, 7],
            autoPanPadding: [5, 5],
            // autoPanPaddingTopLeft: null,
            // autoPanPaddingBottomRight: null,
            keepInView: false,
            className: '',
            zoomAnimation: true
        },
        initialize: function (options, source) {
            L.setOptions(this, options);

            this._source = source;
            this._animated = L.Browser.any3d && this.options.zoomAnimation;
            this._isOpen = false;
        },
        onAdd: function (map) {
            this._map = map;

            if (!this._container) {
                this._initLayout();
            }

            var animFade = map.options.fadeAnimation;

            if (animFade) {
                L.DomUtil.setOpacity(this._container, 0);
            }
            map._panes.popupPane.appendChild(this._container);

            map.on(this._getEvents(), this);

            this.update();

            if (animFade) {
                L.DomUtil.setOpacity(this._container, 1);
            }

            this.fire('open');

            map.fire('popupopen', {popup: this});

            if (this._source) {
                this._source.fire('popupopen', {popup: this});
            }
        },
        addTo: function (map) {
            map.addLayer(this);
            return this;
        },
        openOn: function (map) {
            map.openPopup(this);
            return this;
        },
        onRemove: function (map) {
            map._panes.popupPane.removeChild(this._container);

            L.Util.falseFn(this._container.offsetWidth); // force reflow

            map.off(this._getEvents(), this);

            if (map.options.fadeAnimation) {
                L.DomUtil.setOpacity(this._container, 0);
            }

            this._map = null;

            this.fire('close');

            map.fire('popupclose', {popup: this});

            if (this._source) {
                this._source.fire('popupclose', {popup: this});
            }
        },
        getLatLng: function () {
            return this._latlng;
        },
        setLatLng: function (latlng) {
            this._latlng = L.latLng(latlng);
            if (this._map) {
                this._updatePosition();
                this._adjustPan();
            }
            return this;
        },
        getContent: function () {
            return this._content;
        },
        setContent: function (content) {
            this._content = content;
            this.update();
            return this;
        },
        update: function () {
            if (!this._map) {
                return;
            }

            this._container.style.visibility = 'hidden';

            this._updateContent();
            this._updateLayout();
            this._updatePosition();

            this._container.style.visibility = '';

            this._adjustPan();
        },
        _getEvents: function () {
            var events = {
                viewreset: this._updatePosition
            };

            if (this._animated) {
                events.zoomanim = this._zoomAnimation;
            }
            if ('closeOnClick' in this.options ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
                events.preclick = this._close;
            }
            if (this.options.keepInView) {
                events.moveend = this._adjustPan;
            }

            return events;
        },
        _close: function () {
            if (this._map) {
                this._map.closePopup(this);
            }
        },
        _initLayout: function () {
            var prefix = 'leaflet-popup',
                    containerClass = prefix + ' ' + this.options.className + ' leaflet-zoom-' +
                    (this._animated ? 'animated' : 'hide'),
                    container = this._container = L.DomUtil.create('div', containerClass),
                    closeButton;

            if (this.options.closeButton) {
                closeButton = this._closeButton =
                        L.DomUtil.create('a', prefix + '-close-button', container);
                closeButton.href = '#close';
                closeButton.innerHTML = '&#215;';
                L.DomEvent.disableClickPropagation(closeButton);

                L.DomEvent.on(closeButton, 'click', this._onCloseButtonClick, this);
            }

            var wrapper = this._wrapper =
                    L.DomUtil.create('div', prefix + '-content-wrapper', container);
            L.DomEvent.disableClickPropagation(wrapper);

            this._contentNode = L.DomUtil.create('div', prefix + '-content', wrapper);

            L.DomEvent.disableScrollPropagation(this._contentNode);
            L.DomEvent.on(wrapper, 'contextmenu', L.DomEvent.stopPropagation);

            this._tipContainer = L.DomUtil.create('div', prefix + '-tip-container', container);
            this._tip = L.DomUtil.create('div', prefix + '-tip', this._tipContainer);
        },
        _updateContent: function () {
            if (!this._content) {
                return;
            }

            if (typeof this._content === 'string') {
                this._contentNode.innerHTML = this._content;
            } else {
                while (this._contentNode.hasChildNodes()) {
                    this._contentNode.removeChild(this._contentNode.firstChild);
                }
                this._contentNode.appendChild(this._content);
            }
            this.fire('contentupdate');
        },
        _updateLayout: function () {
            var container = this._contentNode,
                    style = container.style;

            style.width = '';
            style.whiteSpace = 'nowrap';

            var width = container.offsetWidth;
            width = Math.min(width, this.options.maxWidth);
            width = Math.max(width, this.options.minWidth);

            style.width = (width + 1) + 'px';
            style.whiteSpace = '';

            style.height = '';

            var height = container.offsetHeight,
                    maxHeight = this.options.maxHeight,
                    scrolledClass = 'leaflet-popup-scrolled';

            if (maxHeight && height > maxHeight) {
                style.height = maxHeight + 'px';
                L.DomUtil.addClass(container, scrolledClass);
            } else {
                L.DomUtil.removeClass(container, scrolledClass);
            }

            this._containerWidth = this._container.offsetWidth;
        },
        _updatePosition: function () {
            if (!this._map) {
                return;
            }

            var pos = this._map.latLngToLayerPoint(this._latlng),
                    animated = this._animated,
                    offset = L.point(this.options.offset);

            if (animated) {
                L.DomUtil.setPosition(this._container, pos);
            }

            this._containerBottom = -offset.y - (animated ? 0 : pos.y);
            this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x + (animated ? 0 : pos.x);

            // bottom position the popup in case the height of the popup changes (images loading etc)
            this._container.style.bottom = this._containerBottom + 'px';
            this._container.style.left = this._containerLeft + 'px';
        },
        _zoomAnimation: function (opt) {
            var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center);

            L.DomUtil.setPosition(this._container, pos);
        },
        _adjustPan: function () {
            if (!this.options.autoPan) {
                return;
            }

            var map = this._map,
                    containerHeight = this._container.offsetHeight,
                    containerWidth = this._containerWidth,
                    layerPos = new L.Point(this._containerLeft, -containerHeight - this._containerBottom);

            if (this._animated) {
                layerPos._add(L.DomUtil.getPosition(this._container));
            }

            var containerPos = map.layerPointToContainerPoint(layerPos),
                    padding = L.point(this.options.autoPanPadding),
                    paddingTL = L.point(this.options.autoPanPaddingTopLeft || padding),
                    paddingBR = L.point(this.options.autoPanPaddingBottomRight || padding),
                    size = map.getSize(),
                    dx = 0,
                    dy = 0;

            if (containerPos.x + containerWidth + paddingBR.x > size.x) { // right
                dx = containerPos.x + containerWidth - size.x + paddingBR.x;
            }
            if (containerPos.x - dx - paddingTL.x < 0) { // left
                dx = containerPos.x - paddingTL.x;
            }
            if (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom
                dy = containerPos.y + containerHeight - size.y + paddingBR.y;
            }
            if (containerPos.y - dy - paddingTL.y < 0) { // top
                dy = containerPos.y - paddingTL.y;
            }

            if (dx || dy) {
                map
                        .fire('autopanstart')
                        .panBy([dx, dy]);
            }
        },
        _onCloseButtonClick: function (e) {
            this._close();
            L.DomEvent.stop(e);
        }
    });

    L.popup = function (options, source) {
        return new L.Popup(options, source);
    };


    L.Map.include({
        openPopup: function (popup, latlng, options) { // (Popup) or (String || HTMLElement, LatLng[, Object])
            this.closePopup();

            if (!(popup instanceof L.Popup)) {
                var content = popup;

                popup = new L.Popup(options)
                        .setLatLng(latlng)
                        .setContent(content);
            }
            popup._isOpen = true;

            this._popup = popup;
            return this.addLayer(popup);
        },
        closePopup: function (popup) {
            if (!popup || popup === this._popup) {
                popup = this._popup;
                this._popup = null;
            }
            if (popup) {
                this.removeLayer(popup);
                popup._isOpen = false;
            }
            return this;
        }
    });


    /*
     * Popup extension to L.Marker, adding popup-related methods.
     */

    L.Marker.include({
        openPopup: function () {
            if (this._popup && this._map && !this._map.hasLayer(this._popup)) {
                this._popup.setLatLng(this._latlng);
                this._map.openPopup(this._popup);
            }

            return this;
        },
        closePopup: function () {
            if (this._popup) {
                this._popup._close();
            }
            return this;
        },
        togglePopup: function () {
            if (this._popup) {
                if (this._popup._isOpen) {
                    this.closePopup();
                } else {
                    this.openPopup();
                }
            }
            return this;
        },
        bindPopup: function (content, options) {
            var anchor = L.point(this.options.icon.options.popupAnchor || [0, 0]);

            anchor = anchor.add(L.Popup.prototype.options.offset);

            if (options && options.offset) {
                anchor = anchor.add(options.offset);
            }

            options = L.extend({offset: anchor}, options);

            if (!this._popupHandlersAdded) {
                this
                        .on('click', this.togglePopup, this)
                        .on('remove', this.closePopup, this)
                        .on('move', this._movePopup, this);
                this._popupHandlersAdded = true;
            }

            if (content instanceof L.Popup) {
                L.setOptions(content, options);
                this._popup = content;
            } else {
                this._popup = new L.Popup(options, this)
                        .setContent(content);
            }

            return this;
        },
        setPopupContent: function (content) {
            if (this._popup) {
                this._popup.setContent(content);
            }
            return this;
        },
        unbindPopup: function () {
            if (this._popup) {
                this._popup = null;
                this
                        .off('click', this.togglePopup, this)
                        .off('remove', this.closePopup, this)
                        .off('move', this._movePopup, this);
                this._popupHandlersAdded = false;
            }
            return this;
        },
        getPopup: function () {
            return this._popup;
        },
        _movePopup: function (e) {
            this._popup.setLatLng(e.latlng);
        }
    });


    /*
     * L.LayerGroup is a class to combine several layers into one so that
     * you can manipulate the group (e.g. add/remove it) as one layer.
     */

    L.LayerGroup = L.Class.extend({
        initialize: function (layers) {
            this._layers = {};

            var i, len;

            if (layers) {
                for (i = 0, len = layers.length; i < len; i++) {
                    this.addLayer(layers[i]);
                }
            }
        },
        addLayer: function (layer) {
            var id = this.getLayerId(layer);

            this._layers[id] = layer;

            if (this._map) {
                this._map.addLayer(layer);
            }

            return this;
        },
        removeLayer: function (layer) {
            var id = layer in this._layers ? layer : this.getLayerId(layer);

            if (this._map && this._layers[id]) {
                this._map.removeLayer(this._layers[id]);
            }

            delete this._layers[id];

            return this;
        },
        hasLayer: function (layer) {
            if (!layer) {
                return false;
            }

            return (layer in this._layers || this.getLayerId(layer) in this._layers);
        },
        clearLayers: function () {
            this.eachLayer(this.removeLayer, this);
            return this;
        },
        invoke: function (methodName) {
            var args = Array.prototype.slice.call(arguments, 1),
                    i, layer;

            for (i in this._layers) {
                layer = this._layers[i];

                if (layer[methodName]) {
                    layer[methodName].apply(layer, args);
                }
            }

            return this;
        },
        onAdd: function (map) {
            this._map = map;
            this.eachLayer(map.addLayer, map);
        },
        onRemove: function (map) {
            this.eachLayer(map.removeLayer, map);
            this._map = null;
        },
        addTo: function (map) {
            map.addLayer(this);
            return this;
        },
        eachLayer: function (method, context) {
            for (var i in this._layers) {
                method.call(context, this._layers[i]);
            }
            return this;
        },
        getLayer: function (id) {
            return this._layers[id];
        },
        getLayers: function () {
            var layers = [];

            for (var i in this._layers) {
                layers.push(this._layers[i]);
            }
            return layers;
        },
        setZIndex: function (zIndex) {
            return this.invoke('setZIndex', zIndex);
        },
        getLayerId: function (layer) {
            return L.stamp(layer);
        }
    });

    L.layerGroup = function (layers) {
        return new L.LayerGroup(layers);
    };


    /*
     * L.FeatureGroup extends L.LayerGroup by introducing mouse events and additional methods
     * shared between a group of interactive layers (like vectors or markers).
     */

    L.FeatureGroup = L.LayerGroup.extend({
        includes: L.Mixin.Events,
        statics: {
            EVENTS: 'click dblclick mouseover mouseout mousemove contextmenu popupopen popupclose'
        },
        addLayer: function (layer) {
            if (this.hasLayer(layer)) {
                return this;
            }

            if ('on' in layer) {
                layer.on(L.FeatureGroup.EVENTS, this._propagateEvent, this);
            }

            L.LayerGroup.prototype.addLayer.call(this, layer);

            if (this._popupContent && layer.bindPopup) {
                layer.bindPopup(this._popupContent, this._popupOptions);
            }

            return this.fire('layeradd', {layer: layer});
        },
        removeLayer: function (layer) {
            if (!this.hasLayer(layer)) {
                return this;
            }
            if (layer in this._layers) {
                layer = this._layers[layer];
            }

            layer.off(L.FeatureGroup.EVENTS, this._propagateEvent, this);

            L.LayerGroup.prototype.removeLayer.call(this, layer);

            if (this._popupContent) {
                this.invoke('unbindPopup');
            }

            return this.fire('layerremove', {layer: layer});
        },
        bindPopup: function (content, options) {
            this._popupContent = content;
            this._popupOptions = options;
            return this.invoke('bindPopup', content, options);
        },
        openPopup: function (latlng) {
            // open popup on the first layer
            for (var id in this._layers) {
                this._layers[id].openPopup(latlng);
                break;
            }
            return this;
        },
        setStyle: function (style) {
            return this.invoke('setStyle', style);
        },
        bringToFront: function () {
            return this.invoke('bringToFront');
        },
        bringToBack: function () {
            return this.invoke('bringToBack');
        },
        getBounds: function () {
            var bounds = new L.LatLngBounds();

            this.eachLayer(function (layer) {
                bounds.extend(layer instanceof L.Marker ? layer.getLatLng() : layer.getBounds());
            });

            return bounds;
        },
        _propagateEvent: function (e) {
            e = L.extend({
                layer: e.target,
                target: this
            }, e);
            this.fire(e.type, e);
        }
    });

    L.featureGroup = function (layers) {
        return new L.FeatureGroup(layers);
    };


    /*
     * L.Path is a base class for rendering vector paths on a map. Inherited by Polyline, Circle, etc.
     */

    L.Path = L.Class.extend({
        includes: [L.Mixin.Events],
        statics: {
            // how much to extend the clip area around the map view
            // (relative to its size, e.g. 0.5 is half the screen in each direction)
            // set it so that SVG element doesn't exceed 1280px (vectors flicker on dragend if it is)
            CLIP_PADDING: (function () {
                var max = L.Browser.mobile ? 1280 : 2000,
                        target = (max / Math.max(window.outerWidth, window.outerHeight) - 1) / 2;
                return Math.max(0, Math.min(0.5, target));
            })()
        },
        options: {
            stroke: true,
            color: '#0033ff',
            dashArray: null,
            lineCap: null,
            lineJoin: null,
            weight: 5,
            opacity: 0.5,
            fill: false,
            fillColor: null, //same as color by default
            fillOpacity: 0.2,
            clickable: true
        },
        initialize: function (options) {
            L.setOptions(this, options);
        },
        onAdd: function (map) {
            this._map = map;

            if (!this._container) {
                this._initElements();
                this._initEvents();
            }

            this.projectLatlngs();
            this._updatePath();

            if (this._container) {
                this._map._pathRoot.appendChild(this._container);
            }

            this.fire('add');

            map.on({
                'viewreset': this.projectLatlngs,
                'moveend': this._updatePath
            }, this);
        },
        addTo: function (map) {
            map.addLayer(this);
            return this;
        },
        onRemove: function (map) {
            map._pathRoot.removeChild(this._container);

            // Need to fire remove event before we set _map to null as the event hooks might need the object
            this.fire('remove');
            this._map = null;

            if (L.Browser.vml) {
                this._container = null;
                this._stroke = null;
                this._fill = null;
            }

            map.off({
                'viewreset': this.projectLatlngs,
                'moveend': this._updatePath
            }, this);
        },
        projectLatlngs: function () {
            // do all projection stuff here
        },
        setStyle: function (style) {
            L.setOptions(this, style);

            if (this._container) {
                this._updateStyle();
            }

            return this;
        },
        redraw: function () {
            if (this._map) {
                this.projectLatlngs();
                this._updatePath();
            }
            return this;
        }
    });

    L.Map.include({
        _updatePathViewport: function () {
            var p = L.Path.CLIP_PADDING,
                    size = this.getSize(),
                    panePos = L.DomUtil.getPosition(this._mapPane),
                    min = panePos.multiplyBy(-1)._subtract(size.multiplyBy(p)._round()),
                    max = min.add(size.multiplyBy(1 + p * 2)._round());

            this._pathViewport = new L.Bounds(min, max);
        }
    });


    /*
     * Extends L.Path with SVG-specific rendering code.
     */

    L.Path.SVG_NS = 'http://www.w3.org/2000/svg';

    L.Browser.svg = !!(document.createElementNS && document.createElementNS(L.Path.SVG_NS, 'svg').createSVGRect);

    L.Path = L.Path.extend({
        statics: {
            SVG: L.Browser.svg
        },
        bringToFront: function () {
            var root = this._map._pathRoot,
                    path = this._container;

            if (path && root.lastChild !== path) {
                root.appendChild(path);
            }
            return this;
        },
        bringToBack: function () {
            var root = this._map._pathRoot,
                    path = this._container,
                    first = root.firstChild;

            if (path && first !== path) {
                root.insertBefore(path, first);
            }
            return this;
        },
        getPathString: function () {
            // form path string here
        },
        _createElement: function (name) {
            return document.createElementNS(L.Path.SVG_NS, name);
        },
        _initElements: function () {
            this._map._initPathRoot();
            this._initPath();
            this._initStyle();
        },
        _initPath: function () {
            this._container = this._createElement('g');

            this._path = this._createElement('path');

            if (this.options.className) {
                L.DomUtil.addClass(this._path, this.options.className);
            }

            this._container.appendChild(this._path);
        },
        _initStyle: function () {
            if (this.options.stroke) {
                this._path.setAttribute('stroke-linejoin', 'round');
                this._path.setAttribute('stroke-linecap', 'round');
            }
            if (this.options.fill) {
                this._path.setAttribute('fill-rule', 'evenodd');
            }
            if (this.options.pointerEvents) {
                this._path.setAttribute('pointer-events', this.options.pointerEvents);
            }
            if (!this.options.clickable && !this.options.pointerEvents) {
                this._path.setAttribute('pointer-events', 'none');
            }
            this._updateStyle();
        },
        _updateStyle: function () {
            if (this.options.stroke) {
                this._path.setAttribute('stroke', this.options.color);
                this._path.setAttribute('stroke-opacity', this.options.opacity);
                this._path.setAttribute('stroke-width', this.options.weight);
                if (this.options.dashArray) {
                    this._path.setAttribute('stroke-dasharray', this.options.dashArray);
                } else {
                    this._path.removeAttribute('stroke-dasharray');
                }
                if (this.options.lineCap) {
                    this._path.setAttribute('stroke-linecap', this.options.lineCap);
                }
                if (this.options.lineJoin) {
                    this._path.setAttribute('stroke-linejoin', this.options.lineJoin);
                }
            } else {
                this._path.setAttribute('stroke', 'none');
            }
            if (this.options.fill) {
                this._path.setAttribute('fill', this.options.fillColor || this.options.color);
                this._path.setAttribute('fill-opacity', this.options.fillOpacity);
            } else {
                this._path.setAttribute('fill', 'none');
            }
        },
        _updatePath: function () {
            var str = this.getPathString();
            if (!str) {
                // fix webkit empty string parsing bug
                str = 'M0 0';
            }
            this._path.setAttribute('d', str);
        },
        // TODO remove duplication with L.Map
        _initEvents: function () {
            if (this.options.clickable) {
                if (L.Browser.svg || !L.Browser.vml) {
                    L.DomUtil.addClass(this._path, 'leaflet-clickable');
                }

                L.DomEvent.on(this._container, 'click', this._onMouseClick, this);

                var events = ['dblclick', 'mousedown', 'mouseover',
                    'mouseout', 'mousemove', 'contextmenu'];
                for (var i = 0; i < events.length; i++) {
                    L.DomEvent.on(this._container, events[i], this._fireMouseEvent, this);
                }
            }
        },
        _onMouseClick: function (e) {
            if (this._map.dragging && this._map.dragging.moved()) {
                return;
            }

            this._fireMouseEvent(e);
        },
        _fireMouseEvent: function (e) {
            if (!this.hasEventListeners(e.type)) {
                return;
            }

            var map = this._map,
                    containerPoint = map.mouseEventToContainerPoint(e),
                    layerPoint = map.containerPointToLayerPoint(containerPoint),
                    latlng = map.layerPointToLatLng(layerPoint);

            this.fire(e.type, {
                latlng: latlng,
                layerPoint: layerPoint,
                containerPoint: containerPoint,
                originalEvent: e
            });

            if (e.type === 'contextmenu') {
                L.DomEvent.preventDefault(e);
            }
            if (e.type !== 'mousemove') {
                L.DomEvent.stopPropagation(e);
            }
        }
    });

    L.Map.include({
        _initPathRoot: function () {
            if (!this._pathRoot) {
                this._pathRoot = L.Path.prototype._createElement('svg');
                this._panes.overlayPane.appendChild(this._pathRoot);

                if (this.options.zoomAnimation && L.Browser.any3d) {
                    L.DomUtil.addClass(this._pathRoot, 'leaflet-zoom-animated');

                    this.on({
                        'zoomanim': this._animatePathZoom,
                        'zoomend': this._endPathZoom
                    });
                } else {
                    L.DomUtil.addClass(this._pathRoot, 'leaflet-zoom-hide');
                }

                this.on('moveend', this._updateSvgViewport);
                this._updateSvgViewport();
            }
        },
        _animatePathZoom: function (e) {
            var scale = this.getZoomScale(e.zoom),
                    offset = this._getCenterOffset(e.center)._multiplyBy(-scale)._add(this._pathViewport.min);

            this._pathRoot.style[L.DomUtil.TRANSFORM] =
                    L.DomUtil.getTranslateString(offset) + ' scale(' + scale + ') ';

            this._pathZooming = true;
        },
        _endPathZoom: function () {
            this._pathZooming = false;
        },
        _updateSvgViewport: function () {

            if (this._pathZooming) {
                // Do not update SVGs while a zoom animation is going on otherwise the animation will break.
                // When the zoom animation ends we will be updated again anyway
                // This fixes the case where you do a momentum move and zoom while the move is still ongoing.
                return;
            }

            this._updatePathViewport();

            var vp = this._pathViewport,
                    min = vp.min,
                    max = vp.max,
                    width = max.x - min.x,
                    height = max.y - min.y,
                    root = this._pathRoot,
                    pane = this._panes.overlayPane;

            // Hack to make flicker on drag end on mobile webkit less irritating
            if (L.Browser.mobileWebkit) {
                pane.removeChild(root);
            }

            L.DomUtil.setPosition(root, min);
            root.setAttribute('width', width);
            root.setAttribute('height', height);
            root.setAttribute('viewBox', [min.x, min.y, width, height].join(' '));

            if (L.Browser.mobileWebkit) {
                pane.appendChild(root);
            }
        }
    });


    /*
     * Popup extension to L.Path (polylines, polygons, circles), adding popup-related methods.
     */

    L.Path.include({
        bindPopup: function (content, options) {

            if (content instanceof L.Popup) {
                this._popup = content;
            } else {
                if (!this._popup || options) {
                    this._popup = new L.Popup(options, this);
                }
                this._popup.setContent(content);
            }

            if (!this._popupHandlersAdded) {
                this
                        .on('click', this._openPopup, this)
                        .on('remove', this.closePopup, this);

                this._popupHandlersAdded = true;
            }

            return this;
        },
        unbindPopup: function () {
            if (this._popup) {
                this._popup = null;
                this
                        .off('click', this._openPopup)
                        .off('remove', this.closePopup);

                this._popupHandlersAdded = false;
            }
            return this;
        },
        openPopup: function (latlng) {

            if (this._popup) {
                // open the popup from one of the path's points if not specified
                latlng = latlng || this._latlng ||
                        this._latlngs[Math.floor(this._latlngs.length / 2)];

                this._openPopup({latlng: latlng});
            }

            return this;
        },
        closePopup: function () {
            if (this._popup) {
                this._popup._close();
            }
            return this;
        },
        _openPopup: function (e) {
            this._popup.setLatLng(e.latlng);
            this._map.openPopup(this._popup);
        }
    });


    /*
     * Vector rendering for IE6-8 through VML.
     * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!
     */

    L.Browser.vml = !L.Browser.svg && (function () {
        try {
            var div = document.createElement('div');
            div.innerHTML = '<v:shape adj="1"/>';

            var shape = div.firstChild;
            shape.style.behavior = 'url(#default#VML)';

            return shape && (typeof shape.adj === 'object');

        } catch (e) {
            return false;
        }
    }());

    L.Path = L.Browser.svg || !L.Browser.vml ? L.Path : L.Path.extend({
        statics: {
            VML: true,
            CLIP_PADDING: 0.02
        },
        _createElement: (function () {
            try {
                document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');
                return function (name) {
                    return document.createElement('<lvml:' + name + ' class="lvml">');
                };
            } catch (e) {
                return function (name) {
                    return document.createElement(
                            '<' + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
                };
            }
        }()),
        _initPath: function () {
            var container = this._container = this._createElement('shape');

            L.DomUtil.addClass(container, 'leaflet-vml-shape' +
                    (this.options.className ? ' ' + this.options.className : ''));

            if (this.options.clickable) {
                L.DomUtil.addClass(container, 'leaflet-clickable');
            }

            container.coordsize = '1 1';

            this._path = this._createElement('path');
            container.appendChild(this._path);

            this._map._pathRoot.appendChild(container);
        },
        _initStyle: function () {
            this._updateStyle();
        },
        _updateStyle: function () {
            var stroke = this._stroke,
                    fill = this._fill,
                    options = this.options,
                    container = this._container;

            container.stroked = options.stroke;
            container.filled = options.fill;

            if (options.stroke) {
                if (!stroke) {
                    stroke = this._stroke = this._createElement('stroke');
                    stroke.endcap = 'round';
                    container.appendChild(stroke);
                }
                stroke.weight = options.weight + 'px';
                stroke.color = options.color;
                stroke.opacity = options.opacity;

                if (options.dashArray) {
                    stroke.dashStyle = L.Util.isArray(options.dashArray) ?
                            options.dashArray.join(' ') :
                            options.dashArray.replace(/( *, *)/g, ' ');
                } else {
                    stroke.dashStyle = '';
                }
                if (options.lineCap) {
                    stroke.endcap = options.lineCap.replace('butt', 'flat');
                }
                if (options.lineJoin) {
                    stroke.joinstyle = options.lineJoin;
                }

            } else if (stroke) {
                container.removeChild(stroke);
                this._stroke = null;
            }

            if (options.fill) {
                if (!fill) {
                    fill = this._fill = this._createElement('fill');
                    container.appendChild(fill);
                }
                fill.color = options.fillColor || options.color;
                fill.opacity = options.fillOpacity;

            } else if (fill) {
                container.removeChild(fill);
                this._fill = null;
            }
        },
        _updatePath: function () {
            var style = this._container.style;

            style.display = 'none';
            this._path.v = this.getPathString() + ' '; // the space fixes IE empty path string bug
            style.display = '';
        }
    });

    L.Map.include(L.Browser.svg || !L.Browser.vml ? {} : {
        _initPathRoot: function () {
            if (this._pathRoot) {
                return;
            }

            var root = this._pathRoot = document.createElement('div');
            root.className = 'leaflet-vml-container';
            this._panes.overlayPane.appendChild(root);

            this.on('moveend', this._updatePathViewport);
            this._updatePathViewport();
        }
    });


    /*
     * Vector rendering for all browsers that support canvas.
     */

    L.Browser.canvas = (function () {
        return !!document.createElement('canvas').getContext;
    }());

    L.Path = (L.Path.SVG && !window.L_PREFER_CANVAS) || !L.Browser.canvas ? L.Path : L.Path.extend({
        statics: {
            //CLIP_PADDING: 0.02, // not sure if there's a need to set it to a small value
            CANVAS: true,
            SVG: false
        },
        redraw: function () {
            if (this._map) {
                this.projectLatlngs();
                this._requestUpdate();
            }
            return this;
        },
        setStyle: function (style) {
            L.setOptions(this, style);

            if (this._map) {
                this._updateStyle();
                this._requestUpdate();
            }
            return this;
        },
        onRemove: function (map) {
            map
                    .off('viewreset', this.projectLatlngs, this)
                    .off('moveend', this._updatePath, this);

            if (this.options.clickable) {
                this._map.off('click', this._onClick, this);
                this._map.off('mousemove', this._onMouseMove, this);
            }

            this._requestUpdate();

            this.fire('remove');
            this._map = null;
        },
        _requestUpdate: function () {
            if (this._map && !L.Path._updateRequest) {
                L.Path._updateRequest = L.Util.requestAnimFrame(this._fireMapMoveEnd, this._map);
            }
        },
        _fireMapMoveEnd: function () {
            L.Path._updateRequest = null;
            this.fire('moveend');
        },
        _initElements: function () {
            this._map._initPathRoot();
            this._ctx = this._map._canvasCtx;
        },
        _updateStyle: function () {
            var options = this.options;

            if (options.stroke) {
                this._ctx.lineWidth = options.weight;
                this._ctx.strokeStyle = options.color;
            }
            if (options.fill) {
                this._ctx.fillStyle = options.fillColor || options.color;
            }
        },
        _drawPath: function () {
            var i, j, len, len2, point, drawMethod;

            this._ctx.beginPath();

            for (i = 0, len = this._parts.length; i < len; i++) {
                for (j = 0, len2 = this._parts[i].length; j < len2; j++) {
                    point = this._parts[i][j];
                    drawMethod = (j === 0 ? 'move' : 'line') + 'To';

                    this._ctx[drawMethod](point.x, point.y);
                }
                // TODO refactor ugly hack
                if (this instanceof L.Polygon) {
                    this._ctx.closePath();
                }
            }
        },
        _checkIfEmpty: function () {
            return !this._parts.length;
        },
        _updatePath: function () {
            if (this._checkIfEmpty()) {
                return;
            }

            var ctx = this._ctx,
                    options = this.options;

            this._drawPath();
            ctx.save();
            this._updateStyle();

            if (options.fill) {
                ctx.globalAlpha = options.fillOpacity;
                ctx.fill();
            }

            if (options.stroke) {
                ctx.globalAlpha = options.opacity;
                ctx.stroke();
            }

            ctx.restore();

            // TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature
        },
        _initEvents: function () {
            if (this.options.clickable) {
                // TODO dblclick
                this._map.on('mousemove', this._onMouseMove, this);
                this._map.on('click', this._onClick, this);
            }
        },
        _onClick: function (e) {
            if (this._containsPoint(e.layerPoint)) {
                this.fire('click', e);
            }
        },
        _onMouseMove: function (e) {
            if (!this._map || this._map._animatingZoom) {
                return;
            }

            // TODO don't do on each move
            if (this._containsPoint(e.layerPoint)) {
                this._ctx.canvas.style.cursor = 'pointer';
                this._mouseInside = true;
                this.fire('mouseover', e);

            } else if (this._mouseInside) {
                this._ctx.canvas.style.cursor = '';
                this._mouseInside = false;
                this.fire('mouseout', e);
            }
        }
    });

    L.Map.include((L.Path.SVG && !window.L_PREFER_CANVAS) || !L.Browser.canvas ? {} : {
        _initPathRoot: function () {
            var root = this._pathRoot,
                    ctx;

            if (!root) {
                root = this._pathRoot = document.createElement('canvas');
                root.style.position = 'absolute';
                ctx = this._canvasCtx = root.getContext('2d');

                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                this._panes.overlayPane.appendChild(root);

                if (this.options.zoomAnimation) {
                    this._pathRoot.className = 'leaflet-zoom-animated';
                    this.on('zoomanim', this._animatePathZoom);
                    this.on('zoomend', this._endPathZoom);
                }
                this.on('moveend', this._updateCanvasViewport);
                this._updateCanvasViewport();
            }
        },
        _updateCanvasViewport: function () {
            // don't redraw while zooming. See _updateSvgViewport for more details
            if (this._pathZooming) {
                return;
            }
            this._updatePathViewport();

            var vp = this._pathViewport,
                    min = vp.min,
                    size = vp.max.subtract(min),
                    root = this._pathRoot;

            //TODO check if this works properly on mobile webkit
            L.DomUtil.setPosition(root, min);
            root.width = size.x;
            root.height = size.y;
            root.getContext('2d').translate(-min.x, -min.y);
        }
    });


    /*
     * L.LineUtil contains different utility functions for line segments
     * and polylines (clipping, simplification, distances, etc.)
     */

    /*jshint bitwise:false */ // allow bitwise operations for this file

    L.LineUtil = {
        // Simplify polyline with vertex reduction and Douglas-Peucker simplification.
        // Improves rendering performance dramatically by lessening the number of points to draw.

        simplify: function (/*Point[]*/ points, /*Number*/ tolerance) {
            if (!tolerance || !points.length) {
                return points.slice();
            }

            var sqTolerance = tolerance * tolerance;

            // stage 1: vertex reduction
            points = this._reducePoints(points, sqTolerance);

            // stage 2: Douglas-Peucker simplification
            points = this._simplifyDP(points, sqTolerance);

            return points;
        },
        // distance from a point to a segment between two points
        pointToSegmentDistance: function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {
            return Math.sqrt(this._sqClosestPointOnSegment(p, p1, p2, true));
        },
        closestPointOnSegment: function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {
            return this._sqClosestPointOnSegment(p, p1, p2);
        },
        // Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm
        _simplifyDP: function (points, sqTolerance) {

            var len = points.length,
                    ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,
                    markers = new ArrayConstructor(len);

            markers[0] = markers[len - 1] = 1;

            this._simplifyDPStep(points, markers, sqTolerance, 0, len - 1);

            var i,
                    newPoints = [];

            for (i = 0; i < len; i++) {
                if (markers[i]) {
                    newPoints.push(points[i]);
                }
            }

            return newPoints;
        },
        _simplifyDPStep: function (points, markers, sqTolerance, first, last) {

            var maxSqDist = 0,
                    index, i, sqDist;

            for (i = first + 1; i <= last - 1; i++) {
                sqDist = this._sqClosestPointOnSegment(points[i], points[first], points[last], true);

                if (sqDist > maxSqDist) {
                    index = i;
                    maxSqDist = sqDist;
                }
            }

            if (maxSqDist > sqTolerance) {
                markers[index] = 1;

                this._simplifyDPStep(points, markers, sqTolerance, first, index);
                this._simplifyDPStep(points, markers, sqTolerance, index, last);
            }
        },
        // reduce points that are too close to each other to a single point
        _reducePoints: function (points, sqTolerance) {
            var reducedPoints = [points[0]];

            for (var i = 1, prev = 0, len = points.length; i < len; i++) {
                if (this._sqDist(points[i], points[prev]) > sqTolerance) {
                    reducedPoints.push(points[i]);
                    prev = i;
                }
            }
            if (prev < len - 1) {
                reducedPoints.push(points[len - 1]);
            }
            return reducedPoints;
        },
        // Cohen-Sutherland line clipping algorithm.
        // Used to avoid rendering parts of a polyline that are not currently visible.

        clipSegment: function (a, b, bounds, useLastCode) {
            var codeA = useLastCode ? this._lastCode : this._getBitCode(a, bounds),
                    codeB = this._getBitCode(b, bounds),
                    codeOut, p, newCode;

            // save 2nd code to avoid calculating it on the next segment
            this._lastCode = codeB;

            while (true) {
                // if a,b is inside the clip window (trivial accept)
                if (!(codeA | codeB)) {
                    return [a, b];
                    // if a,b is outside the clip window (trivial reject)
                } else if (codeA & codeB) {
                    return false;
                    // other cases
                } else {
                    codeOut = codeA || codeB;
                    p = this._getEdgeIntersection(a, b, codeOut, bounds);
                    newCode = this._getBitCode(p, bounds);

                    if (codeOut === codeA) {
                        a = p;
                        codeA = newCode;
                    } else {
                        b = p;
                        codeB = newCode;
                    }
                }
            }
        },
        _getEdgeIntersection: function (a, b, code, bounds) {
            var dx = b.x - a.x,
                    dy = b.y - a.y,
                    min = bounds.min,
                    max = bounds.max;

            if (code & 8) { // top
                return new L.Point(a.x + dx * (max.y - a.y) / dy, max.y);
            } else if (code & 4) { // bottom
                return new L.Point(a.x + dx * (min.y - a.y) / dy, min.y);
            } else if (code & 2) { // right
                return new L.Point(max.x, a.y + dy * (max.x - a.x) / dx);
            } else if (code & 1) { // left
                return new L.Point(min.x, a.y + dy * (min.x - a.x) / dx);
            }
        },
        _getBitCode: function (/*Point*/ p, bounds) {
            var code = 0;

            if (p.x < bounds.min.x) { // left
                code |= 1;
            } else if (p.x > bounds.max.x) { // right
                code |= 2;
            }
            if (p.y < bounds.min.y) { // bottom
                code |= 4;
            } else if (p.y > bounds.max.y) { // top
                code |= 8;
            }

            return code;
        },
        // square distance (to avoid unnecessary Math.sqrt calls)
        _sqDist: function (p1, p2) {
            var dx = p2.x - p1.x,
                    dy = p2.y - p1.y;
            return dx * dx + dy * dy;
        },
        // return closest point on segment or distance to that point
        _sqClosestPointOnSegment: function (p, p1, p2, sqDist) {
            var x = p1.x,
                    y = p1.y,
                    dx = p2.x - x,
                    dy = p2.y - y,
                    dot = dx * dx + dy * dy,
                    t;

            if (dot > 0) {
                t = ((p.x - x) * dx + (p.y - y) * dy) / dot;

                if (t > 1) {
                    x = p2.x;
                    y = p2.y;
                } else if (t > 0) {
                    x += dx * t;
                    y += dy * t;
                }
            }

            dx = p.x - x;
            dy = p.y - y;

            return sqDist ? dx * dx + dy * dy : new L.Point(x, y);
        }
    };


    /*
     * L.Polyline is used to display polylines on a map.
     */

    L.Polyline = L.Path.extend({
        initialize: function (latlngs, options) {
            L.Path.prototype.initialize.call(this, options);

            this._latlngs = this._convertLatLngs(latlngs);
        },
        options: {
            // how much to simplify the polyline on each zoom level
            // more = better performance and smoother look, less = more accurate
            smoothFactor: 1.0,
            noClip: false
        },
        projectLatlngs: function () {
            this._originalPoints = [];

            for (var i = 0, len = this._latlngs.length; i < len; i++) {
                this._originalPoints[i] = this._map.latLngToLayerPoint(this._latlngs[i]);
            }
        },
        getPathString: function () {
            for (var i = 0, len = this._parts.length, str = ''; i < len; i++) {
                str += this._getPathPartStr(this._parts[i]);
            }
            return str;
        },
        getLatLngs: function () {
            return this._latlngs;
        },
        setLatLngs: function (latlngs) {
            this._latlngs = this._convertLatLngs(latlngs);
            return this.redraw();
        },
        addLatLng: function (latlng) {
            this._latlngs.push(L.latLng(latlng));
            return this.redraw();
        },
        spliceLatLngs: function () { // (Number index, Number howMany)
            var removed = [].splice.apply(this._latlngs, arguments);
            this._convertLatLngs(this._latlngs, true);
            this.redraw();
            return removed;
        },
        closestLayerPoint: function (p) {
            var minDistance = Infinity, parts = this._parts, p1, p2, minPoint = null;

            for (var j = 0, jLen = parts.length; j < jLen; j++) {
                var points = parts[j];
                for (var i = 1, len = points.length; i < len; i++) {
                    p1 = points[i - 1];
                    p2 = points[i];
                    var sqDist = L.LineUtil._sqClosestPointOnSegment(p, p1, p2, true);
                    if (sqDist < minDistance) {
                        minDistance = sqDist;
                        minPoint = L.LineUtil._sqClosestPointOnSegment(p, p1, p2);
                    }
                }
            }
            if (minPoint) {
                minPoint.distance = Math.sqrt(minDistance);
            }
            return minPoint;
        },
        getBounds: function () {
            return new L.LatLngBounds(this.getLatLngs());
        },
        _convertLatLngs: function (latlngs, overwrite) {
            var i, len, target = overwrite ? latlngs : [];

            for (i = 0, len = latlngs.length; i < len; i++) {
                if (L.Util.isArray(latlngs[i]) && typeof latlngs[i][0] !== 'number') {
                    return;
                }
                target[i] = L.latLng(latlngs[i]);
            }
            return target;
        },
        _initEvents: function () {
            L.Path.prototype._initEvents.call(this);
        },
        _getPathPartStr: function (points) {
            var round = L.Path.VML;

            for (var j = 0, len2 = points.length, str = '', p; j < len2; j++) {
                p = points[j];
                if (round) {
                    p._round();
                }
                str += (j ? 'L' : 'M') + p.x + ' ' + p.y;
            }
            return str;
        },
        _clipPoints: function () {
            var points = this._originalPoints,
                    len = points.length,
                    i, k, segment;

            if (this.options.noClip) {
                this._parts = [points];
                return;
            }

            this._parts = [];

            var parts = this._parts,
                    vp = this._map._pathViewport,
                    lu = L.LineUtil;

            for (i = 0, k = 0; i < len - 1; i++) {
                segment = lu.clipSegment(points[i], points[i + 1], vp, i);
                if (!segment) {
                    continue;
                }

                parts[k] = parts[k] || [];
                parts[k].push(segment[0]);

                // if segment goes out of screen, or it's the last one, it's the end of the line part
                if ((segment[1] !== points[i + 1]) || (i === len - 2)) {
                    parts[k].push(segment[1]);
                    k++;
                }
            }
        },
        // simplify each clipped part of the polyline
        _simplifyPoints: function () {
            var parts = this._parts,
                    lu = L.LineUtil;

            for (var i = 0, len = parts.length; i < len; i++) {
                parts[i] = lu.simplify(parts[i], this.options.smoothFactor);
            }
        },
        _updatePath: function () {
            if (!this._map) {
                return;
            }

            this._clipPoints();
            this._simplifyPoints();

            L.Path.prototype._updatePath.call(this);
        }
    });

    L.polyline = function (latlngs, options) {
        return new L.Polyline(latlngs, options);
    };


    /*
     * L.PolyUtil contains utility functions for polygons (clipping, etc.).
     */

    /*jshint bitwise:false */ // allow bitwise operations here

    L.PolyUtil = {};

    /*
     * Sutherland-Hodgeman polygon clipping algorithm.
     * Used to avoid rendering parts of a polygon that are not currently visible.
     */
    L.PolyUtil.clipPolygon = function (points, bounds) {
        var clippedPoints,
                edges = [1, 4, 2, 8],
                i, j, k,
                a, b,
                len, edge, p,
                lu = L.LineUtil;

        for (i = 0, len = points.length; i < len; i++) {
            points[i]._code = lu._getBitCode(points[i], bounds);
        }

        // for each edge (left, bottom, right, top)
        for (k = 0; k < 4; k++) {
            edge = edges[k];
            clippedPoints = [];

            for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
                a = points[i];
                b = points[j];

                // if a is inside the clip window
                if (!(a._code & edge)) {
                    // if b is outside the clip window (a->b goes out of screen)
                    if (b._code & edge) {
                        p = lu._getEdgeIntersection(b, a, edge, bounds);
                        p._code = lu._getBitCode(p, bounds);
                        clippedPoints.push(p);
                    }
                    clippedPoints.push(a);

                    // else if b is inside the clip window (a->b enters the screen)
                } else if (!(b._code & edge)) {
                    p = lu._getEdgeIntersection(b, a, edge, bounds);
                    p._code = lu._getBitCode(p, bounds);
                    clippedPoints.push(p);
                }
            }
            points = clippedPoints;
        }

        return points;
    };


    /*
     * L.Polygon is used to display polygons on a map.
     */

    L.Polygon = L.Polyline.extend({
        options: {
            fill: true
        },
        initialize: function (latlngs, options) {
            L.Polyline.prototype.initialize.call(this, latlngs, options);
            this._initWithHoles(latlngs);
        },
        _initWithHoles: function (latlngs) {
            var i, len, hole;
            if (latlngs && L.Util.isArray(latlngs[0]) && (typeof latlngs[0][0] !== 'number')) {
                this._latlngs = this._convertLatLngs(latlngs[0]);
                this._holes = latlngs.slice(1);

                for (i = 0, len = this._holes.length; i < len; i++) {
                    hole = this._holes[i] = this._convertLatLngs(this._holes[i]);
                    if (hole[0].equals(hole[hole.length - 1])) {
                        hole.pop();
                    }
                }
            }

            // filter out last point if its equal to the first one
            latlngs = this._latlngs;

            if (latlngs.length >= 2 && latlngs[0].equals(latlngs[latlngs.length - 1])) {
                latlngs.pop();
            }
        },
        projectLatlngs: function () {
            L.Polyline.prototype.projectLatlngs.call(this);

            // project polygon holes points
            // TODO move this logic to Polyline to get rid of duplication
            this._holePoints = [];

            if (!this._holes) {
                return;
            }

            var i, j, len, len2;

            for (i = 0, len = this._holes.length; i < len; i++) {
                this._holePoints[i] = [];

                for (j = 0, len2 = this._holes[i].length; j < len2; j++) {
                    this._holePoints[i][j] = this._map.latLngToLayerPoint(this._holes[i][j]);
                }
            }
        },
        setLatLngs: function (latlngs) {
            if (latlngs && L.Util.isArray(latlngs[0]) && (typeof latlngs[0][0] !== 'number')) {
                this._initWithHoles(latlngs);
                return this.redraw();
            } else {
                return L.Polyline.prototype.setLatLngs.call(this, latlngs);
            }
        },
        _clipPoints: function () {
            var points = this._originalPoints,
                    newParts = [];

            this._parts = [points].concat(this._holePoints);

            if (this.options.noClip) {
                return;
            }

            for (var i = 0, len = this._parts.length; i < len; i++) {
                var clipped = L.PolyUtil.clipPolygon(this._parts[i], this._map._pathViewport);
                if (clipped.length) {
                    newParts.push(clipped);
                }
            }

            this._parts = newParts;
        },
        _getPathPartStr: function (points) {
            var str = L.Polyline.prototype._getPathPartStr.call(this, points);
            return str + (L.Browser.svg ? 'z' : 'x');
        }
    });

    L.polygon = function (latlngs, options) {
        return new L.Polygon(latlngs, options);
    };


    /*
     * Contains L.MultiPolyline and L.MultiPolygon layers.
     */

    (function () {
        function createMulti(Klass) {

            return L.FeatureGroup.extend({
                initialize: function (latlngs, options) {
                    this._layers = {};
                    this._options = options;
                    this.setLatLngs(latlngs);
                },
                setLatLngs: function (latlngs) {
                    var i = 0,
                            len = latlngs.length;

                    this.eachLayer(function (layer) {
                        if (i < len) {
                            layer.setLatLngs(latlngs[i++]);
                        } else {
                            this.removeLayer(layer);
                        }
                    }, this);

                    while (i < len) {
                        this.addLayer(new Klass(latlngs[i++], this._options));
                    }

                    return this;
                },
                getLatLngs: function () {
                    var latlngs = [];

                    this.eachLayer(function (layer) {
                        latlngs.push(layer.getLatLngs());
                    });

                    return latlngs;
                }
            });
        }

        L.MultiPolyline = createMulti(L.Polyline);
        L.MultiPolygon = createMulti(L.Polygon);

        L.multiPolyline = function (latlngs, options) {
            return new L.MultiPolyline(latlngs, options);
        };

        L.multiPolygon = function (latlngs, options) {
            return new L.MultiPolygon(latlngs, options);
        };
    }());


    /*
     * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.
     */

    L.Rectangle = L.Polygon.extend({
        initialize: function (latLngBounds, options) {
            L.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
        },
        setBounds: function (latLngBounds) {
            this.setLatLngs(this._boundsToLatLngs(latLngBounds));
        },
        _boundsToLatLngs: function (latLngBounds) {
            latLngBounds = L.latLngBounds(latLngBounds);
            return [
                latLngBounds.getSouthWest(),
                latLngBounds.getNorthWest(),
                latLngBounds.getNorthEast(),
                latLngBounds.getSouthEast()
            ];
        }
    });

    L.rectangle = function (latLngBounds, options) {
        return new L.Rectangle(latLngBounds, options);
    };


    /*
     * L.Circle is a circle overlay (with a certain radius in meters).
     */

    L.Circle = L.Path.extend({
        initialize: function (latlng, radius, options) {
            L.Path.prototype.initialize.call(this, options);

            this._latlng = L.latLng(latlng);
            this._mRadius = radius;
        },
        options: {
            fill: true
        },
        setLatLng: function (latlng) {
            this._latlng = L.latLng(latlng);
            return this.redraw();
        },
        setRadius: function (radius) {
            this._mRadius = radius;
            return this.redraw();
        },
        projectLatlngs: function () {
            var lngRadius = this._getLngRadius(),
                    latlng = this._latlng,
                    pointLeft = this._map.latLngToLayerPoint([latlng.lat, latlng.lng - lngRadius]);

            this._point = this._map.latLngToLayerPoint(latlng);
            this._radius = Math.max(this._point.x - pointLeft.x, 1);
        },
        getBounds: function () {
            var lngRadius = this._getLngRadius(),
                    latRadius = (this._mRadius / 40075017) * 360,
                    latlng = this._latlng;

            return new L.LatLngBounds(
                    [latlng.lat - latRadius, latlng.lng - lngRadius],
                    [latlng.lat + latRadius, latlng.lng + lngRadius]);
        },
        getLatLng: function () {
            return this._latlng;
        },
        getPathString: function () {
            var p = this._point,
                    r = this._radius;

            if (this._checkIfEmpty()) {
                return '';
            }

            if (L.Browser.svg) {
                return 'M' + p.x + ',' + (p.y - r) +
                        'A' + r + ',' + r + ',0,1,1,' +
                        (p.x - 0.1) + ',' + (p.y - r) + ' z';
            } else {
                p._round();
                r = Math.round(r);
                return 'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r + ' 0,' + (65535 * 360);
            }
        },
        getRadius: function () {
            return this._mRadius;
        },
        // TODO Earth hardcoded, move into projection code!

        _getLatRadius: function () {
            return (this._mRadius / 40075017) * 360;
        },
        _getLngRadius: function () {
            return this._getLatRadius() / Math.cos(L.LatLng.DEG_TO_RAD * this._latlng.lat);
        },
        _checkIfEmpty: function () {
            if (!this._map) {
                return false;
            }
            var vp = this._map._pathViewport,
                    r = this._radius,
                    p = this._point;

            return p.x - r > vp.max.x || p.y - r > vp.max.y ||
                    p.x + r < vp.min.x || p.y + r < vp.min.y;
        }
    });

    L.circle = function (latlng, radius, options) {
        return new L.Circle(latlng, radius, options);
    };


    /*
     * L.CircleMarker is a circle overlay with a permanent pixel radius.
     */

    L.CircleMarker = L.Circle.extend({
        options: {
            radius: 10,
            weight: 2
        },
        initialize: function (latlng, options) {
            L.Circle.prototype.initialize.call(this, latlng, null, options);
            this._radius = this.options.radius;
        },
        projectLatlngs: function () {
            this._point = this._map.latLngToLayerPoint(this._latlng);
        },
        _updateStyle: function () {
            L.Circle.prototype._updateStyle.call(this);
            this.setRadius(this.options.radius);
        },
        setLatLng: function (latlng) {
            L.Circle.prototype.setLatLng.call(this, latlng);
            if (this._popup && this._popup._isOpen) {
                this._popup.setLatLng(latlng);
            }
            return this;
        },
        setRadius: function (radius) {
            this.options.radius = this._radius = radius;
            return this.redraw();
        },
        getRadius: function () {
            return this._radius;
        }
    });

    L.circleMarker = function (latlng, options) {
        return new L.CircleMarker(latlng, options);
    };


    /*
     * Extends L.Polyline to be able to manually detect clicks on Canvas-rendered polylines.
     */

    L.Polyline.include(!L.Path.CANVAS ? {} : {
        _containsPoint: function (p, closed) {
            var i, j, k, len, len2, dist, part,
                    w = this.options.weight / 2;

            if (L.Browser.touch) {
                w += 10; // polyline click tolerance on touch devices
            }

            for (i = 0, len = this._parts.length; i < len; i++) {
                part = this._parts[i];
                for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
                    if (!closed && (j === 0)) {
                        continue;
                    }

                    dist = L.LineUtil.pointToSegmentDistance(p, part[k], part[j]);

                    if (dist <= w) {
                        return true;
                    }
                }
            }
            return false;
        }
    });


    /*
     * Extends L.Polygon to be able to manually detect clicks on Canvas-rendered polygons.
     */

    L.Polygon.include(!L.Path.CANVAS ? {} : {
        _containsPoint: function (p) {
            var inside = false,
                    part, p1, p2,
                    i, j, k,
                    len, len2;

            // TODO optimization: check if within bounds first

            if (L.Polyline.prototype._containsPoint.call(this, p, true)) {
                // click on polygon border
                return true;
            }

            // ray casting algorithm for detecting if point is in polygon

            for (i = 0, len = this._parts.length; i < len; i++) {
                part = this._parts[i];

                for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
                    p1 = part[j];
                    p2 = part[k];

                    if (((p1.y > p.y) !== (p2.y > p.y)) &&
                            (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
                        inside = !inside;
                    }
                }
            }

            return inside;
        }
    });


    /*
     * Extends L.Circle with Canvas-specific code.
     */

    L.Circle.include(!L.Path.CANVAS ? {} : {
        _drawPath: function () {
            var p = this._point;
            this._ctx.beginPath();
            this._ctx.arc(p.x, p.y, this._radius, 0, Math.PI * 2, false);
        },
        _containsPoint: function (p) {
            var center = this._point,
                    w2 = this.options.stroke ? this.options.weight / 2 : 0;

            return (p.distanceTo(center) <= this._radius + w2);
        }
    });


    /*
     * CircleMarker canvas specific drawing parts.
     */

    L.CircleMarker.include(!L.Path.CANVAS ? {} : {
        _updateStyle: function () {
            L.Path.prototype._updateStyle.call(this);
        }
    });


    /*
     * L.GeoJSON turns any GeoJSON data into a Leaflet layer.
     */

    L.GeoJSON = L.FeatureGroup.extend({
        initialize: function (geojson, options) {
            L.setOptions(this, options);

            this._layers = {};

            if (geojson) {
                this.addData(geojson);
            }
        },
        addData: function (geojson) {
            var features = L.Util.isArray(geojson) ? geojson : geojson.features,
                    i, len, feature;

            if (features) {
                for (i = 0, len = features.length; i < len; i++) {
                    // Only add this if geometry or geometries are set and not null
                    feature = features[i];
                    if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
                        this.addData(features[i]);
                    }
                }
                return this;
            }

            var options = this.options;

            if (options.filter && !options.filter(geojson)) {
                return;
            }

            var layer = L.GeoJSON.geometryToLayer(geojson, options.pointToLayer, options.coordsToLatLng, options);
            layer.feature = L.GeoJSON.asFeature(geojson);

            layer.defaultOptions = layer.options;
            this.resetStyle(layer);

            if (options.onEachFeature) {
                options.onEachFeature(geojson, layer);
            }

            return this.addLayer(layer);
        },
        resetStyle: function (layer) {
            var style = this.options.style;
            if (style) {
                // reset any custom styles
                L.Util.extend(layer.options, layer.defaultOptions);

                this._setLayerStyle(layer, style);
            }
        },
        setStyle: function (style) {
            this.eachLayer(function (layer) {
                this._setLayerStyle(layer, style);
            }, this);
        },
        _setLayerStyle: function (layer, style) {
            if (typeof style === 'function') {
                style = style(layer.feature);
            }
            if (layer.setStyle) {
                layer.setStyle(style);
            }
        }
    });

    L.extend(L.GeoJSON, {
        geometryToLayer: function (geojson, pointToLayer, coordsToLatLng, vectorOptions) {
            var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
                    coords = geometry.coordinates,
                    layers = [],
                    latlng, latlngs, i, len;

            coordsToLatLng = coordsToLatLng || this.coordsToLatLng;

            switch (geometry.type) {
                case 'Point':
                    latlng = coordsToLatLng(coords);
                    return pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng);

                case 'MultiPoint':
                    for (i = 0, len = coords.length; i < len; i++) {
                        latlng = coordsToLatLng(coords[i]);
                        layers.push(pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng));
                    }
                    return new L.FeatureGroup(layers);

                case 'LineString':
                    latlngs = this.coordsToLatLngs(coords, 0, coordsToLatLng);
                    return new L.Polyline(latlngs, vectorOptions);

                case 'Polygon':
                    if (coords.length === 2 && !coords[1].length) {
                        throw new Error('Invalid GeoJSON object.');
                    }
                    latlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);
                    return new L.Polygon(latlngs, vectorOptions);

                case 'MultiLineString':
                    latlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);
                    return new L.MultiPolyline(latlngs, vectorOptions);

                case 'MultiPolygon':
                    latlngs = this.coordsToLatLngs(coords, 2, coordsToLatLng);
                    return new L.MultiPolygon(latlngs, vectorOptions);

                case 'GeometryCollection':
                    for (i = 0, len = geometry.geometries.length; i < len; i++) {

                        layers.push(this.geometryToLayer({
                            geometry: geometry.geometries[i],
                            type: 'Feature',
                            properties: geojson.properties
                        }, pointToLayer, coordsToLatLng, vectorOptions));
                    }
                    return new L.FeatureGroup(layers);

                default:
                    throw new Error('Invalid GeoJSON object.');
            }
        },
        coordsToLatLng: function (coords) { // (Array[, Boolean]) -> LatLng
            return new L.LatLng(coords[1], coords[0], coords[2]);
        },
        coordsToLatLngs: function (coords, levelsDeep, coordsToLatLng) { // (Array[, Number, Function]) -> Array
            var latlng, i, len,
                    latlngs = [];

            for (i = 0, len = coords.length; i < len; i++) {
                latlng = levelsDeep ?
                        this.coordsToLatLngs(coords[i], levelsDeep - 1, coordsToLatLng) :
                        (coordsToLatLng || this.coordsToLatLng)(coords[i]);

                latlngs.push(latlng);
            }

            return latlngs;
        },
        latLngToCoords: function (latlng) {
            var coords = [latlng.lng, latlng.lat];

            if (latlng.alt !== undefined) {
                coords.push(latlng.alt);
            }
            return coords;
        },
        latLngsToCoords: function (latLngs) {
            var coords = [];

            for (var i = 0, len = latLngs.length; i < len; i++) {
                coords.push(L.GeoJSON.latLngToCoords(latLngs[i]));
            }

            return coords;
        },
        getFeature: function (layer, newGeometry) {
            return layer.feature ? L.extend({}, layer.feature, {geometry: newGeometry}) : L.GeoJSON.asFeature(newGeometry);
        },
        asFeature: function (geoJSON) {
            if (geoJSON.type === 'Feature') {
                return geoJSON;
            }

            return {
                type: 'Feature',
                properties: {},
                geometry: geoJSON
            };
        }
    });

    var PointToGeoJSON = {
        toGeoJSON: function () {
            return L.GeoJSON.getFeature(this, {
                type: 'Point',
                coordinates: L.GeoJSON.latLngToCoords(this.getLatLng())
            });
        }
    };

    L.Marker.include(PointToGeoJSON);
    L.Circle.include(PointToGeoJSON);
    L.CircleMarker.include(PointToGeoJSON);

    L.Polyline.include({
        toGeoJSON: function () {
            return L.GeoJSON.getFeature(this, {
                type: 'LineString',
                coordinates: L.GeoJSON.latLngsToCoords(this.getLatLngs())
            });
        }
    });

    L.Polygon.include({
        toGeoJSON: function () {
            var coords = [L.GeoJSON.latLngsToCoords(this.getLatLngs())],
                    i, len, hole;

            coords[0].push(coords[0][0]);

            if (this._holes) {
                for (i = 0, len = this._holes.length; i < len; i++) {
                    hole = L.GeoJSON.latLngsToCoords(this._holes[i]);
                    hole.push(hole[0]);
                    coords.push(hole);
                }
            }

            return L.GeoJSON.getFeature(this, {
                type: 'Polygon',
                coordinates: coords
            });
        }
    });

    (function () {
        function multiToGeoJSON(type) {
            return function () {
                var coords = [];

                this.eachLayer(function (layer) {
                    coords.push(layer.toGeoJSON().geometry.coordinates);
                });

                return L.GeoJSON.getFeature(this, {
                    type: type,
                    coordinates: coords
                });
            };
        }

        L.MultiPolyline.include({toGeoJSON: multiToGeoJSON('MultiLineString')});
        L.MultiPolygon.include({toGeoJSON: multiToGeoJSON('MultiPolygon')});

        L.LayerGroup.include({
            toGeoJSON: function () {

                var geometry = this.feature && this.feature.geometry,
                        jsons = [],
                        json;

                if (geometry && geometry.type === 'MultiPoint') {
                    return multiToGeoJSON('MultiPoint').call(this);
                }

                var isGeometryCollection = geometry && geometry.type === 'GeometryCollection';

                this.eachLayer(function (layer) {
                    if (layer.toGeoJSON) {
                        json = layer.toGeoJSON();
                        jsons.push(isGeometryCollection ? json.geometry : L.GeoJSON.asFeature(json));
                    }
                });

                if (isGeometryCollection) {
                    return L.GeoJSON.getFeature(this, {
                        geometries: jsons,
                        type: 'GeometryCollection'
                    });
                }

                return {
                    type: 'FeatureCollection',
                    features: jsons
                };
            }
        });
    }());

    L.geoJson = function (geojson, options) {
        return new L.GeoJSON(geojson, options);
    };


    /*
     * L.DomEvent contains functions for working with DOM events.
     */

    L.DomEvent = {
        /* inspired by John Resig, Dean Edwards and YUI addEvent implementations */
        addListener: function (obj, type, fn, context) { // (HTMLElement, String, Function[, Object])

            var id = L.stamp(fn),
                    key = '_leaflet_' + type + id,
                    handler, originalHandler, newType;

            if (obj[key]) {
                return this;
            }

            handler = function (e) {
                return fn.call(context || obj, e || L.DomEvent._getEvent());
            };

            if (L.Browser.pointer && type.indexOf('touch') === 0) {
                return this.addPointerListener(obj, type, handler, id);
            }
            if (L.Browser.touch && (type === 'dblclick') && this.addDoubleTapListener) {
                this.addDoubleTapListener(obj, handler, id);
            }

            if ('addEventListener' in obj) {

                if (type === 'mousewheel') {
                    obj.addEventListener('DOMMouseScroll', handler, false);
                    obj.addEventListener(type, handler, false);

                } else if ((type === 'mouseenter') || (type === 'mouseleave')) {

                    originalHandler = handler;
                    newType = (type === 'mouseenter' ? 'mouseover' : 'mouseout');

                    handler = function (e) {
                        if (!L.DomEvent._checkMouse(obj, e)) {
                            return;
                        }
                        return originalHandler(e);
                    };

                    obj.addEventListener(newType, handler, false);

                } else if (type === 'click' && L.Browser.android) {
                    originalHandler = handler;
                    handler = function (e) {
                        return L.DomEvent._filterClick(e, originalHandler);
                    };

                    obj.addEventListener(type, handler, false);
                } else {
                    obj.addEventListener(type, handler, false);
                }

            } else if ('attachEvent' in obj) {
                obj.attachEvent('on' + type, handler);
            }

            obj[key] = handler;

            return this;
        },
        removeListener: function (obj, type, fn) {  // (HTMLElement, String, Function)

            var id = L.stamp(fn),
                    key = '_leaflet_' + type + id,
                    handler = obj[key];

            if (!handler) {
                return this;
            }

            if (L.Browser.pointer && type.indexOf('touch') === 0) {
                this.removePointerListener(obj, type, id);
            } else if (L.Browser.touch && (type === 'dblclick') && this.removeDoubleTapListener) {
                this.removeDoubleTapListener(obj, id);

            } else if ('removeEventListener' in obj) {

                if (type === 'mousewheel') {
                    obj.removeEventListener('DOMMouseScroll', handler, false);
                    obj.removeEventListener(type, handler, false);

                } else if ((type === 'mouseenter') || (type === 'mouseleave')) {
                    obj.removeEventListener((type === 'mouseenter' ? 'mouseover' : 'mouseout'), handler, false);
                } else {
                    obj.removeEventListener(type, handler, false);
                }
            } else if ('detachEvent' in obj) {
                obj.detachEvent('on' + type, handler);
            }

            obj[key] = null;

            return this;
        },
        stopPropagation: function (e) {

            if (e.stopPropagation) {
                e.stopPropagation();
            } else {
                e.cancelBubble = true;
            }
            L.DomEvent._skipped(e);

            return this;
        },
        disableScrollPropagation: function (el) {
            var stop = L.DomEvent.stopPropagation;

            return L.DomEvent
                    .on(el, 'mousewheel', stop)
                    .on(el, 'MozMousePixelScroll', stop);
        },
        disableClickPropagation: function (el) {
            var stop = L.DomEvent.stopPropagation;

            for (var i = L.Draggable.START.length - 1; i >= 0; i--) {
                L.DomEvent.on(el, L.Draggable.START[i], stop);
            }

            return L.DomEvent
                    .on(el, 'click', L.DomEvent._fakeStop)
                    .on(el, 'dblclick', stop);
        },
        preventDefault: function (e) {

            if (e.preventDefault) {
                e.preventDefault();
            } else {
                e.returnValue = false;
            }
            return this;
        },
        stop: function (e) {
            return L.DomEvent
                    .preventDefault(e)
                    .stopPropagation(e);
        },
        getMousePosition: function (e, container) {
            if (!container) {
                return new L.Point(e.clientX, e.clientY);
            }

            var rect = container.getBoundingClientRect();

            return new L.Point(
                    e.clientX - rect.left - container.clientLeft,
                    e.clientY - rect.top - container.clientTop);
        },
        getWheelDelta: function (e) {

            var delta = 0;

            if (e.wheelDelta) {
                delta = e.wheelDelta / 120;
            }
            if (e.detail) {
                delta = -e.detail / 3;
            }
            return delta;
        },
        _skipEvents: {},
        _fakeStop: function (e) {
            // fakes stopPropagation by setting a special event flag, checked/reset with L.DomEvent._skipped(e)
            L.DomEvent._skipEvents[e.type] = true;
        },
        _skipped: function (e) {
            var skipped = this._skipEvents[e.type];
            // reset when checking, as it's only used in map container and propagates outside of the map
            this._skipEvents[e.type] = false;
            return skipped;
        },
        // check if element really left/entered the event target (for mouseenter/mouseleave)
        _checkMouse: function (el, e) {

            var related = e.relatedTarget;

            if (!related) {
                return true;
            }

            try {
                while (related && (related !== el)) {
                    related = related.parentNode;
                }
            } catch (err) {
                return false;
            }
            return (related !== el);
        },
        _getEvent: function () { // evil magic for IE
            /*jshint noarg:false */
            var e = window.event;
            if (!e) {
                var caller = arguments.callee.caller;
                while (caller) {
                    e = caller['arguments'][0];
                    if (e && window.Event === e.constructor) {
                        break;
                    }
                    caller = caller.caller;
                }
            }
            return e;
        },
        // this is a horrible workaround for a bug in Android where a single touch triggers two click events
        _filterClick: function (e, handler) {
            var timeStamp = (e.timeStamp || e.originalEvent.timeStamp),
                    elapsed = L.DomEvent._lastClick && (timeStamp - L.DomEvent._lastClick);

            // are they closer together than 500ms yet more than 100ms?
            // Android typically triggers them ~300ms apart while multiple listeners
            // on the same event should be triggered far faster;
            // or check if click is simulated on the element, and if it is, reject any non-simulated events

            if ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {
                L.DomEvent.stop(e);
                return;
            }
            L.DomEvent._lastClick = timeStamp;

            return handler(e);
        }
    };

    L.DomEvent.on = L.DomEvent.addListener;
    L.DomEvent.off = L.DomEvent.removeListener;


    /*
     * L.Draggable allows you to add dragging capabilities to any element. Supports mobile devices too.
     */

    L.Draggable = L.Class.extend({
        includes: L.Mixin.Events,
        statics: {
            START: L.Browser.touch ? ['touchstart', 'mousedown'] : ['mousedown'],
            END: {
                mousedown: 'mouseup',
                touchstart: 'touchend',
                pointerdown: 'touchend',
                MSPointerDown: 'touchend'
            },
            MOVE: {
                mousedown: 'mousemove',
                touchstart: 'touchmove',
                pointerdown: 'touchmove',
                MSPointerDown: 'touchmove'
            }
        },
        initialize: function (element, dragStartTarget) {
            this._element = element;
            this._dragStartTarget = dragStartTarget || element;
        },
        enable: function () {
            if (this._enabled) {
                return;
            }

            for (var i = L.Draggable.START.length - 1; i >= 0; i--) {
                L.DomEvent.on(this._dragStartTarget, L.Draggable.START[i], this._onDown, this);
            }

            this._enabled = true;
        },
        disable: function () {
            if (!this._enabled) {
                return;
            }

            for (var i = L.Draggable.START.length - 1; i >= 0; i--) {
                L.DomEvent.off(this._dragStartTarget, L.Draggable.START[i], this._onDown, this);
            }

            this._enabled = false;
            this._moved = false;
        },
        _onDown: function (e) {
            this._moved = false;

            if (e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches)) {
                return;
            }

            L.DomEvent.stopPropagation(e);

            if (L.Draggable._disabled) {
                return;
            }

            L.DomUtil.disableImageDrag();
            L.DomUtil.disableTextSelection();

            if (this._moving) {
                return;
            }

            var first = e.touches ? e.touches[0] : e;

            this._startPoint = new L.Point(first.clientX, first.clientY);
            this._startPos = this._newPos = L.DomUtil.getPosition(this._element);

            L.DomEvent
                    .on(document, L.Draggable.MOVE[e.type], this._onMove, this)
                    .on(document, L.Draggable.END[e.type], this._onUp, this);
        },
        _onMove: function (e) {
            if (e.touches && e.touches.length > 1) {
                this._moved = true;
                return;
            }

            var first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),
                    newPoint = new L.Point(first.clientX, first.clientY),
                    offset = newPoint.subtract(this._startPoint);

            if (!offset.x && !offset.y) {
                return;
            }
            if (L.Browser.touch && Math.abs(offset.x) + Math.abs(offset.y) < 3) {
                return;
            }

            L.DomEvent.preventDefault(e);

            if (!this._moved) {
                this.fire('dragstart');

                this._moved = true;
                this._startPos = L.DomUtil.getPosition(this._element).subtract(offset);

                L.DomUtil.addClass(document.body, 'leaflet-dragging');
                this._lastTarget = e.target || e.srcElement;
                L.DomUtil.addClass(this._lastTarget, 'leaflet-drag-target');
            }

            this._newPos = this._startPos.add(offset);
            this._moving = true;

            L.Util.cancelAnimFrame(this._animRequest);
            this._animRequest = L.Util.requestAnimFrame(this._updatePosition, this, true, this._dragStartTarget);
        },
        _updatePosition: function () {
            this.fire('predrag');
            L.DomUtil.setPosition(this._element, this._newPos);
            this.fire('drag');
        },
        _onUp: function () {
            L.DomUtil.removeClass(document.body, 'leaflet-dragging');

            if (this._lastTarget) {
                L.DomUtil.removeClass(this._lastTarget, 'leaflet-drag-target');
                this._lastTarget = null;
            }

            for (var i in L.Draggable.MOVE) {
                L.DomEvent
                        .off(document, L.Draggable.MOVE[i], this._onMove)
                        .off(document, L.Draggable.END[i], this._onUp);
            }

            L.DomUtil.enableImageDrag();
            L.DomUtil.enableTextSelection();

            if (this._moved && this._moving) {
                // ensure drag is not fired after dragend
                L.Util.cancelAnimFrame(this._animRequest);

                this.fire('dragend', {
                    distance: this._newPos.distanceTo(this._startPos)
                });
            }

            this._moving = false;
        }
    });


    /*
     L.Handler is a base class for handler classes that are used internally to inject
     interaction features like dragging to classes like Map and Marker.
     */

    L.Handler = L.Class.extend({
        initialize: function (map) {
            this._map = map;
        },
        enable: function () {
            if (this._enabled) {
                return;
            }

            this._enabled = true;
            this.addHooks();
        },
        disable: function () {
            if (!this._enabled) {
                return;
            }

            this._enabled = false;
            this.removeHooks();
        },
        enabled: function () {
            return !!this._enabled;
        }
    });


    /*
     * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.
     */

    L.Map.mergeOptions({
        dragging: true,
        inertia: !L.Browser.android23,
        inertiaDeceleration: 3400, // px/s^2
        inertiaMaxSpeed: Infinity, // px/s
        inertiaThreshold: L.Browser.touch ? 32 : 18, // ms
        easeLinearity: 0.25,
        // TODO refactor, move to CRS
        worldCopyJump: false
    });

    L.Map.Drag = L.Handler.extend({
        addHooks: function () {
            if (!this._draggable) {
                var map = this._map;

                this._draggable = new L.Draggable(map._mapPane, map._container);

                this._draggable.on({
                    'dragstart': this._onDragStart,
                    'drag': this._onDrag,
                    'dragend': this._onDragEnd
                }, this);

                if (map.options.worldCopyJump) {
                    this._draggable.on('predrag', this._onPreDrag, this);
                    map.on('viewreset', this._onViewReset, this);

                    map.whenReady(this._onViewReset, this);
                }
            }
            this._draggable.enable();
        },
        removeHooks: function () {
            this._draggable.disable();
        },
        moved: function () {
            return this._draggable && this._draggable._moved;
        },
        _onDragStart: function () {
            var map = this._map;

            if (map._panAnim) {
                map._panAnim.stop();
            }

            map
                    .fire('movestart')
                    .fire('dragstart');

            if (map.options.inertia) {
                this._positions = [];
                this._times = [];
            }
        },
        _onDrag: function () {
            if (this._map.options.inertia) {
                var time = this._lastTime = +new Date(),
                        pos = this._lastPos = this._draggable._newPos;

                this._positions.push(pos);
                this._times.push(time);

                if (time - this._times[0] > 200) {
                    this._positions.shift();
                    this._times.shift();
                }
            }

            this._map
                    .fire('move')
                    .fire('drag');
        },
        _onViewReset: function () {
            // TODO fix hardcoded Earth values
            var pxCenter = this._map.getSize()._divideBy(2),
                    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);

            this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
            this._worldWidth = this._map.project([0, 180]).x;
        },
        _onPreDrag: function () {
            // TODO refactor to be able to adjust map pane position after zoom
            var worldWidth = this._worldWidth,
                    halfWidth = Math.round(worldWidth / 2),
                    dx = this._initialWorldOffset,
                    x = this._draggable._newPos.x,
                    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,
                    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,
                    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;

            this._draggable._newPos.x = newX;
        },
        _onDragEnd: function (e) {
            var map = this._map,
                    options = map.options,
                    delay = +new Date() - this._lastTime,
                    noInertia = !options.inertia || delay > options.inertiaThreshold || !this._positions[0];

            map.fire('dragend', e);

            if (noInertia) {
                map.fire('moveend');

            } else {

                var direction = this._lastPos.subtract(this._positions[0]),
                        duration = (this._lastTime + delay - this._times[0]) / 1000,
                        ease = options.easeLinearity,
                        speedVector = direction.multiplyBy(ease / duration),
                        speed = speedVector.distanceTo([0, 0]),
                        limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),
                        limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),
                        decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),
                        offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();

                if (!offset.x || !offset.y) {
                    map.fire('moveend');

                } else {
                    offset = map._limitOffset(offset, map.options.maxBounds);

                    L.Util.requestAnimFrame(function () {
                        map.panBy(offset, {
                            duration: decelerationDuration,
                            easeLinearity: ease,
                            noMoveStart: true
                        });
                    });
                }
            }
        }
    });

    L.Map.addInitHook('addHandler', 'dragging', L.Map.Drag);


    /*
     * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.
     */

    L.Map.mergeOptions({
        doubleClickZoom: true
    });

    L.Map.DoubleClickZoom = L.Handler.extend({
        addHooks: function () {
            this._map.on('dblclick', this._onDoubleClick, this);
        },
        removeHooks: function () {
            this._map.off('dblclick', this._onDoubleClick, this);
        },
        _onDoubleClick: function (e) {
            var map = this._map,
                    zoom = map.getZoom() + (e.originalEvent.shiftKey ? -1 : 1);

            if (map.options.doubleClickZoom === 'center') {
                map.setZoom(zoom);
            } else {
                map.setZoomAround(e.containerPoint, zoom);
            }
        }
    });

    L.Map.addInitHook('addHandler', 'doubleClickZoom', L.Map.DoubleClickZoom);


    /*
     * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.
     */

    L.Map.mergeOptions({
        scrollWheelZoom: true
    });

    L.Map.ScrollWheelZoom = L.Handler.extend({
        addHooks: function () {
            L.DomEvent.on(this._map._container, 'mousewheel', this._onWheelScroll, this);
            L.DomEvent.on(this._map._container, 'MozMousePixelScroll', L.DomEvent.preventDefault);
            this._delta = 0;
        },
        removeHooks: function () {
            L.DomEvent.off(this._map._container, 'mousewheel', this._onWheelScroll);
            L.DomEvent.off(this._map._container, 'MozMousePixelScroll', L.DomEvent.preventDefault);
        },
        _onWheelScroll: function (e) {
            var delta = L.DomEvent.getWheelDelta(e);

            this._delta += delta;
            this._lastMousePos = this._map.mouseEventToContainerPoint(e);

            if (!this._startTime) {
                this._startTime = +new Date();
            }

            var left = Math.max(40 - (+new Date() - this._startTime), 0);

            clearTimeout(this._timer);
            this._timer = setTimeout(L.bind(this._performZoom, this), left);

            L.DomEvent.preventDefault(e);
            L.DomEvent.stopPropagation(e);
        },
        _performZoom: function () {
            var map = this._map,
                    delta = this._delta,
                    zoom = map.getZoom();

            delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);
            delta = Math.max(Math.min(delta, 4), -4);
            delta = map._limitZoom(zoom + delta) - zoom;

            this._delta = 0;
            this._startTime = null;

            if (!delta) {
                return;
            }

            if (map.options.scrollWheelZoom === 'center') {
                map.setZoom(zoom + delta);
            } else {
                map.setZoomAround(this._lastMousePos, zoom + delta);
            }
        }
    });

    L.Map.addInitHook('addHandler', 'scrollWheelZoom', L.Map.ScrollWheelZoom);


    /*
     * Extends the event handling code with double tap support for mobile browsers.
     */

    L.extend(L.DomEvent, {
        _touchstart: L.Browser.msPointer ? 'MSPointerDown' : L.Browser.pointer ? 'pointerdown' : 'touchstart',
        _touchend: L.Browser.msPointer ? 'MSPointerUp' : L.Browser.pointer ? 'pointerup' : 'touchend',
        // inspired by Zepto touch code by Thomas Fuchs
        addDoubleTapListener: function (obj, handler, id) {
            var last,
                    doubleTap = false,
                    delay = 250,
                    touch,
                    pre = '_leaflet_',
                    touchstart = this._touchstart,
                    touchend = this._touchend,
                    trackedTouches = [];

            function onTouchStart(e) {
                var count;

                if (L.Browser.pointer) {
                    trackedTouches.push(e.pointerId);
                    count = trackedTouches.length;
                } else {
                    count = e.touches.length;
                }
                if (count > 1) {
                    return;
                }

                var now = Date.now(),
                        delta = now - (last || now);

                touch = e.touches ? e.touches[0] : e;
                doubleTap = (delta > 0 && delta <= delay);
                last = now;
            }

            function onTouchEnd(e) {
                if (L.Browser.pointer) {
                    var idx = trackedTouches.indexOf(e.pointerId);
                    if (idx === -1) {
                        return;
                    }
                    trackedTouches.splice(idx, 1);
                }

                if (doubleTap) {
                    if (L.Browser.pointer) {
                        // work around .type being readonly with MSPointer* events
                        var newTouch = {},
                                prop;

                        // jshint forin:false
                        for (var i in touch) {
                            prop = touch[i];
                            if (typeof prop === 'function') {
                                newTouch[i] = prop.bind(touch);
                            } else {
                                newTouch[i] = prop;
                            }
                        }
                        touch = newTouch;
                    }
                    touch.type = 'dblclick';
                    handler(touch);
                    last = null;
                }
            }
            obj[pre + touchstart + id] = onTouchStart;
            obj[pre + touchend + id] = onTouchEnd;

            // on pointer we need to listen on the document, otherwise a drag starting on the map and moving off screen
            // will not come through to us, so we will lose track of how many touches are ongoing
            var endElement = L.Browser.pointer ? document.documentElement : obj;

            obj.addEventListener(touchstart, onTouchStart, false);
            endElement.addEventListener(touchend, onTouchEnd, false);

            if (L.Browser.pointer) {
                endElement.addEventListener(L.DomEvent.POINTER_CANCEL, onTouchEnd, false);
            }

            return this;
        },
        removeDoubleTapListener: function (obj, id) {
            var pre = '_leaflet_';

            obj.removeEventListener(this._touchstart, obj[pre + this._touchstart + id], false);
            (L.Browser.pointer ? document.documentElement : obj).removeEventListener(
                    this._touchend, obj[pre + this._touchend + id], false);

            if (L.Browser.pointer) {
                document.documentElement.removeEventListener(L.DomEvent.POINTER_CANCEL, obj[pre + this._touchend + id],
                        false);
            }

            return this;
        }
    });


    /*
     * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.
     */

    L.extend(L.DomEvent, {
        //static
        POINTER_DOWN: L.Browser.msPointer ? 'MSPointerDown' : 'pointerdown',
        POINTER_MOVE: L.Browser.msPointer ? 'MSPointerMove' : 'pointermove',
        POINTER_UP: L.Browser.msPointer ? 'MSPointerUp' : 'pointerup',
        POINTER_CANCEL: L.Browser.msPointer ? 'MSPointerCancel' : 'pointercancel',
        _pointers: [],
        _pointerDocumentListener: false,
        // Provides a touch events wrapper for (ms)pointer events.
        // Based on changes by veproza https://github.com/CloudMade/Leaflet/pull/1019
        //ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890

        addPointerListener: function (obj, type, handler, id) {

            switch (type) {
                case 'touchstart':
                    return this.addPointerListenerStart(obj, type, handler, id);
                case 'touchend':
                    return this.addPointerListenerEnd(obj, type, handler, id);
                case 'touchmove':
                    return this.addPointerListenerMove(obj, type, handler, id);
                default:
                    throw 'Unknown touch event type';
            }
        },
        addPointerListenerStart: function (obj, type, handler, id) {
            var pre = '_leaflet_',
                    pointers = this._pointers;

            var cb = function (e) {

                L.DomEvent.preventDefault(e);

                var alreadyInArray = false;
                for (var i = 0; i < pointers.length; i++) {
                    if (pointers[i].pointerId === e.pointerId) {
                        alreadyInArray = true;
                        break;
                    }
                }
                if (!alreadyInArray) {
                    pointers.push(e);
                }

                e.touches = pointers.slice();
                e.changedTouches = [e];

                handler(e);
            };

            obj[pre + 'touchstart' + id] = cb;
            obj.addEventListener(this.POINTER_DOWN, cb, false);

            // need to also listen for end events to keep the _pointers list accurate
            // this needs to be on the body and never go away
            if (!this._pointerDocumentListener) {
                var internalCb = function (e) {
                    for (var i = 0; i < pointers.length; i++) {
                        if (pointers[i].pointerId === e.pointerId) {
                            pointers.splice(i, 1);
                            break;
                        }
                    }
                };
                //We listen on the documentElement as any drags that end by moving the touch off the screen get fired there
                document.documentElement.addEventListener(this.POINTER_UP, internalCb, false);
                document.documentElement.addEventListener(this.POINTER_CANCEL, internalCb, false);

                this._pointerDocumentListener = true;
            }

            return this;
        },
        addPointerListenerMove: function (obj, type, handler, id) {
            var pre = '_leaflet_',
                    touches = this._pointers;

            function cb(e) {

                // don't fire touch moves when mouse isn't down
                if ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) {
                    return;
                }

                for (var i = 0; i < touches.length; i++) {
                    if (touches[i].pointerId === e.pointerId) {
                        touches[i] = e;
                        break;
                    }
                }

                e.touches = touches.slice();
                e.changedTouches = [e];

                handler(e);
            }

            obj[pre + 'touchmove' + id] = cb;
            obj.addEventListener(this.POINTER_MOVE, cb, false);

            return this;
        },
        addPointerListenerEnd: function (obj, type, handler, id) {
            var pre = '_leaflet_',
                    touches = this._pointers;

            var cb = function (e) {
                for (var i = 0; i < touches.length; i++) {
                    if (touches[i].pointerId === e.pointerId) {
                        touches.splice(i, 1);
                        break;
                    }
                }

                e.touches = touches.slice();
                e.changedTouches = [e];

                handler(e);
            };

            obj[pre + 'touchend' + id] = cb;
            obj.addEventListener(this.POINTER_UP, cb, false);
            obj.addEventListener(this.POINTER_CANCEL, cb, false);

            return this;
        },
        removePointerListener: function (obj, type, id) {
            var pre = '_leaflet_',
                    cb = obj[pre + type + id];

            switch (type) {
                case 'touchstart':
                    obj.removeEventListener(this.POINTER_DOWN, cb, false);
                    break;
                case 'touchmove':
                    obj.removeEventListener(this.POINTER_MOVE, cb, false);
                    break;
                case 'touchend':
                    obj.removeEventListener(this.POINTER_UP, cb, false);
                    obj.removeEventListener(this.POINTER_CANCEL, cb, false);
                    break;
            }

            return this;
        }
    });


    /*
     * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.
     */

    L.Map.mergeOptions({
        touchZoom: L.Browser.touch && !L.Browser.android23,
        bounceAtZoomLimits: true
    });

    L.Map.TouchZoom = L.Handler.extend({
        addHooks: function () {
            L.DomEvent.on(this._map._container, 'touchstart', this._onTouchStart, this);
        },
        removeHooks: function () {
            L.DomEvent.off(this._map._container, 'touchstart', this._onTouchStart, this);
        },
        _onTouchStart: function (e) {
            var map = this._map;

            if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) {
                return;
            }

            var p1 = map.mouseEventToLayerPoint(e.touches[0]),
                    p2 = map.mouseEventToLayerPoint(e.touches[1]),
                    viewCenter = map._getCenterLayerPoint();

            this._startCenter = p1.add(p2)._divideBy(2);
            this._startDist = p1.distanceTo(p2);

            this._moved = false;
            this._zooming = true;

            this._centerOffset = viewCenter.subtract(this._startCenter);

            if (map._panAnim) {
                map._panAnim.stop();
            }

            L.DomEvent
                    .on(document, 'touchmove', this._onTouchMove, this)
                    .on(document, 'touchend', this._onTouchEnd, this);

            L.DomEvent.preventDefault(e);
        },
        _onTouchMove: function (e) {
            var map = this._map;

            if (!e.touches || e.touches.length !== 2 || !this._zooming) {
                return;
            }

            var p1 = map.mouseEventToLayerPoint(e.touches[0]),
                    p2 = map.mouseEventToLayerPoint(e.touches[1]);

            this._scale = p1.distanceTo(p2) / this._startDist;
            this._delta = p1._add(p2)._divideBy(2)._subtract(this._startCenter);

            if (this._scale === 1) {
                return;
            }

            if (!map.options.bounceAtZoomLimits) {
                if ((map.getZoom() === map.getMinZoom() && this._scale < 1) ||
                        (map.getZoom() === map.getMaxZoom() && this._scale > 1)) {
                    return;
                }
            }

            if (!this._moved) {
                L.DomUtil.addClass(map._mapPane, 'leaflet-touching');

                map
                        .fire('movestart')
                        .fire('zoomstart');

                this._moved = true;
            }

            L.Util.cancelAnimFrame(this._animRequest);
            this._animRequest = L.Util.requestAnimFrame(
                    this._updateOnMove, this, true, this._map._container);

            L.DomEvent.preventDefault(e);
        },
        _updateOnMove: function () {
            var map = this._map,
                    origin = this._getScaleOrigin(),
                    center = map.layerPointToLatLng(origin),
                    zoom = map.getScaleZoom(this._scale);

            map._animateZoom(center, zoom, this._startCenter, this._scale, this._delta, false, true);
        },
        _onTouchEnd: function () {
            if (!this._moved || !this._zooming) {
                this._zooming = false;
                return;
            }

            var map = this._map;

            this._zooming = false;
            L.DomUtil.removeClass(map._mapPane, 'leaflet-touching');
            L.Util.cancelAnimFrame(this._animRequest);

            L.DomEvent
                    .off(document, 'touchmove', this._onTouchMove)
                    .off(document, 'touchend', this._onTouchEnd);

            var origin = this._getScaleOrigin(),
                    center = map.layerPointToLatLng(origin),
                    oldZoom = map.getZoom(),
                    floatZoomDelta = map.getScaleZoom(this._scale) - oldZoom,
                    roundZoomDelta = (floatZoomDelta > 0 ?
                            Math.ceil(floatZoomDelta) : Math.floor(floatZoomDelta)),
                    zoom = map._limitZoom(oldZoom + roundZoomDelta),
                    scale = map.getZoomScale(zoom) / this._scale;

            map._animateZoom(center, zoom, origin, scale);
        },
        _getScaleOrigin: function () {
            var centerOffset = this._centerOffset.subtract(this._delta).divideBy(this._scale);
            return this._startCenter.add(centerOffset);
        }
    });

    L.Map.addInitHook('addHandler', 'touchZoom', L.Map.TouchZoom);


    /*
     * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.
     */

    L.Map.mergeOptions({
        tap: true,
        tapTolerance: 15
    });

    L.Map.Tap = L.Handler.extend({
        addHooks: function () {
            L.DomEvent.on(this._map._container, 'touchstart', this._onDown, this);
        },
        removeHooks: function () {
            L.DomEvent.off(this._map._container, 'touchstart', this._onDown, this);
        },
        _onDown: function (e) {
            if (!e.touches) {
                return;
            }

            L.DomEvent.preventDefault(e);

            this._fireClick = true;

            // don't simulate click or track longpress if more than 1 touch
            if (e.touches.length > 1) {
                this._fireClick = false;
                clearTimeout(this._holdTimeout);
                return;
            }

            var first = e.touches[0],
                    el = first.target;

            this._startPos = this._newPos = new L.Point(first.clientX, first.clientY);

            // if touching a link, highlight it
            if (el.tagName && el.tagName.toLowerCase() === 'a') {
                L.DomUtil.addClass(el, 'leaflet-active');
            }

            // simulate long hold but setting a timeout
            this._holdTimeout = setTimeout(L.bind(function () {
                if (this._isTapValid()) {
                    this._fireClick = false;
                    this._onUp();
                    this._simulateEvent('contextmenu', first);
                }
            }, this), 1000);

            L.DomEvent
                    .on(document, 'touchmove', this._onMove, this)
                    .on(document, 'touchend', this._onUp, this);
        },
        _onUp: function (e) {
            clearTimeout(this._holdTimeout);

            L.DomEvent
                    .off(document, 'touchmove', this._onMove, this)
                    .off(document, 'touchend', this._onUp, this);

            if (this._fireClick && e && e.changedTouches) {

                var first = e.changedTouches[0],
                        el = first.target;

                if (el && el.tagName && el.tagName.toLowerCase() === 'a') {
                    L.DomUtil.removeClass(el, 'leaflet-active');
                }

                // simulate click if the touch didn't move too much
                if (this._isTapValid()) {
                    this._simulateEvent('click', first);
                }
            }
        },
        _isTapValid: function () {
            return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
        },
        _onMove: function (e) {
            var first = e.touches[0];
            this._newPos = new L.Point(first.clientX, first.clientY);
        },
        _simulateEvent: function (type, e) {
            var simulatedEvent = document.createEvent('MouseEvents');

            simulatedEvent._simulated = true;
            e.target._simulatedClick = true;

            simulatedEvent.initMouseEvent(
                    type, true, true, window, 1,
                    e.screenX, e.screenY,
                    e.clientX, e.clientY,
                    false, false, false, false, 0, null);

            e.target.dispatchEvent(simulatedEvent);
        }
    });

    if (L.Browser.touch && !L.Browser.pointer) {
        L.Map.addInitHook('addHandler', 'tap', L.Map.Tap);
    }


    /*
     * L.Handler.ShiftDragZoom is used to add shift-drag zoom interaction to the map
     * (zoom to a selected bounding box), enabled by default.
     */

    L.Map.mergeOptions({
        boxZoom: true
    });

    L.Map.BoxZoom = L.Handler.extend({
        initialize: function (map) {
            this._map = map;
            this._container = map._container;
            this._pane = map._panes.overlayPane;
            this._moved = false;
        },
        addHooks: function () {
            L.DomEvent.on(this._container, 'mousedown', this._onMouseDown, this);
        },
        removeHooks: function () {
            L.DomEvent.off(this._container, 'mousedown', this._onMouseDown);
            this._moved = false;
        },
        moved: function () {
            return this._moved;
        },
        _onMouseDown: function (e) {
            this._moved = false;

            if (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) {
                return false;
            }

            L.DomUtil.disableTextSelection();
            L.DomUtil.disableImageDrag();

            this._startLayerPoint = this._map.mouseEventToLayerPoint(e);

            L.DomEvent
                    .on(document, 'mousemove', this._onMouseMove, this)
                    .on(document, 'mouseup', this._onMouseUp, this)
                    .on(document, 'keydown', this._onKeyDown, this);
        },
        _onMouseMove: function (e) {
            if (!this._moved) {
                this._box = L.DomUtil.create('div', 'leaflet-zoom-box', this._pane);
                L.DomUtil.setPosition(this._box, this._startLayerPoint);

                //TODO refactor: move cursor to styles
                this._container.style.cursor = 'crosshair';
                this._map.fire('boxzoomstart');
            }

            var startPoint = this._startLayerPoint,
                    box = this._box,
                    layerPoint = this._map.mouseEventToLayerPoint(e),
                    offset = layerPoint.subtract(startPoint),
                    newPos = new L.Point(
                            Math.min(layerPoint.x, startPoint.x),
                            Math.min(layerPoint.y, startPoint.y));

            L.DomUtil.setPosition(box, newPos);

            this._moved = true;

            // TODO refactor: remove hardcoded 4 pixels
            box.style.width = (Math.max(0, Math.abs(offset.x) - 4)) + 'px';
            box.style.height = (Math.max(0, Math.abs(offset.y) - 4)) + 'px';
        },
        _finish: function () {
            if (this._moved) {
                this._pane.removeChild(this._box);
                this._container.style.cursor = '';
            }

            L.DomUtil.enableTextSelection();
            L.DomUtil.enableImageDrag();

            L.DomEvent
                    .off(document, 'mousemove', this._onMouseMove)
                    .off(document, 'mouseup', this._onMouseUp)
                    .off(document, 'keydown', this._onKeyDown);
        },
        _onMouseUp: function (e) {

            this._finish();

            var map = this._map,
                    layerPoint = map.mouseEventToLayerPoint(e);

            if (this._startLayerPoint.equals(layerPoint)) {
                return;
            }

            var bounds = new L.LatLngBounds(
                    map.layerPointToLatLng(this._startLayerPoint),
                    map.layerPointToLatLng(layerPoint));

            map.fitBounds(bounds);

            map.fire('boxzoomend', {
                boxZoomBounds: bounds
            });
        },
        _onKeyDown: function (e) {
            if (e.keyCode === 27) {
                this._finish();
            }
        }
    });

    L.Map.addInitHook('addHandler', 'boxZoom', L.Map.BoxZoom);


    /*
     * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.
     */

    L.Map.mergeOptions({
        keyboard: true,
        keyboardPanOffset: 80,
        keyboardZoomOffset: 1
    });

    L.Map.Keyboard = L.Handler.extend({
        keyCodes: {
            left: [37],
            right: [39],
            down: [40],
            up: [38],
            zoomIn: [187, 107, 61, 171],
            zoomOut: [189, 109, 173]
        },
        initialize: function (map) {
            this._map = map;

            this._setPanOffset(map.options.keyboardPanOffset);
            this._setZoomOffset(map.options.keyboardZoomOffset);
        },
        addHooks: function () {
            var container = this._map._container;

            // make the container focusable by tabbing
            if (container.tabIndex === -1) {
                container.tabIndex = '0';
            }

            L.DomEvent
                    .on(container, 'focus', this._onFocus, this)
                    .on(container, 'blur', this._onBlur, this)
                    .on(container, 'mousedown', this._onMouseDown, this);

            this._map
                    .on('focus', this._addHooks, this)
                    .on('blur', this._removeHooks, this);
        },
        removeHooks: function () {
            this._removeHooks();

            var container = this._map._container;

            L.DomEvent
                    .off(container, 'focus', this._onFocus, this)
                    .off(container, 'blur', this._onBlur, this)
                    .off(container, 'mousedown', this._onMouseDown, this);

            this._map
                    .off('focus', this._addHooks, this)
                    .off('blur', this._removeHooks, this);
        },
        _onMouseDown: function () {
            if (this._focused) {
                return;
            }

            var body = document.body,
                    docEl = document.documentElement,
                    top = body.scrollTop || docEl.scrollTop,
                    left = body.scrollLeft || docEl.scrollLeft;

            this._map._container.focus();

            window.scrollTo(left, top);
        },
        _onFocus: function () {
            this._focused = true;
            this._map.fire('focus');
        },
        _onBlur: function () {
            this._focused = false;
            this._map.fire('blur');
        },
        _setPanOffset: function (pan) {
            var keys = this._panKeys = {},
                    codes = this.keyCodes,
                    i, len;

            for (i = 0, len = codes.left.length; i < len; i++) {
                keys[codes.left[i]] = [-1 * pan, 0];
            }
            for (i = 0, len = codes.right.length; i < len; i++) {
                keys[codes.right[i]] = [pan, 0];
            }
            for (i = 0, len = codes.down.length; i < len; i++) {
                keys[codes.down[i]] = [0, pan];
            }
            for (i = 0, len = codes.up.length; i < len; i++) {
                keys[codes.up[i]] = [0, -1 * pan];
            }
        },
        _setZoomOffset: function (zoom) {
            var keys = this._zoomKeys = {},
                    codes = this.keyCodes,
                    i, len;

            for (i = 0, len = codes.zoomIn.length; i < len; i++) {
                keys[codes.zoomIn[i]] = zoom;
            }
            for (i = 0, len = codes.zoomOut.length; i < len; i++) {
                keys[codes.zoomOut[i]] = -zoom;
            }
        },
        _addHooks: function () {
            L.DomEvent.on(document, 'keydown', this._onKeyDown, this);
        },
        _removeHooks: function () {
            L.DomEvent.off(document, 'keydown', this._onKeyDown, this);
        },
        _onKeyDown: function (e) {
            var key = e.keyCode,
                    map = this._map;

            if (key in this._panKeys) {

                if (map._panAnim && map._panAnim._inProgress) {
                    return;
                }

                map.panBy(this._panKeys[key]);

                if (map.options.maxBounds) {
                    map.panInsideBounds(map.options.maxBounds);
                }

            } else if (key in this._zoomKeys) {
                map.setZoom(map.getZoom() + this._zoomKeys[key]);

            } else {
                return;
            }

            L.DomEvent.stop(e);
        }
    });

    L.Map.addInitHook('addHandler', 'keyboard', L.Map.Keyboard);


    /*
     * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.
     */

    L.Handler.MarkerDrag = L.Handler.extend({
        initialize: function (marker) {
            this._marker = marker;
        },
        addHooks: function () {
            var icon = this._marker._icon;
            if (!this._draggable) {
                this._draggable = new L.Draggable(icon, icon);
            }

            this._draggable
                    .on('dragstart', this._onDragStart, this)
                    .on('drag', this._onDrag, this)
                    .on('dragend', this._onDragEnd, this);
            this._draggable.enable();
            L.DomUtil.addClass(this._marker._icon, 'leaflet-marker-draggable');
        },
        removeHooks: function () {
            this._draggable
                    .off('dragstart', this._onDragStart, this)
                    .off('drag', this._onDrag, this)
                    .off('dragend', this._onDragEnd, this);

            this._draggable.disable();
            L.DomUtil.removeClass(this._marker._icon, 'leaflet-marker-draggable');
        },
        moved: function () {
            return this._draggable && this._draggable._moved;
        },
        _onDragStart: function () {
            this._marker
                    .closePopup()
                    .fire('movestart')
                    .fire('dragstart');
        },
        _onDrag: function () {
            var marker = this._marker,
                    shadow = marker._shadow,
                    iconPos = L.DomUtil.getPosition(marker._icon),
                    latlng = marker._map.layerPointToLatLng(iconPos);

            // update shadow position
            if (shadow) {
                L.DomUtil.setPosition(shadow, iconPos);
            }

            marker._latlng = latlng;

            marker
                    .fire('move', {latlng: latlng})
                    .fire('drag');
        },
        _onDragEnd: function (e) {
            this._marker
                    .fire('moveend')
                    .fire('dragend', e);
        }
    });


    /*
     * L.Control is a base class for implementing map controls. Handles positioning.
     * All other controls extend from this class.
     */

    L.Control = L.Class.extend({
        options: {
            position: 'topright'
        },
        initialize: function (options) {
            L.setOptions(this, options);
        },
        getPosition: function () {
            return this.options.position;
        },
        setPosition: function (position) {
            var map = this._map;

            if (map) {
                map.removeControl(this);
            }

            this.options.position = position;

            if (map) {
                map.addControl(this);
            }

            return this;
        },
        getContainer: function () {
            return this._container;
        },
        addTo: function (map) {
            this._map = map;

            var container = this._container = this.onAdd(map),
                    pos = this.getPosition(),
                    corner = map._controlCorners[pos];

            L.DomUtil.addClass(container, 'leaflet-control');

            if (pos.indexOf('bottom') !== -1) {
                corner.insertBefore(container, corner.firstChild);
            } else {
                corner.appendChild(container);
            }

            return this;
        },
        removeFrom: function (map) {
            var pos = this.getPosition(),
                    corner = map._controlCorners[pos];

            corner.removeChild(this._container);
            this._map = null;

            if (this.onRemove) {
                this.onRemove(map);
            }

            return this;
        },
        _refocusOnMap: function () {
            if (this._map) {
                this._map.getContainer().focus();
            }
        }
    });

    L.control = function (options) {
        return new L.Control(options);
    };


// adds control-related methods to L.Map

    L.Map.include({
        addControl: function (control) {
            control.addTo(this);
            return this;
        },
        removeControl: function (control) {
            control.removeFrom(this);
            return this;
        },
        _initControlPos: function () {
            var corners = this._controlCorners = {},
                    l = 'leaflet-',
                    container = this._controlContainer =
                    L.DomUtil.create('div', l + 'control-container', this._container);

            function createCorner(vSide, hSide) {
                var className = l + vSide + ' ' + l + hSide;

                corners[vSide + hSide] = L.DomUtil.create('div', className, container);
            }

            createCorner('top', 'left');
            createCorner('top', 'right');
            createCorner('bottom', 'left');
            createCorner('bottom', 'right');
        },
        _clearControlPos: function () {
            this._container.removeChild(this._controlContainer);
        }
    });


    /*
     * L.Control.Zoom is used for the default zoom buttons on the map.
     */

    L.Control.Zoom = L.Control.extend({
        options: {
            position: 'topleft',
            zoomInText: '+',
            zoomInTitle: 'Zoom in',
            zoomOutText: '-',
            zoomOutTitle: 'Zoom out'
        },
        onAdd: function (map) {
            var zoomName = 'leaflet-control-zoom',
                    container = L.DomUtil.create('div', zoomName + ' leaflet-bar');

            this._map = map;

            this._zoomInButton = this._createButton(
                    this.options.zoomInText, this.options.zoomInTitle,
                    zoomName + '-in', container, this._zoomIn, this);
            this._zoomOutButton = this._createButton(
                    this.options.zoomOutText, this.options.zoomOutTitle,
                    zoomName + '-out', container, this._zoomOut, this);

            this._updateDisabled();
            map.on('zoomend zoomlevelschange', this._updateDisabled, this);

            return container;
        },
        onRemove: function (map) {
            map.off('zoomend zoomlevelschange', this._updateDisabled, this);
        },
        _zoomIn: function (e) {
            this._map.zoomIn(e.shiftKey ? 3 : 1);
        },
        _zoomOut: function (e) {
            this._map.zoomOut(e.shiftKey ? 3 : 1);
        },
        _createButton: function (html, title, className, container, fn, context) {
            var link = L.DomUtil.create('a', className, container);
            link.innerHTML = html;
            link.href = '#';
            link.title = title;

            var stop = L.DomEvent.stopPropagation;

            L.DomEvent
                    .on(link, 'click', stop)
                    .on(link, 'mousedown', stop)
                    .on(link, 'dblclick', stop)
                    .on(link, 'click', L.DomEvent.preventDefault)
                    .on(link, 'click', fn, context)
                    .on(link, 'click', this._refocusOnMap, context);

            return link;
        },
        _updateDisabled: function () {
            var map = this._map,
                    className = 'leaflet-disabled';

            L.DomUtil.removeClass(this._zoomInButton, className);
            L.DomUtil.removeClass(this._zoomOutButton, className);

            if (map._zoom === map.getMinZoom()) {
                L.DomUtil.addClass(this._zoomOutButton, className);
            }
            if (map._zoom === map.getMaxZoom()) {
                L.DomUtil.addClass(this._zoomInButton, className);
            }
        }
    });

    L.Map.mergeOptions({
        zoomControl: true
    });

    L.Map.addInitHook(function () {
        if (this.options.zoomControl) {
            this.zoomControl = new L.Control.Zoom();
            this.addControl(this.zoomControl);
        }
    });

    L.control.zoom = function (options) {
        return new L.Control.Zoom(options);
    };



    /*
     * L.Control.Attribution is used for displaying attribution on the map (added by default).
     */

    L.Control.Attribution = L.Control.extend({
        options: {
            position: 'bottomright',
            prefix: '<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
        },
        initialize: function (options) {
            L.setOptions(this, options);

            this._attributions = {};
        },
        onAdd: function (map) {
            this._container = L.DomUtil.create('div', 'leaflet-control-attribution');
            L.DomEvent.disableClickPropagation(this._container);

            for (var i in map._layers) {
                if (map._layers[i].getAttribution) {
                    this.addAttribution(map._layers[i].getAttribution());
                }
            }

            map
                    .on('layeradd', this._onLayerAdd, this)
                    .on('layerremove', this._onLayerRemove, this);

            this._update();

            return this._container;
        },
        onRemove: function (map) {
            map
                    .off('layeradd', this._onLayerAdd)
                    .off('layerremove', this._onLayerRemove);

        },
        setPrefix: function (prefix) {
            this.options.prefix = prefix;
            this._update();
            return this;
        },
        addAttribution: function (text) {
            if (!text) {
                return;
            }

            if (!this._attributions[text]) {
                this._attributions[text] = 0;
            }
            this._attributions[text]++;

            this._update();

            return this;
        },
        removeAttribution: function (text) {
            if (!text) {
                return;
            }

            if (this._attributions[text]) {
                this._attributions[text]--;
                this._update();
            }

            return this;
        },
        _update: function () {
            if (!this._map) {
                return;
            }

            var attribs = [];

            for (var i in this._attributions) {
                if (this._attributions[i]) {
                    attribs.push(i);
                }
            }

            var prefixAndAttribs = [];

            if (this.options.prefix) {
                prefixAndAttribs.push(this.options.prefix);
            }
            if (attribs.length) {
                prefixAndAttribs.push(attribs.join(', '));
            }

            this._container.innerHTML = prefixAndAttribs.join(' | ');
        },
        _onLayerAdd: function (e) {
            if (e.layer.getAttribution) {
                this.addAttribution(e.layer.getAttribution());
            }
        },
        _onLayerRemove: function (e) {
            if (e.layer.getAttribution) {
                this.removeAttribution(e.layer.getAttribution());
            }
        }
    });

    L.Map.mergeOptions({
        attributionControl: true
    });

    L.Map.addInitHook(function () {
        if (this.options.attributionControl) {
            this.attributionControl = (new L.Control.Attribution()).addTo(this);
        }
    });

    L.control.attribution = function (options) {
        return new L.Control.Attribution(options);
    };


    /*
     * L.Control.Scale is used for displaying metric/imperial scale on the map.
     */

    L.Control.Scale = L.Control.extend({
        options: {
            position: 'bottomleft',
            maxWidth: 100,
            metric: true,
            imperial: true,
            updateWhenIdle: false
        },
        onAdd: function (map) {
            this._map = map;

            var className = 'leaflet-control-scale',
                    container = L.DomUtil.create('div', className),
                    options = this.options;

            this._addScales(options, className, container);

            map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
            map.whenReady(this._update, this);

            return container;
        },
        onRemove: function (map) {
            map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
        },
        _addScales: function (options, className, container) {
            if (options.metric) {
                this._mScale = L.DomUtil.create('div', className + '-line', container);
            }
            if (options.imperial) {
                this._iScale = L.DomUtil.create('div', className + '-line', container);
            }
        },
        _update: function () {
            var bounds = this._map.getBounds(),
                    centerLat = bounds.getCenter().lat,
                    halfWorldMeters = 6378137 * Math.PI * Math.cos(centerLat * Math.PI / 180),
                    dist = halfWorldMeters * (bounds.getNorthEast().lng - bounds.getSouthWest().lng) / 180,
                    size = this._map.getSize(),
                    options = this.options,
                    maxMeters = 0;

            if (size.x > 0) {
                maxMeters = dist * (options.maxWidth / size.x);
            }

            this._updateScales(options, maxMeters);
        },
        _updateScales: function (options, maxMeters) {
            if (options.metric && maxMeters) {
                this._updateMetric(maxMeters);
            }

            if (options.imperial && maxMeters) {
                this._updateImperial(maxMeters);
            }
        },
        _updateMetric: function (maxMeters) {
            var meters = this._getRoundNum(maxMeters);

            this._mScale.style.width = this._getScaleWidth(meters / maxMeters) + 'px';
            this._mScale.innerHTML = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';
        },
        _updateImperial: function (maxMeters) {
            var maxFeet = maxMeters * 3.2808399,
                    scale = this._iScale,
                    maxMiles, miles, feet;

            if (maxFeet > 5280) {
                maxMiles = maxFeet / 5280;
                miles = this._getRoundNum(maxMiles);

                scale.style.width = this._getScaleWidth(miles / maxMiles) + 'px';
                scale.innerHTML = miles + ' mi';

            } else {
                feet = this._getRoundNum(maxFeet);

                scale.style.width = this._getScaleWidth(feet / maxFeet) + 'px';
                scale.innerHTML = feet + ' ft';
            }
        },
        _getScaleWidth: function (ratio) {
            return Math.round(this.options.maxWidth * ratio) - 10;
        },
        _getRoundNum: function (num) {
            var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),
                    d = num / pow10;

            d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;

            return pow10 * d;
        }
    });

    L.control.scale = function (options) {
        return new L.Control.Scale(options);
    };


    /*
     * L.Control.Layers is a control to allow users to switch between different layers on the map.
     */

    L.Control.Layers = L.Control.extend({
        options: {
            collapsed: true,
            position: 'topright',
            autoZIndex: true
        },
        initialize: function (baseLayers, overlays, options) {
            L.setOptions(this, options);

            this._layers = {};
            this._lastZIndex = 0;
            this._handlingClick = false;

            for (var i in baseLayers) {
                this._addLayer(baseLayers[i], i);
            }

            for (i in overlays) {
                this._addLayer(overlays[i], i, true);
            }
        },
        onAdd: function (map) {
            this._initLayout();
            this._update();

            map
                    .on('layeradd', this._onLayerChange, this)
                    .on('layerremove', this._onLayerChange, this);

            return this._container;
        },
        onRemove: function (map) {
            map
                    .off('layeradd', this._onLayerChange, this)
                    .off('layerremove', this._onLayerChange, this);
        },
        addBaseLayer: function (layer, name) {
            this._addLayer(layer, name);
            this._update();
            return this;
        },
        addOverlay: function (layer, name) {
            this._addLayer(layer, name, true);
            this._update();
            return this;
        },
        removeLayer: function (layer) {
            var id = L.stamp(layer);
            delete this._layers[id];
            this._update();
            return this;
        },
        _initLayout: function () {
            var className = 'leaflet-control-layers',
                    container = this._container = L.DomUtil.create('div', className);

            //Makes this work on IE10 Touch devices by stopping it from firing a mouseout event when the touch is released
            container.setAttribute('aria-haspopup', true);

            if (!L.Browser.touch) {
                L.DomEvent
                        .disableClickPropagation(container)
                        .disableScrollPropagation(container);
            } else {
                L.DomEvent.on(container, 'click', L.DomEvent.stopPropagation);
            }

            var form = this._form = L.DomUtil.create('form', className + '-list');

            if (this.options.collapsed) {
                if (!L.Browser.android) {
                    L.DomEvent
                            .on(container, 'mouseover', this._expand, this)
                            .on(container, 'mouseout', this._collapse, this);
                }
                var link = this._layersLink = L.DomUtil.create('a', className + '-toggle', container);
                link.href = '#';
                link.title = 'Layers';

                if (L.Browser.touch) {
                    L.DomEvent
                            .on(link, 'click', L.DomEvent.stop)
                            .on(link, 'click', this._expand, this);
                }
                else {
                    L.DomEvent.on(link, 'focus', this._expand, this);
                }
                //Work around for Firefox android issue https://github.com/Leaflet/Leaflet/issues/2033
                L.DomEvent.on(form, 'click', function () {
                    setTimeout(L.bind(this._onInputClick, this), 0);
                }, this);

                this._map.on('click', this._collapse, this);
                // TODO keyboard accessibility
            } else {
                this._expand();
            }

            this._baseLayersList = L.DomUtil.create('div', className + '-base', form);
            this._separator = L.DomUtil.create('div', className + '-separator', form);
            this._overlaysList = L.DomUtil.create('div', className + '-overlays', form);

            container.appendChild(form);
        },
        _addLayer: function (layer, name, overlay) {
            var id = L.stamp(layer);

            this._layers[id] = {
                layer: layer,
                name: name,
                overlay: overlay
            };

            if (this.options.autoZIndex && layer.setZIndex) {
                this._lastZIndex++;
                layer.setZIndex(this._lastZIndex);
            }
        },
        _update: function () {
            if (!this._container) {
                return;
            }

            this._baseLayersList.innerHTML = '';
            this._overlaysList.innerHTML = '';

            var baseLayersPresent = false,
                    overlaysPresent = false,
                    i, obj;

            for (i in this._layers) {
                obj = this._layers[i];
                this._addItem(obj);
                overlaysPresent = overlaysPresent || obj.overlay;
                baseLayersPresent = baseLayersPresent || !obj.overlay;
            }

            this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';
        },
        _onLayerChange: function (e) {
            var obj = this._layers[L.stamp(e.layer)];

            if (!obj) {
                return;
            }

            if (!this._handlingClick) {
                this._update();
            }

            var type = obj.overlay ?
                    (e.type === 'layeradd' ? 'overlayadd' : 'overlayremove') :
                    (e.type === 'layeradd' ? 'baselayerchange' : null);

            if (type) {
                this._map.fire(type, obj);
            }
        },
        // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)
        _createRadioElement: function (name, checked) {

            var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name + '"';
            if (checked) {
                radioHtml += ' checked="checked"';
            }
            radioHtml += '/>';

            var radioFragment = document.createElement('div');
            radioFragment.innerHTML = radioHtml;

            return radioFragment.firstChild;
        },
        _addItem: function (obj) {
            var label = document.createElement('label'),
                    input,
                    checked = this._map.hasLayer(obj.layer);

            if (obj.overlay) {
                input = document.createElement('input');
                input.type = 'checkbox';
                input.className = 'leaflet-control-layers-selector';
                input.defaultChecked = checked;
            } else {
                input = this._createRadioElement('leaflet-base-layers', checked);
            }

            input.layerId = L.stamp(obj.layer);

            L.DomEvent.on(input, 'click', this._onInputClick, this);

            var name = document.createElement('span');
            name.innerHTML = ' ' + obj.name;

            label.appendChild(input);
            label.appendChild(name);

            var container = obj.overlay ? this._overlaysList : this._baseLayersList;
            container.appendChild(label);

            return label;
        },
        _onInputClick: function () {
            var i, input, obj,
                    inputs = this._form.getElementsByTagName('input'),
                    inputsLen = inputs.length;

            this._handlingClick = true;

            for (i = 0; i < inputsLen; i++) {
                input = inputs[i];
                obj = this._layers[input.layerId];

                if (input.checked && !this._map.hasLayer(obj.layer)) {
                    this._map.addLayer(obj.layer);

                } else if (!input.checked && this._map.hasLayer(obj.layer)) {
                    this._map.removeLayer(obj.layer);
                }
            }

            this._handlingClick = false;

            this._refocusOnMap();
        },
        _expand: function () {
            L.DomUtil.addClass(this._container, 'leaflet-control-layers-expanded');
        },
        _collapse: function () {
            this._container.className = this._container.className.replace(' leaflet-control-layers-expanded', '');
        }
    });

    L.control.layers = function (baseLayers, overlays, options) {
        return new L.Control.Layers(baseLayers, overlays, options);
    };


    /*
     * L.PosAnimation is used by Leaflet internally for pan animations.
     */

    L.PosAnimation = L.Class.extend({
        includes: L.Mixin.Events,
        run: function (el, newPos, duration, easeLinearity) { // (HTMLElement, Point[, Number, Number])
            this.stop();

            this._el = el;
            this._inProgress = true;
            this._newPos = newPos;

            this.fire('start');

            el.style[L.DomUtil.TRANSITION] = 'all ' + (duration || 0.25) +
                    's cubic-bezier(0,0,' + (easeLinearity || 0.5) + ',1)';

            L.DomEvent.on(el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);
            L.DomUtil.setPosition(el, newPos);

            // toggle reflow, Chrome flickers for some reason if you don't do this
            L.Util.falseFn(el.offsetWidth);

            // there's no native way to track value updates of transitioned properties, so we imitate this
            this._stepTimer = setInterval(L.bind(this._onStep, this), 50);
        },
        stop: function () {
            if (!this._inProgress) {
                return;
            }

            // if we just removed the transition property, the element would jump to its final position,
            // so we need to make it stay at the current position

            L.DomUtil.setPosition(this._el, this._getPos());
            this._onTransitionEnd();
            L.Util.falseFn(this._el.offsetWidth); // force reflow in case we are about to start a new animation
        },
        _onStep: function () {
            var stepPos = this._getPos();
            if (!stepPos) {
                this._onTransitionEnd();
                return;
            }
            // jshint camelcase: false
            // make L.DomUtil.getPosition return intermediate position value during animation
            this._el._leaflet_pos = stepPos;

            this.fire('step');
        },
        // you can't easily get intermediate values of properties animated with CSS3 Transitions,
        // we need to parse computed style (in case of transform it returns matrix string)

        _transformRe: /([-+]?(?:\d*\.)?\d+)\D*, ([-+]?(?:\d*\.)?\d+)\D*\)/,
        _getPos: function () {
            var left, top, matches,
                    el = this._el,
                    style = window.getComputedStyle(el);

            if (L.Browser.any3d) {
                matches = style[L.DomUtil.TRANSFORM].match(this._transformRe);
                if (!matches) {
                    return;
                }
                left = parseFloat(matches[1]);
                top = parseFloat(matches[2]);
            } else {
                left = parseFloat(style.left);
                top = parseFloat(style.top);
            }

            return new L.Point(left, top, true);
        },
        _onTransitionEnd: function () {
            L.DomEvent.off(this._el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);

            if (!this._inProgress) {
                return;
            }
            this._inProgress = false;

            this._el.style[L.DomUtil.TRANSITION] = '';

            // jshint camelcase: false
            // make sure L.DomUtil.getPosition returns the final position value after animation
            this._el._leaflet_pos = this._newPos;

            clearInterval(this._stepTimer);

            this.fire('step').fire('end');
        }

    });


    /*
     * Extends L.Map to handle panning animations.
     */

    L.Map.include({
        setView: function (center, zoom, options) {

            zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
            center = this._limitCenter(L.latLng(center), zoom, this.options.maxBounds);
            options = options || {};

            if (this._panAnim) {
                this._panAnim.stop();
            }

            if (this._loaded && !options.reset && options !== true) {

                if (options.animate !== undefined) {
                    options.zoom = L.extend({animate: options.animate}, options.zoom);
                    options.pan = L.extend({animate: options.animate}, options.pan);
                }

                // try animating pan or zoom
                var animated = (this._zoom !== zoom) ?
                        this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :
                        this._tryAnimatedPan(center, options.pan);

                if (animated) {
                    // prevent resize handler call, the view will refresh after animation anyway
                    clearTimeout(this._sizeTimer);
                    return this;
                }
            }

            // animation didn't start, just reset the map view
            this._resetView(center, zoom);

            return this;
        },
        panBy: function (offset, options) {
            offset = L.point(offset).round();
            options = options || {};

            if (!offset.x && !offset.y) {
                return this;
            }

            if (!this._panAnim) {
                this._panAnim = new L.PosAnimation();

                this._panAnim.on({
                    'step': this._onPanTransitionStep,
                    'end': this._onPanTransitionEnd
                }, this);
            }

            // don't fire movestart if animating inertia
            if (!options.noMoveStart) {
                this.fire('movestart');
            }

            // animate pan unless animate: false specified
            if (options.animate !== false) {
                L.DomUtil.addClass(this._mapPane, 'leaflet-pan-anim');

                var newPos = this._getMapPanePos().subtract(offset);
                this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
            } else {
                this._rawPanBy(offset);
                this.fire('move').fire('moveend');
            }

            return this;
        },
        _onPanTransitionStep: function () {
            this.fire('move');
        },
        _onPanTransitionEnd: function () {
            L.DomUtil.removeClass(this._mapPane, 'leaflet-pan-anim');
            this.fire('moveend');
        },
        _tryAnimatedPan: function (center, options) {
            // difference between the new and current centers in pixels
            var offset = this._getCenterOffset(center)._floor();

            // don't animate too far unless animate: true specified in options
            if ((options && options.animate) !== true && !this.getSize().contains(offset)) {
                return false;
            }

            this.panBy(offset, options);

            return true;
        }
    });


    /*
     * L.PosAnimation fallback implementation that powers Leaflet pan animations
     * in browsers that don't support CSS3 Transitions.
     */

    L.PosAnimation = L.DomUtil.TRANSITION ? L.PosAnimation : L.PosAnimation.extend({
        run: function (el, newPos, duration, easeLinearity) { // (HTMLElement, Point[, Number, Number])
            this.stop();

            this._el = el;
            this._inProgress = true;
            this._duration = duration || 0.25;
            this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);

            this._startPos = L.DomUtil.getPosition(el);
            this._offset = newPos.subtract(this._startPos);
            this._startTime = +new Date();

            this.fire('start');

            this._animate();
        },
        stop: function () {
            if (!this._inProgress) {
                return;
            }

            this._step();
            this._complete();
        },
        _animate: function () {
            // animation loop
            this._animId = L.Util.requestAnimFrame(this._animate, this);
            this._step();
        },
        _step: function () {
            var elapsed = (+new Date()) - this._startTime,
                    duration = this._duration * 1000;

            if (elapsed < duration) {
                this._runFrame(this._easeOut(elapsed / duration));
            } else {
                this._runFrame(1);
                this._complete();
            }
        },
        _runFrame: function (progress) {
            var pos = this._startPos.add(this._offset.multiplyBy(progress));
            L.DomUtil.setPosition(this._el, pos);

            this.fire('step');
        },
        _complete: function () {
            L.Util.cancelAnimFrame(this._animId);

            this._inProgress = false;
            this.fire('end');
        },
        _easeOut: function (t) {
            return 1 - Math.pow(1 - t, this._easeOutPower);
        }
    });


    /*
     * Extends L.Map to handle zoom animations.
     */

    L.Map.mergeOptions({
        zoomAnimation: true,
        zoomAnimationThreshold: 4
    });

    if (L.DomUtil.TRANSITION) {

        L.Map.addInitHook(function () {
            // don't animate on browsers without hardware-accelerated transitions or old Android/Opera
            this._zoomAnimated = this.options.zoomAnimation && L.DomUtil.TRANSITION &&
                    L.Browser.any3d && !L.Browser.android23 && !L.Browser.mobileOpera;

            // zoom transitions run with the same duration for all layers, so if one of transitionend events
            // happens after starting zoom animation (propagating to the map pane), we know that it ended globally
            if (this._zoomAnimated) {
                L.DomEvent.on(this._mapPane, L.DomUtil.TRANSITION_END, this._catchTransitionEnd, this);
            }
        });
    }

    L.Map.include(!L.DomUtil.TRANSITION ? {} : {
        _catchTransitionEnd: function (e) {
            if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {
                this._onZoomTransitionEnd();
            }
        },
        _nothingToAnimate: function () {
            return !this._container.getElementsByClassName('leaflet-zoom-animated').length;
        },
        _tryAnimatedZoom: function (center, zoom, options) {

            if (this._animatingZoom) {
                return true;
            }

            options = options || {};

            // don't animate if disabled, not supported or zoom difference is too large
            if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||
                    Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) {
                return false;
            }

            // offset is the pixel coords of the zoom origin relative to the current center
            var scale = this.getZoomScale(zoom),
                    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale),
                    origin = this._getCenterLayerPoint()._add(offset);

            // don't animate if the zoom origin isn't within one screen from the current center, unless forced
            if (options.animate !== true && !this.getSize().contains(offset)) {
                return false;
            }

            this
                    .fire('movestart')
                    .fire('zoomstart');

            this._animateZoom(center, zoom, origin, scale, null, true);

            return true;
        },
        _animateZoom: function (center, zoom, origin, scale, delta, backwards, forTouchZoom) {

            if (!forTouchZoom) {
                this._animatingZoom = true;
            }

            // put transform transition on all layers with leaflet-zoom-animated class
            L.DomUtil.addClass(this._mapPane, 'leaflet-zoom-anim');

            // remember what center/zoom to set after animation
            this._animateToCenter = center;
            this._animateToZoom = zoom;

            // disable any dragging during animation
            if (L.Draggable) {
                L.Draggable._disabled = true;
            }

            L.Util.requestAnimFrame(function () {
                this.fire('zoomanim', {
                    center: center,
                    zoom: zoom,
                    origin: origin,
                    scale: scale,
                    delta: delta,
                    backwards: backwards
                });
            }, this);
        },
        _onZoomTransitionEnd: function () {

            this._animatingZoom = false;

            L.DomUtil.removeClass(this._mapPane, 'leaflet-zoom-anim');

            this._resetView(this._animateToCenter, this._animateToZoom, true, true);

            if (L.Draggable) {
                L.Draggable._disabled = false;
            }
        }
    });


    /*
     Zoom animation logic for L.TileLayer.
     */

    L.TileLayer.include({
        _animateZoom: function (e) {
            if (!this._animating) {
                this._animating = true;
                this._prepareBgBuffer();
            }

            var bg = this._bgBuffer,
                    transform = L.DomUtil.TRANSFORM,
                    initialTransform = e.delta ? L.DomUtil.getTranslateString(e.delta) : bg.style[transform],
                    scaleStr = L.DomUtil.getScaleString(e.scale, e.origin);

            bg.style[transform] = e.backwards ?
                    scaleStr + ' ' + initialTransform :
                    initialTransform + ' ' + scaleStr;
        },
        _endZoomAnim: function () {
            var front = this._tileContainer,
                    bg = this._bgBuffer;

            front.style.visibility = '';
            front.parentNode.appendChild(front); // Bring to fore

            // force reflow
            L.Util.falseFn(bg.offsetWidth);

            this._animating = false;
        },
        _clearBgBuffer: function () {
            var map = this._map;

            if (map && !map._animatingZoom && !map.touchZoom._zooming) {
                this._bgBuffer.innerHTML = '';
                this._bgBuffer.style[L.DomUtil.TRANSFORM] = '';
            }
        },
        _prepareBgBuffer: function () {

            var front = this._tileContainer,
                    bg = this._bgBuffer;

            // if foreground layer doesn't have many tiles but bg layer does,
            // keep the existing bg layer and just zoom it some more

            var bgLoaded = this._getLoadedTilesPercentage(bg),
                    frontLoaded = this._getLoadedTilesPercentage(front);

            if (bg && bgLoaded > 0.5 && frontLoaded < 0.5) {

                front.style.visibility = 'hidden';
                this._stopLoadingImages(front);
                return;
            }

            // prepare the buffer to become the front tile pane
            bg.style.visibility = 'hidden';
            bg.style[L.DomUtil.TRANSFORM] = '';

            // switch out the current layer to be the new bg layer (and vice-versa)
            this._tileContainer = bg;
            bg = this._bgBuffer = front;

            this._stopLoadingImages(bg);

            //prevent bg buffer from clearing right after zoom
            clearTimeout(this._clearBgBufferTimer);
        },
        _getLoadedTilesPercentage: function (container) {
            var tiles = container.getElementsByTagName('img'),
                    i, len, count = 0;

            for (i = 0, len = tiles.length; i < len; i++) {
                if (tiles[i].complete) {
                    count++;
                }
            }
            return count / len;
        },
        // stops loading all tiles in the background layer
        _stopLoadingImages: function (container) {
            var tiles = Array.prototype.slice.call(container.getElementsByTagName('img')),
                    i, len, tile;

            for (i = 0, len = tiles.length; i < len; i++) {
                tile = tiles[i];

                if (!tile.complete) {
                    tile.onload = L.Util.falseFn;
                    tile.onerror = L.Util.falseFn;
                    tile.src = L.Util.emptyImageUrl;

                    tile.parentNode.removeChild(tile);
                }
            }
        }
    });


    /*
     * Provides L.Map with convenient shortcuts for using browser geolocation features.
     */

    L.Map.include({
        _defaultLocateOptions: {
            watch: false,
            setView: false,
            maxZoom: Infinity,
            timeout: 10000,
            maximumAge: 0,
            enableHighAccuracy: false
        },
        locate: function (/*Object*/ options) {

            options = this._locateOptions = L.extend(this._defaultLocateOptions, options);

            if (!navigator.geolocation) {
                this._handleGeolocationError({
                    code: 0,
                    message: 'Geolocation not supported.'
                });
                return this;
            }

            var onResponse = L.bind(this._handleGeolocationResponse, this),
                    onError = L.bind(this._handleGeolocationError, this);

            if (options.watch) {
                this._locationWatchId =
                        navigator.geolocation.watchPosition(onResponse, onError, options);
            } else {
                navigator.geolocation.getCurrentPosition(onResponse, onError, options);
            }
            return this;
        },
        stopLocate: function () {
            if (navigator.geolocation) {
                navigator.geolocation.clearWatch(this._locationWatchId);
            }
            if (this._locateOptions) {
                this._locateOptions.setView = false;
            }
            return this;
        },
        _handleGeolocationError: function (error) {
            var c = error.code,
                    message = error.message ||
                    (c === 1 ? 'permission denied' :
                            (c === 2 ? 'position unavailable' : 'timeout'));

            if (this._locateOptions.setView && !this._loaded) {
                this.fitWorld();
            }

            this.fire('locationerror', {
                code: c,
                message: 'Geolocation error: ' + message + '.'
            });
        },
        _handleGeolocationResponse: function (pos) {
            var lat = pos.coords.latitude,
                    lng = pos.coords.longitude,
                    latlng = new L.LatLng(lat, lng),
                    latAccuracy = 180 * pos.coords.accuracy / 40075017,
                    lngAccuracy = latAccuracy / Math.cos(L.LatLng.DEG_TO_RAD * lat),
                    bounds = L.latLngBounds(
                            [lat - latAccuracy, lng - lngAccuracy],
                            [lat + latAccuracy, lng + lngAccuracy]),
                    options = this._locateOptions;

            if (options.setView) {
                var zoom = Math.min(this.getBoundsZoom(bounds), options.maxZoom);
                this.setView(latlng, zoom);
            }

            var data = {
                latlng: latlng,
                bounds: bounds,
                timestamp: pos.timestamp
            };

            for (var i in pos.coords) {
                if (typeof pos.coords[i] === 'number') {
                    data[i] = pos.coords[i];
                }
            }

            this.fire('locationfound', data);
        }
    });


}(window, document));
L.BingLayer = L.TileLayer.extend({
	options: {
		subdomains: [0, 1, 2, 3],
		type: 'Aerial',
		attribution: 'Bing'
	},

	initialize: function(key, options) {
		L.Util.setOptions(this, options);

		this._key = key;
		this._url = null;
		this.meta = {};
		this.loadMetadata();
	},

	tile2quad: function(x, y, z) {
		var quad = '';
		for (var i = z; i > 0; i--) {
			var digit = 0;
			var mask = 1 << (i - 1);
			if ((x & mask) != 0) digit += 1;
			if ((y & mask) != 0) digit += 2;
			quad = quad + digit;
		}
		return quad;
	},

	getTileUrl: function(p, z) {
		var z = this._getZoomForUrl();
		var subdomains = this.options.subdomains,
			s = this.options.subdomains[(p.x + p.y) % subdomains.length];
		return this._url.replace('{subdomain}', s)
				.replace('{quadkey}', this.tile2quad(p.x, p.y, z))
				.replace('{culture}', '');
	},

	loadMetadata: function() {
		var _this = this;
		var cbid = '_bing_metadata_' + L.Util.stamp(this);
		window[cbid] = function (meta) {
			_this.meta = meta;
			window[cbid] = undefined;
			var e = document.getElementById(cbid);
			e.parentNode.removeChild(e);
			if (meta.errorDetails) {
				alert("Got metadata" + meta.errorDetails);
				return;
			}
			_this.initMetadata();
		};
		var url = "http://dev.virtualearth.net/REST/v1/Imagery/Metadata/" + this.options.type + "?include=ImageryProviders&jsonp=" + cbid + "&key=" + this._key;
		var script = document.createElement("script");
		script.type = "text/javascript";
		script.src = url;
		script.id = cbid;
		document.getElementsByTagName("head")[0].appendChild(script);
	},

	initMetadata: function() {
		var r = this.meta.resourceSets[0].resources[0];
		this.options.subdomains = r.imageUrlSubdomains;
		this._url = r.imageUrl;
		this._providers = [];
		for (var i = 0; i < r.imageryProviders.length; i++) {
			var p = r.imageryProviders[i];
			for (var j = 0; j < p.coverageAreas.length; j++) {
				var c = p.coverageAreas[j];
				var coverage = {zoomMin: c.zoomMin, zoomMax: c.zoomMax, active: false};
				var bounds = new L.LatLngBounds(
						new L.LatLng(c.bbox[0]+0.01, c.bbox[1]+0.01),
						new L.LatLng(c.bbox[2]-0.01, c.bbox[3]-0.01)
				);
				coverage.bounds = bounds;
				coverage.attrib = p.attribution;
				this._providers.push(coverage);
			}
		}
		this._update();
	},

	_update: function() {
		if (this._url == null || !this._map) return;
		this._update_attribution();
		L.TileLayer.prototype._update.apply(this, []);
	},

	_update_attribution: function() {
		var bounds = this._map.getBounds();
		var zoom = this._map.getZoom();
		for (var i = 0; i < this._providers.length; i++) {
			var p = this._providers[i];
			if ((zoom <= p.zoomMax && zoom >= p.zoomMin) &&
					bounds.intersects(p.bounds)) {
				if (!p.active)
					this._map.attributionControl.addAttribution(p.attrib);
				p.active = true;
			} else {
				if (p.active)
					this._map.attributionControl.removeAttribution(p.attrib);
				p.active = false;
			}
		}
	},

	onRemove: function(map) {
		for (var i = 0; i < this._providers.length; i++) {
			var p = this._providers[i];
			if (p.active) {
				this._map.attributionControl.removeAttribution(p.attrib);
				p.active = false;
			}
		}
        	L.TileLayer.prototype.onRemove.apply(this, [map]);
	}
});

L.Control.MiniMap = L.Control.extend({
	options: {
		position: 'bottomright',
		toggleDisplay: false,
		zoomLevelOffset: -5,
		zoomLevelFixed: false,
		zoomAnimation: false,
		autoToggleDisplay: false,
		width: 150,
		height: 150,
		aimingRectOptions: {color: "#ff7800", weight: 1, clickable: false},
		shadowRectOptions: {color: "#000000", weight: 1, clickable: false, opacity:0, fillOpacity:0}
	},
	
	hideText: 'Hide MiniMap',
	
	showText: 'Show MiniMap',
	
	//layer is the map layer to be shown in the minimap
	initialize: function (layer, options) {
		L.Util.setOptions(this, options);
		//Make sure the aiming rects are non-clickable even if the user tries to set them clickable (most likely by forgetting to specify them false)
		this.options.aimingRectOptions.clickable = false;
		this.options.shadowRectOptions.clickable = false;
		this._layer = layer;
	},
	
	onAdd: function (map) {

		this._mainMap = map;

		//Creating the container and stopping events from spilling through to the main map.
		this._container = L.DomUtil.create('div', 'leaflet-control-minimap');
		this._container.style.width = this.options.width + 'px';
		this._container.style.height = this.options.height + 'px';
		L.DomEvent.disableClickPropagation(this._container);
		L.DomEvent.on(this._container, 'mousewheel', L.DomEvent.stopPropagation);


		this._miniMap = new L.Map(this._container,
		{
			attributionControl: false,
			zoomControl: false,
			zoomAnimation: this.options.zoomAnimation,
			autoToggleDisplay: this.options.autoToggleDisplay,
			touchZoom: !this.options.zoomLevelFixed,
			scrollWheelZoom: !this.options.zoomLevelFixed,
			doubleClickZoom: !this.options.zoomLevelFixed,
			boxZoom: !this.options.zoomLevelFixed,
			crs: map.options.crs
		});

		this._miniMap.addLayer(this._layer);

		//These bools are used to prevent infinite loops of the two maps notifying each other that they've moved.
		this._mainMapMoving = false;
		this._miniMapMoving = false;

		//Keep a record of this to prevent auto toggling when the user explicitly doesn't want it.
		this._userToggledDisplay = false;
		this._minimized = false;

		if (this.options.toggleDisplay) {
			this._addToggleButton();
		}

		this._miniMap.whenReady(L.Util.bind(function () {
			this._aimingRect = L.rectangle(this._mainMap.getBounds(), this.options.aimingRectOptions).addTo(this._miniMap);
			this._shadowRect = L.rectangle(this._mainMap.getBounds(), this.options.shadowRectOptions).addTo(this._miniMap);
			this._mainMap.on('moveend', this._onMainMapMoved, this);
			this._mainMap.on('move', this._onMainMapMoving, this);
			this._miniMap.on('movestart', this._onMiniMapMoveStarted, this);
			this._miniMap.on('move', this._onMiniMapMoving, this);
			this._miniMap.on('moveend', this._onMiniMapMoved, this);
		}, this));

		return this._container;
	},

	addTo: function (map) {
		L.Control.prototype.addTo.call(this, map);
		this._miniMap.setView(this._mainMap.getCenter(), this._decideZoom(true));
		this._setDisplay(this._decideMinimized());
		return this;
	},

	onRemove: function (map) {
		this._mainMap.off('moveend', this._onMainMapMoved, this);
		this._mainMap.off('move', this._onMainMapMoving, this);
		this._miniMap.off('moveend', this._onMiniMapMoved, this);

		this._miniMap.removeLayer(this._layer);
	},

	_addToggleButton: function () {
		this._toggleDisplayButton = this.options.toggleDisplay ? this._createButton(
				'', this.hideText, 'leaflet-control-minimap-toggle-display', this._container, this._toggleDisplayButtonClicked, this) : undefined;
	},

	_createButton: function (html, title, className, container, fn, context) {
		var link = L.DomUtil.create('a', className, container);
		link.innerHTML = html;
		link.href = '#';
		link.title = title;

		var stop = L.DomEvent.stopPropagation;

		L.DomEvent
			.on(link, 'click', stop)
			.on(link, 'mousedown', stop)
			.on(link, 'dblclick', stop)
			.on(link, 'click', L.DomEvent.preventDefault)
			.on(link, 'click', fn, context);

		return link;
	},

	_toggleDisplayButtonClicked: function () {
		this._userToggledDisplay = true;
		if (!this._minimized) {
			this._minimize();
			this._toggleDisplayButton.title = this.showText;
		}
		else {
			this._restore();
			this._toggleDisplayButton.title = this.hideText;
		}
	},

	_setDisplay: function (minimize) {
		if (minimize != this._minimized) {
			if (!this._minimized) {
				this._minimize();
			}
			else {
				this._restore();
			}
		}
	},

	_minimize: function () {
		// hide the minimap
		if (this.options.toggleDisplay) {
			this._container.style.width = '19px';
			this._container.style.height = '19px';
			this._toggleDisplayButton.className += ' minimized';
		}
		else {
			this._container.style.display = 'none';
		}
		this._minimized = true;
	},

	_restore: function () {
		if (this.options.toggleDisplay) {
			this._container.style.width = this.options.width + 'px';
			this._container.style.height = this.options.height + 'px';
			this._toggleDisplayButton.className = this._toggleDisplayButton.className
					.replace(/(?:^|\s)minimized(?!\S)/g, '');
		}
		else {
			this._container.style.display = 'block';
		}
		this._minimized = false;
	},

	_onMainMapMoved: function (e) {
		if (!this._miniMapMoving) {
			this._mainMapMoving = true;
			this._miniMap.setView(this._mainMap.getCenter(), this._decideZoom(true));
			this._setDisplay(this._decideMinimized());
		} else {
			this._miniMapMoving = false;
		}
		this._aimingRect.setBounds(this._mainMap.getBounds());
	},

	_onMainMapMoving: function (e) {
		this._aimingRect.setBounds(this._mainMap.getBounds());
	},

	_onMiniMapMoveStarted:function (e) {
		var lastAimingRect = this._aimingRect.getBounds();
		var sw = this._miniMap.latLngToContainerPoint(lastAimingRect.getSouthWest());
		var ne = this._miniMap.latLngToContainerPoint(lastAimingRect.getNorthEast());
		this._lastAimingRectPosition = {sw:sw,ne:ne};
	},

	_onMiniMapMoving: function (e) {
		if (!this._mainMapMoving && this._lastAimingRectPosition) {
			this._shadowRect.setBounds(new L.LatLngBounds(this._miniMap.containerPointToLatLng(this._lastAimingRectPosition.sw),this._miniMap.containerPointToLatLng(this._lastAimingRectPosition.ne)));
			this._shadowRect.setStyle({opacity:1,fillOpacity:0.3});
		}
	},

	_onMiniMapMoved: function (e) {
		if (!this._mainMapMoving) {
			this._miniMapMoving = true;
			this._mainMap.setView(this._miniMap.getCenter(), this._decideZoom(false));
			this._shadowRect.setStyle({opacity:0,fillOpacity:0});
		} else {
			this._mainMapMoving = false;
		}
	},

	_decideZoom: function (fromMaintoMini) {
		if (!this.options.zoomLevelFixed) {
			if (fromMaintoMini)
				return this._mainMap.getZoom() + this.options.zoomLevelOffset;
			else {
				var currentDiff = this._miniMap.getZoom() - this._mainMap.getZoom();
				var proposedZoom = this._miniMap.getZoom() - this.options.zoomLevelOffset;
				var toRet;
				
				if (currentDiff > this.options.zoomLevelOffset && this._mainMap.getZoom() < this._miniMap.getMinZoom() - this.options.zoomLevelOffset) {
					//This means the miniMap is zoomed out to the minimum zoom level and can't zoom any more.
					if (this._miniMap.getZoom() > this._lastMiniMapZoom) {
						//This means the user is trying to zoom in by using the minimap, zoom the main map.
						toRet = this._mainMap.getZoom() + 1;
						//Also we cheat and zoom the minimap out again to keep it visually consistent.
						this._miniMap.setZoom(this._miniMap.getZoom() -1);
					} else {
						//Either the user is trying to zoom out past the mini map's min zoom or has just panned using it, we can't tell the difference.
						//Therefore, we ignore it!
						toRet = this._mainMap.getZoom();
					}
				} else {
					//This is what happens in the majority of cases, and always if you configure the min levels + offset in a sane fashion.
					toRet = proposedZoom;
				}
				this._lastMiniMapZoom = this._miniMap.getZoom();
				return toRet;
			}
		} else {
			if (fromMaintoMini)
				return this.options.zoomLevelFixed;
			else
				return this._mainMap.getZoom();
		}
	},

	_decideMinimized: function () {
		if (this._userToggledDisplay) {
			return this._minimized;
		}

		if (this.options.autoToggleDisplay) {
			if (this._mainMap.getBounds().contains(this._miniMap.getBounds())) {
				return true;
			}
			return false;
		}

		return this._minimized;
	}
});

L.Map.mergeOptions({
	miniMapControl: false
});

L.Map.addInitHook(function () {
	if (this.options.miniMapControl) {
		this.miniMapControl = (new L.Control.MiniMap()).addTo(this);
	}
});

L.control.minimap = function (options) {
	return new L.Control.MiniMap(options);
};

/* 
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
if (I18n === undefined)
    var I18n;
I18n = I18n || {};
I18n.translations = {'en': {
        'Cancel drawing': 'Cancel drawing',
        "Cancel": "Cancel",
        "Delete last point drawn": "Delete last point drawn",
        "Delete last point": "Delete last point",
        "Draw a polyline": "Draw a polyline",
        "Draw a polygon": "Draw a polygon",
        "Draw a rectangle": "Draw a rectangle",
        "Draw a circle": "Draw a circle",
        "Draw a marker": "Draw a marker",
        "Click and drag to draw circle.": "Click and drag to draw circle.",
        "Click map to place marker.": "Click map to place marker.",
        "Click to start drawing shape.": "Click to start drawing shape.",
        "Click to continue drawing shape.": "Click to continue drawing shape.",
        "Click first point to close this shape.": "Click first point to close this shape.",
        "<strong>Error:</strong> shape edges cannot cross!": "<strong>Error:</strong> shape edges cannot cross!",
        "Click to start drawing line.": "Click to start drawing line.",
        "Click to continue drawing line.": "Click to continue drawing line.",
        "Click last point to finish line.": "Click last point to finish line.",
        "Click and drag to draw rectangle.": "Click and drag to draw rectangle.",
        "Release mouse to finish drawing.": "Release mouse to finish drawing.",
        "Save changes": "Save changes",
        "Save": "Save",
        "Cancel editing, discards all changes.": "Cancel editing, discards all changes.",
        "Edit layers": "Edit layers",
        "No layers to edit": "No layers to edit",
        "Delete layers": "Delete layers",
        "No layers to delete": "No layers to delete.",
        "Drag handles, or marker to edit feature.": "Drag handles, or marker to edit feature.",
        "Click cancel to undo changes": "Click cancel to undo changes.",
        "Click on a feature to remove": "Click on a feature to remove"
    }
};

/* 
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
if (I18n === undefined)
    var I18n;
I18n = I18n || {};
I18n.translations = {'es': {
        'Cancel drawing': 'Cancelar dibujo',
        "Cancel": "Cancelar",
        "Delete last point drawn": "Borrar el último punto dibujado",
        "Delete last point": "Borrar el último punto",
        "Draw a polyline": "Dibuje una polilínea",
        "Draw a polygon": "Dibuja un polígono",
        "Draw a rectangle": "Dibuje un rectángulo",
        "Draw a circle": "Dibuja un círculo",
        "Draw a marker": "Dibuje un marcador",
        "Click and drag to draw circle": "Haga clic y arrastre para dibujar el círculo.",
        "Click map to place marker": "Haga clic en el mapa para colocar marcadores.",
        "Click to start drawing shape": "Haga clic para empezar a dibujar la forma.",
        "Click to continue drawing shape": "Haga clic para seguir dibujando la forma.",
        "Click first point to close this shape": "Haga clic en el primer punto para cerrar esta forma.",
        "<strong>Error:</strong> shape edges cannot cross!": "<strong>Error:</strong> dan forma a los bordes no pueden cruzar!",
        "Click to start drawing line": "Haga clic para empezar a dibujar la línea.",
        "Click to continue drawing line": "Haga clic para continuar la línea de dibujo.",
        "Click last point to finish line": "Haga clic último punto para terminar la línea.",
        "Click and drag to draw rectangle": "Haga clic y arrastre para dibujar rectángulo.",
        "Release mouse to finish drawing": "Suelte el ratón para terminar el dibujo.",
        "Save changes": "Guardar cambios",
        "Save": "Guardar",
        "Cancel editing, discards all changes": "Cancelar la edición, descarta todos los cambios",
        "Edit layers": "Editar capas.",
        "No layers to edit": "No hay capas para editar.",
        "Delete layers": "Eliminar capas",
        "No layers to delete": "No hay capas para eliminar.",
        "Drag handles, or marker to edit feature": "Control de arrastre, o marcador para editar característica.",
        "Click cancel to undo changes": "Haga clic en Cancelar para deshacer los cambios.",
        "Click on a feature to remove": "Haga clic en una función para eliminar."
    }
};

/* 
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
var draw_translations = {'zh': {
        'Cancel drawing': '取消当前的画图形操作.',
        "Cancel": "取消.",
        "Delete last point drawn": "删除最后所画的点.",
        "Delete last point": "删除最后一个点.",
        "Draw a polyline": "画线.",
        "Draw a polygon": "画多边形.",
        "Draw a rectangle": "画矩形.",
        "Draw a circle": "画圆.",
        "Draw a marker": "画标记.",
        "Click and drag to draw circle.": "单击并拖动以画圆.",
        "Click map to place marker.": "点击地图以放置标记.",
        "Click to start drawing shape.": "点击开始画图形.",
        "Click to continue drawing shape.": "点击继续画图形.",
        "Click first point to close this shape.": "点击第一个点来关闭这个图形.",
        "<strong>Error:</strong> shape edges cannot cross!": "<strong>错误:</strong> 图形边界不能交叉!",
        "Click to start drawing line.": "点击开始画线.",
        "Click to continue drawing line.": "点击继续画线.",
        "Click last point to finish line.": "单击最后一个点来结束画线.",
        "Click and drag to draw rectangle.": "单击并拖动鼠标画矩形.",
        "Release mouse to finish drawing.": "松开鼠标完成当前的操作.",
        "Save changes": "保存更改.",
        "Save": "保存.",
        "Cancel editing, discards all changes": "取消编辑，放弃所有更改.",
        "Edit layers": "编辑图层.",
        "No layers to edit": "没有图层进行编辑.",
        "Delete layers": "删除图层.",
        "No layers to delete": "没有图层删除.",
        "Drag handles, or marker to edit feature.": "拖动控制点，或标记编辑功能.",
        "Click cancel to undo changes.": "单击‘取消’取消修改.",
        "Click on a feature to remove": "点击要删除的图元进行删除操作."
    }
};
if (I18n !== undefined && I18n.translations !== undefined)
{
    I18n.translations=$.merge(I18n.translations,draw_translations);
}
else if (I18n !== undefined) {
    I18n.translations = draw_translations;
}
else {
    var I18n;
    I18n = I18n || {};
    I18n.translations = draw_translations;
}


/* 
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

var I18n = I18n || {};
I18n.translations = {'en': {
        'javascripts': {
            'map': {
                'zoom': {
                    'in': 'Zoom in',
                    'out': 'Zoom out'
                },
                'layers': {
                    'header': 'Map Layers',
                    'title': 'Layers',
                    'overlays': 'OverLays',
                    'baselayers': 'BaseLayers',
                    'notes': 'Notes',
                    'Subwatersheds': 'Subwatersheds',
                    'Watersheds': 'Watersheds',
                    'cvcsubwatersheds': 'Subwatersheds',
                    'cvcwatersheds': 'Watersheds',
                    'parks': 'Parks',
                    'conservation_areas': 'Conservation Areas',
                    'data': 'Data',
                    "Credit River Parks": "Credit River Parks",
                    'golf_courses': 'Golf Courses',
                    'peel_community_centres': 'Community Centres',
                    "Conservation": "Conservation",
                    "credit_river": "Credit River",
                    "credit_river_head_waters": "Credit River Head Waters",
                    "credit_valley_conservation": "Credit Valley Conservation",
                    "creditriverheadwaters": "Credit River Head Waters",
                    "creditvalleyprovincialpark": "Credit Valley Provincial Park",
                    "creditvalleytrails": "Credit Valley Trails",
                    "peel_golf_courses": "Peel Golf Courses",
                    "peel_parks": "Peel Parks",
                    "peel_playground_pools": "Peel Playground Pools",
                    "peel_region_trails": "Peel Region Trails",
                    "trail3_clip": "Trail Head",
                    "trails": "Trails",
                    "water_ways": "Water Ways"
                },
                'locate': {
                    'title': 'Show my location'
                }
                ,
                'share': {
                    'title': 'Share Map Information'
                },
                'key': {
                    'title': 'Show Map Legend'
                }
                ,
                'legend': {
                    'title': 'Show Map Legend'
                }
                ,
                'graphchart': {
                    'title': 'Show Graph and Chart'
                }
                ,
                'note': {
                    'title': 'Create Note'
                }
            },
            'key': {
                'title': 'Legend',
                'tooltip_disabled': 'Map Legend Disabled',
                'tooltip': 'Show Map Legend'
            },
            'business': {
                'title': 'Business',
                'tooltip_disabled': 'Business Panel Disabled',
                'tooltip': 'Show Business Panel'
            },
            'graphchart': {
                'title': 'Graph and Chart',
                'tooltip_disabled': 'Graph and Chart Disabled',
                'tooltip': 'Show Graph and Chart'
            },
            'shapefile-upload': {
                'title': 'Upload Shapefile'
            },
            'textfile-upload': {
                'title': 'Upload Text File'
            },
            'mapinfofile-upload': {
                'title': 'Upload Mapinfo File'
            },
            'kmlfile-upload': {
                'title': 'Upload KML File'
            },
            'shapefile-list': {
                'title': 'Shapefile List'
            },
            'uploadfile': {
                'title': 'Upload File'
            },
            'uploadfile-list': {
                'title': 'Upload File List'
            },
            'share': {
                'title': 'Share',
                'link': 'Link or HTML',
                'include_marker': 'include marker',
                'long_link': 'Link',
                'short_link': 'Short Link',
                'embed': 'HTML',
                'image': 'Image',
                'format': 'Format',
                'scale': 'Scale',
                'image_size': 'Image Size',
                'paste_html': 'Paste HTML',
                'custom_dimensions': 'Custom Dimensions',
                'download': 'Download'

            },
            'site': {
                'shapefile_upload_disabled_tooltip': 'Upload Shapefile Disabled',
                'shapefile_upload_tooltip': 'Upload Shapefile',
                'shapefile_list_disabled_tooltip': 'Shapefile List Disabled',
                'shapefile_list_tooltip': 'Shapefile List',
                'graphchart_disabled_tooltip': 'Graph and Chart Disabled',
                'graphchart_tooltip': 'Graph and Chart',
                'uploadfile_disabled_tooltip': 'Upload Spatial File Disabled',
                'uploadfile_tooltip': 'Upload Spatial File',
                'uploadfile_list_disabled_tooltip': 'Upload File List Disabled',
                'uploadfile_list_tooltip': 'Upload File List',
                'createnote_disabled_tooltip': 'Create Note Disabled',
                'createnote_tooltip': 'Create Note'
            }
        },
        'Reset Map Extent': 'Reset Map Extent',
        'Prev Map Extent': 'Prev Map Extent',
        'Next Map Extent': 'Next Map Extent',
        'Cancel drawing': 'Cancel drawing',
        "Cancel": "Cancel",
        "Delete last point drawn": "Delete last point drawn",
        "Delete last point": "Delete last point",
        "Draw a polyline": "Draw a polyline",
        "Draw a polygon": "Draw a polygon",
        "Draw a rectangle": "Draw a rectangle",
        "Draw a circle": "Draw a circle",
        "Draw a marker": "Draw a marker",
        "Click and drag to draw circle": "Click and drag to draw circle.",
        "Click map to place marker": "Click map to place marker.",
        "Click to start drawing shape": "Click to start drawing shape.",
        "Click to continue drawing shape": "Click to continue drawing shape.",
        "Click first point to close this shape": "Click first point to close this shape.",
        "<strong>Error:</strong> shape edges cannot cross!": "<strong>Error:</strong> shape edges cannot cross!",
        "Click to start drawing line": "Click to start drawing line.",
        "Click to continue drawing line": "Click to continue drawing line.",
        "Click last point to finish line": "Click last point to finish line.",
        "Click and drag to draw rectangle": "Click and drag to draw rectangle.",
        "Release mouse to finish drawing": "Release mouse to finish drawing.",
        "Save changes": "Save changes",
        "Save": "Save",
        "Cancel editing, discards all changes": "Cancel editing, discards all changes.",
        "Edit layers": "Edit layers",
        "No layers to edit": "No layers to edit",
        "Delete layers": "Delete layers",
        "No layers to delete": "No layers to delete.",
        "Drag handles, or marker to edit feature": "Drag handles, or marker to edit feature.",
        "Click cancel to undo changes": "Click cancel to undo changes.",
        "Click on a feature to remove": "Click on a feature to remove"
    }
};

/* 
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

var I18n = I18n || {};
I18n.translations = {'es': {
        'javascripts': {
            'map': {
                'zoom': {
                    'in': 'Zoom in',
                    'out': 'Zoom out'
                },
                'layers': {
                    'header': 'Map Layers',
                    'title': 'Layers',
                    'overlays': 'OverLays',
                    'baselayers': 'BaseLayers',
                    'notes': 'Notes',
                    'Subwatersheds': 'Subwatersheds',
                    'Watersheds': 'Watersheds',
                    'cvcsubwatersheds': 'Subwatersheds',
                    'cvcwatersheds': 'Watersheds',
                    'parks': 'Parks',
                    'conservation_areas': 'Conservation Areas',
                    'data': 'Data',
                    "Credit River Parks": "Credit River Parks",
                    'golf_courses': 'Golf Courses',
                    'peel_community_centres': 'Community Centres',
                    "Conservation": "Conservation",
                    "credit_river": "Credit River",
                    "credit_river_head_waters": "Credit River Head Waters",
                    "credit_valley_conservation": "Credit Valley Conservation",
                    "creditriverheadwaters": "Credit River Head Waters",
                    "creditvalleyprovincialpark": "Credit Valley Provincial Park",
                    "creditvalleytrails": "Credit Valley Trails",
                    "peel_golf_courses": "Peel Golf Courses",
                    "peel_parks": "Peel Parks",
                    "peel_playground_pools": "Peel Playground Pools",
                    "peel_region_trails": "Peel Region Trails",
                    "trail3_clip": "Trail Head",
                    "trails": "Trails",
                    "water_ways": "Water Ways"
                },
                'locate': {
                    'title': 'Show my location'
                }
                ,
                'share': {
                    'title': 'Share Map Information'
                },
                'key': {
                    'title': 'Show Map Legend'
                }
                ,
                'legend': {
                    'title': 'Show Map Legend'
                }
                ,
                'note': {
                    'title': 'Create Note'
                }
            },
            'key': {
                'title': 'Legend',
                'tooltip_disabled': 'Map Legend Disabled',
                'tooltip': 'Show Map Legend'
            },
            'business': {
                'title': 'negocio',
                'tooltip_disabled': 'Business Panel Disabled',
                'tooltip': 'Show Business Panel'
            },
            'shapefile-upload': {
                'title': 'Upload Shapefile'
            },
            'textfile-upload': {
                'title': 'Upload Text File'
            },
            'mapinfofile-upload': {
                'title': 'Upload Mapinfo File'
            },
            'kmlfile-upload': {
                'title': 'Upload KML File'
            },
            'shapefile-list': {
                'title': 'Shapefile List'
            },
            'uploadfile': {
                'title': 'Upload File'
            },
            'uploadfile-list': {
                'title': 'Upload File List'
            },
            'share': {
                'title': 'Share',
                'link': 'Link or HTML',
                'include_marker': 'include marker',
                'long_link': 'Link',
                'short_link': 'Short Link',
                'embed': 'HTML',
                'image': 'Image',
                'format': 'Format',
                'scale': 'Scale',
                'image_size': 'Image Size',
                'paste_html': 'Paste HTML',
                'custom_dimensions': 'Custom Dimensions',
                'download': 'Download'

            },
            'site': {
                'shapefile_upload_disabled_tooltip': 'Upload Shapefile Disabled',
                'shapefile_upload_tooltip': 'Upload Shapefile',
                'shapefile_list_disabled_tooltip': 'Shapefile List Disabled',
                'shapefile_list_tooltip': 'Shapefile List',
                'uploadfile_disabled_tooltip': 'Upload Spatial File Disabled',
                'uploadfile_tooltip': 'Upload Spatial File',
                'uploadfile_list_disabled_tooltip': 'Upload File List Disabled',
                'uploadfile_list_tooltip': 'Upload File List',
                'createnote_disabled_tooltip': 'Create Note Disabled',
                'createnote_tooltip': 'Create Note'
            }
        },
        'Reset Map Extent': 'Reiniciar Extensión de Mapa',
        'Prev Map Extent': 'Anterior Extensión de Mapa',
        'Next Map Extent': 'Siguiente Extensión de Mapa',
        'Cancel drawing': 'Cancelar dibujo',
        "Cancel": "Cancelar",
        "Delete last point drawn": "Borrar el último punto dibujado",
        "Delete last point": "Borrar el último punto",
        "Draw a polyline": "Dibuje una polilínea",
        "Draw a polygon": "Dibuja un polígono",
        "Draw a rectangle": "Dibuje un rectángulo",
        "Draw a circle": "Dibuja un círculo",
        "Draw a marker": "Dibuje un marcador",
        "Click and drag to draw circle": "Haga clic y arrastre para dibujar el círculo.",
        "Click map to place marker": "Haga clic en el mapa para colocar marcadores.",
        "Click to start drawing shape": "Haga clic para empezar a dibujar la forma.",
        "Click to continue drawing shape": "Haga clic para seguir dibujando la forma.",
        "Click first point to close this shape": "Haga clic en el primer punto para cerrar esta forma.",
        "<strong>Error:</strong> shape edges cannot cross!": "<strong>Error:</strong> dan forma a los bordes no pueden cruzar!",
        "Click to start drawing line": "Haga clic para empezar a dibujar la línea.",
        "Click to continue drawing line": "Haga clic para continuar la línea de dibujo.",
        "Click last point to finish line": "Haga clic último punto para terminar la línea.",
        "Click and drag to draw rectangle": "Haga clic y arrastre para dibujar rectángulo.",
        "Release mouse to finish drawing": "Suelte el ratón para terminar el dibujo.",
        "Save changes": "Guardar cambios",
        "Save": "Guardar",
        "Cancel editing, discards all changes": "Cancelar la edición, descarta todos los cambios",
        "Edit layers": "Editar capas.",
        "No layers to edit": "No hay capas para editar.",
        "Delete layers": "Eliminar capas",
        "No layers to delete": "No hay capas para eliminar.",
        "Drag handles, or marker to edit feature": "Control de arrastre, o marcador para editar característica.",
        "Click cancel to undo changes": "Haga clic en Cancelar para deshacer los cambios.",
        "Click on a feature to remove": "Haga clic en una función para eliminar."
    }
};

/* 
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

var I18n = I18n || {};
I18n.translations = {'zh': {
        'javascripts': {
            'map': {
                'zoom': {
                    'in': '放大',
                    'out': '缩小'
                },
                'layers': {
                    'header': '图层',
                    'title': '图层',
                    'overlays': '专题图层',
                    'baselayers': '背景图层',
                    'notes': 'Notes',
                    'Subwatersheds': 'Subwatersheds',
                    'Watersheds': 'Watersheds',
                    'cvcsubwatersheds': 'Subwatersheds',
                    'cvcwatersheds': 'Watersheds',
                    'parks': 'Parks',
                    'conservation_areas': 'Conservation Areas',
                    'data': 'Data',
                    "Credit River Parks": "Credit River Parks",
                    'golf_courses': 'Golf Courses',
                    'peel_community_centres': 'Community Centres',
                    "Conservation": "Conservation",
                    "credit_river": "Credit River",
                    "credit_river_head_waters": "Credit River Head Waters",
                    "credit_valley_conservation": "Credit Valley Conservation",
                    "creditriverheadwaters": "Credit River Head Waters",
                    "creditvalleyprovincialpark": "Credit Valley Provincial Park",
                    "creditvalleytrails": "Credit Valley Trails",
                    "peel_golf_courses": "Peel Golf Courses",
                    "peel_parks": "Peel Parks",
                    "peel_playground_pools": "Peel Playground Pools",
                    "peel_region_trails": "Peel Region Trails",
                    "trail3_clip": "Trail Head",
                    "trails": "Trails",
                    "water_ways": "Water Ways"
                },
                'locate': {
                    'title': '显示我当前位置'
                }
                ,
                'share': {
                    'title': '共享地图信息'
                },
                'key': {
                    'title': 'Show Map Legend'
                }
                ,
                'graphchart': {
                    'title': '显示图表'
                },
                'legend': {
                    'title': '显示图例'
                }
                ,
                'note': {
                    'title': 'Create Note'
                }
            },
            'key': {
                'title': 'Legend',
                'tooltip_disabled': 'Map Legend Disabled',
                'tooltip': 'Show Map Legend'
            },
            'graphchart': {
                'title': '图表',
                'tooltip_disabled': '图表信息禁用',
                'tooltip': '显示图表信息'
            },
            'shapefile-upload': {
                'title': '上载Shapefile文件'
            },
            'textfile-upload': {
                'title': '上载文本文件'
            },
            'mapinfofile-upload': {
                'title': '上载Mapinfo文件'
            },
            'kmlfile-upload': {
                'title': '上载KML文件'
            },
            'shapefile-list': {
                'title': 'Shapefile文件列表'
            },
            'uploadfile': {
                'title': '上载空间信息文件'
            },
            'uploadfile-list': {
                'title': '空间信息文件列表'
            },
            'share': {
                'title': 'Share',
                'link': 'Link or HTML',
                'include_marker': 'include marker',
                'long_link': 'Link',
                'short_link': 'Short Link',
                'embed': 'HTML',
                'image': 'Image',
                'format': 'Format',
                'scale': 'Scale',
                'image_size': 'Image Size',
                'paste_html': 'Paste HTML',
                'custom_dimensions': 'Custom Dimensions',
                'download': 'Download'

            },
            'site': {
                'shapefile_upload_disabled_tooltip': 'Upload Shapefile Disabled',
                'shapefile_upload_tooltip': 'Upload Shapefile',
                'shapefile_list_disabled_tooltip': 'Shapefile List Disabled',
                'shapefile_list_tooltip': 'Shapefile List',
                'uploadfile_disabled_tooltip': '上载空间信息文件禁用',
                'uploadfile_tooltip': '上载空间信息文件',
                'graphchart_disabled_tooltip': '图表信息禁用',
                'graphchart_tooltip': '图表信息',
                'uploadfile_list_disabled_tooltip': '空间信息文件列表禁用',
                'uploadfile_list_tooltip': '空间信息文件列表',
                'createnote_disabled_tooltip': 'Create Note Disabled',
                'createnote_tooltip': 'Create Note'
            }
        },
        'Reset Map Extent': '恢复到缺省的图幅范围',
        'Prev Map Extent': '前一次的图幅范围',
        'Next Map Extent': '前一次的图幅范围',
        'Cancel drawing': '取消当前的画图形操作.',
        "Cancel": "取消.",
        "Delete last point drawn": "删除最后所画的点.",
        "Delete last point": "删除最后一个点.",
        "Draw a polyline": "画线.",
        "Draw a polygon": "画多边形.",
        "Draw a rectangle": "画矩形.",
        "Draw a circle": "画圆.",
        "Draw a marker": "画标记.",
        "Click and drag to draw circle": "单击并拖动以画圆.",
        "Click map to place marker": "点击地图以放置标记.",
        "Click to start drawing shape": "点击开始画图形.",
        "Click to continue drawing shape": "点击继续画图形.",
        "Click first point to close this shape": "点击第一个点来关闭这个图形.",
        "<strong>Error:</strong> shape edges cannot cross!": "<strong>错误:</strong> 图形边界不能交叉!",
        "Click to start drawing line": "点击开始画线.",
        "Click to continue drawing line": "点击继续画线.",
        "Click last point to finish line": "单击最后一个点来结束画线.",
        "Click and drag to draw rectangle": "单击并拖动鼠标画矩形.",
        "Release mouse to finish drawing": "松开鼠标完成当前的操作.",
        "Save changes": "保存更改.",
        "Save": "保存.",
        "Cancel editing, discards all changes": "取消编辑，放弃所有更改.",
        "Edit layers": "编辑图层.",
        "No layers to edit": "没有图层进行编辑.",
        "Delete layers": "删除图层.",
        "No layers to delete": "没有图层删除.",
        "Drag handles, or marker to edit feature": "拖动控制点，或标记编辑功能.",
        "Click cancel to undo changes": "单击‘取消’取消修改.",
        "Click on a feature to remove": "点击要删除的图元进行删除操作."
    }
};

L.Control.MousePosition = L.Control.extend({
    options: {
        position: 'bottomleft',
        separator: ' : ',
        emptyString: 'Unavailable',
        lngFirst: false,
        numDigits: 5,
        lngFormatter: undefined,
        latFormatter: undefined,
        prefix: ""
    },
    onAdd: function(map) {
        this._container = L.DomUtil.create('div', 'leaflet-control-mouseposition');
        L.DomEvent.disableClickPropagation(this._container);
        map.on('mousemove', this._onMouseMove, this);
        this._map=map;
        this._container.innerHTML = this.options.emptyString;
        return this._container;
    },
    onRemove: function(map) {
        map.off('mousemove', this._onMouseMove)
    },
    _onMouseMove: function(e) {
        var lng = this.options.lngFormatter ? this.options.lngFormatter(e.latlng.lng) : L.Util.formatNum(e.latlng.lng, this.options.numDigits);
        var lat = this.options.latFormatter ? this.options.latFormatter(e.latlng.lat) : L.Util.formatNum(e.latlng.lat, this.options.numDigits);
        var value = this.options.lngFirst ? lng + this.options.separator + lat : lat + this.options.separator + lng;
        var prefixAndValue = this.options.prefix + ' ' + value;
        this._container.innerHTML = prefixAndValue;
    }

});

L.Map.mergeOptions({
    positionControl: false
});

L.Map.addInitHook(function() {
    if (this.options.positionControl) {
        this.positionControl = new L.Control.MousePosition();
        this.addControl(this.positionControl);
    }
});

L.control.mousePosition = function(options) {
    return new L.Control.MousePosition(options);
};

L.Control.Sidebar = L.Control.extend({
    includes: L.Mixin.Events,
    options: {
        closeButton: true,
        position: 'left',
        autoPan: true,
    },
    initialize: function(placeholder, options) {
        L.setOptions(this, options);

        this._control = {};
        this._sidebar = $(placeholder);
        this._current = $();
        this._currentButton = $();
   
        // Find content container
        var content = this._contentContainer = L.DomUtil.get(placeholder);

        // Remove the content container from its original parent
    
        
        content.parentNode.removeChild(content);
 
        var l = 'leaflet-';

        // Create sidebar container
        var container = this._container =
                L.DomUtil.create('div', l + 'sidebar ' + this.options.position);

        // Style and attach content container
        L.DomUtil.addClass(content, l + 'control');
        
        
        
        container.appendChild(content);
        
 
        // Create close button and attach it if configured
        if (this.options.closeButton) {
            var close = this._closeButton =
                    L.DomUtil.create('a', 'close', container);
            close.innerHTML = '&times;';
        }
    },
    addTo: function(map) {
        
        
        var container = this._container;
        var content = this._contentContainer;
        // Attach event to close button
        if (this.options.closeButton) {
            var close = this._closeButton;

            L.DomEvent.on(close, 'click', this.hide, this);
        }
        // Attach sidebar container to controls container
        var controlContainer = map._controlContainer;
       controlContainer.insertBefore(container, controlContainer.firstChild);
 
        this._map = map;
       // Make sure we don't drag the map when we interact with the content
        var stop = L.DomEvent.stopPropagation;
        L.DomEvent
                .on(content, 'click', stop)
                .on(content, 'mousedown', stop)
                .on(content, 'touchstart', stop)
                .on(content, 'dblclick', stop)
                .on(content, 'mousewheel', stop)
                .on(content, 'MozMousePixelScroll', stop);
        return this;
    },
    addPane: function(pane) {
        pane
         .hide()
         .appendTo(this._contentContainer);

    },
    removeFrom: function(map) {
        //if the control is visible, hide it before removing it.
        this.hide();

        var content = this._contentContainer;

        // Remove sidebar container from controls container
        var controlContainer = map._controlContainer;
        controlContainer.removeChild(this._container);

        //disassociate the map object
        this._map = null;

        // Unregister events to prevent memory leak
        var stop = L.DomEvent.stopPropagation;
        L.DomEvent
                .off(content, 'click', stop)
                .off(content, 'mousedown', stop)
                .off(content, 'touchstart', stop)
                .off(content, 'dblclick', stop)
                .off(content, 'mousewheel', stop)
                .off(content, 'MozMousePixelScroll', stop);

        if (this._closeButton && this._close) {
            var close = this._closeButton;

            L.DomEvent.off(close, 'click', this.hide, this);
        }

        return this;
    },
    isVisible: function() {
        return L.DomUtil.hasClass(this._container, 'visible');
    },
    show: function() {
        if (!this.isVisible()) {
            L.DomUtil.addClass(this._container, 'visible');
            if (this.options.autoPan) {
                this._map.panBy([-this.getOffset() / 2, 0], {
                    duration: 0.5
                });
            }
            this.fire('show');
        }
    },
    hide: function(e) {
        if (this.isVisible()) {
            L.DomUtil.removeClass(this._container, 'visible');
            if (this.options.autoPan) {
                this._map.panBy([this.getOffset() / 2, 0], {
                    duration: 0.5
                });
            }
            this.fire('hide');
           
            this._current
                    .hide()
                    .trigger('hide');
            this._currentButton
                    .removeClass('active');
            this._current = this._currentButton = $();
            
        }
        if (e) {
            L.DomEvent.stopPropagation(e);
        }
    },
    toggle: function() {
        if (this.isVisible()) {
            this.hide();
           

        } else {
            this.show();
        }
    },
    togglePane: function(pane, button) {

        this._current
                .hide()
                .trigger('hide');

        this._currentButton
                .removeClass('active');

        if (this._current === pane) {
            
            this.hide();
            $(this._sidebar).hide();
            
            this._current = this._currentButton = $();
        } else {
            $(this._sidebar).show();
            this.show();
            this._current = pane;
            this._currentButton = button || $();
        }

        //   map.invalidateSize({pan: false, animate: false});

        this._current
                .show()
                .trigger('show');

        this._currentButton
                .addClass('active');


    },
//  control.togglePane: function(pane, button) {
//    current
//      .hide()
//      .trigger('hide');
//
//    currentButton
//      .removeClass('active');
//
//    if (current === pane) {
//      $(sidebar).hide();
//      current = currentButton = $();
//    } else {
//      $(sidebar).show();
//      current = pane;
//      currentButton = button || $();
//    }
//
//    map.invalidateSize({pan: false, animate: false});
//
//    current
//      .show()
//      .trigger('show');
//
//    currentButton
//      .addClass('active');
//    };
//
//        return control;
//    };
    getContainer: function() {
        return this._contentContainer;
    },
    getCloseButton: function() {
        return this._closeButton;
    },
    setContent: function(content) {
        this.getContainer().innerHTML = content;
        return this;
    },
    getOffset: function() {
        if (this.options.position === 'right') {
            return -this._container.offsetWidth;
        } else {
            return this._container.offsetWidth;
        }
    }
});

L.control.sidebar = function(placeholder, options) {
    return new L.Control.Sidebar(placeholder, options);
};

/*
    The MIT License

    Copyright (c) 2011 Mike Chambers

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    THE SOFTWARE.
*/

/*
From https://github.com/jsmarkus/ExamplesByMesh/tree/master/JavaScript/QuadTree, slightly modified by domoritz
*/


/**
* A QuadTree implementation in JavaScript, a 2d spatial subdivision algorithm.
* @module QuadTree
**/

(function(window) {

/****************** QuadTree ****************/

/**
* QuadTree data structure.
* @class QuadTree
* @constructor
* @param {Object} An object representing the bounds of the top level of the QuadTree. The object
* should contain the following properties : x, y, width, height
* @param {Boolean} pointQuad Whether the QuadTree will contain points (true), or items with bounds
* (width / height)(false). Default value is false.
* @param {Number} maxDepth The maximum number of levels that the quadtree will create. Default is 4.
* @param {Number} maxChildren The maximum number of children that a node can contain before it is split into sub-nodes.
**/
function QuadTree(bounds, pointQuad, maxDepth, maxChildren)
{
    var node;
    if(pointQuad)
    {

        node = new Node(bounds, 0, maxDepth, maxChildren);
    }
    else
    {
        node = new BoundsNode(bounds, 0, maxDepth, maxChildren);
    }

    this.root = node;
}

/**
* The root node of the QuadTree which covers the entire area being segmented.
* @property root
* @type Node
**/
QuadTree.prototype.root = null;


/**
* Inserts an item into the QuadTree.
* @method insert
* @param {Object|Array} item The item or Array of items to be inserted into the QuadTree. The item should expose x, y
* properties that represents its position in 2D space.
**/
QuadTree.prototype.insert = function(item)
{
    if(item instanceof Array)
    {
        var len = item.length;

        for(var i = 0; i < len; i++)
        {
            this.root.insert(item[i]);
        }
    }
    else
    {
        this.root.insert(item);
    }
};

/**
* Clears all nodes and children from the QuadTree
* @method clear
**/
QuadTree.prototype.clear = function()
{
    this.root.clear();
};

/**
* Retrieves all items / points in the same node as the specified item / point. If the specified item
* overlaps the bounds of a node, then all children in both nodes will be returned.
* @method retrieve
* @param {Object} item An object representing a 2D coordinate point (with x, y properties), or a shape
* with dimensions (x, y, width, height) properties.
**/
QuadTree.prototype.retrieve = function(item)
{
    //get a copy of the array of items
    var out = this.root.retrieve(item).slice(0);
    //return QuadTree._filterResults(out, {x:item.x, y:item.y, width:0, height:0});
    return out;
};

QuadTree.prototype.retrieveInBounds = function (bounds)
{
    var treeResult = this.root.retrieveInBounds(bounds);
    return QuadTree._filterResults(treeResult, bounds);
};

QuadTree._filterResults = function(treeResult, bounds)
{
    var filteredResult = [];

    if(this.root instanceof BoundsNode)
    {
        for (var i=0; i < treeResult.length; i++)
        {
            var node = treeResult[i];
            if (QuadTree._isBoundOverlappingBound(node, bounds))
            {
                filteredResult.push(node);
            }
        }
    }
    else
    {
        treeResult.forEach(function(node){
            if(QuadTree._isPointInsideBounds(node, bounds))
            {
                filteredResult.push(node);
            }
        });
    }

    return filteredResult;
};

QuadTree._isPointInsideBounds = function (point, bounds)
{
    return (
        (point.x >= bounds.x) &&
        (point.x <= bounds.x + bounds.width) &&
        (point.y >= bounds.y) &&
        (point.y <= bounds.y + bounds.height)
    );
};


QuadTree._isBoundOverlappingBound = function (b1, b2)
{
    return !(
            b1.x > (b2.x + b2.width)  ||
            b2.x > (b1.x + b1.width)  ||
            b1.y > (b2.y + b2.height) ||
            b2.y > (b1.y + b1.height)
       );
};

/************** Node ********************/


function Node(bounds, depth, maxDepth, maxChildren)
{
    this._bounds = bounds;
    this.children = [];
    this.nodes = [];

    if(maxChildren)
    {
        this._maxChildren = maxChildren;

    }

    if(maxDepth)
    {
        this._maxDepth = maxDepth;
    }

    if(depth)
    {
        this._depth = depth;
    }
};

//subnodes
Node.prototype.nodes = null;
Node.prototype._classConstructor = Node;

//children contained directly in the node
Node.prototype.children = null;
Node.prototype._bounds = null;

//read only
Node.prototype._depth = 0;

Node.prototype._maxChildren = 4;
Node.prototype._maxDepth = 4;

Node.TOP_LEFT = 0;
Node.TOP_RIGHT = 1;
Node.BOTTOM_LEFT = 2;
Node.BOTTOM_RIGHT = 3;


Node.prototype.insert = function(item)
{
    if(this.nodes.length)
    {
        var index = this._findIndex(item);

        this.nodes[index].insert(item);

        return;
    }

    this.children.push(item);

    var len = this.children.length;
    if(!(this._depth >= this._maxDepth) &&
        len > this._maxChildren)
    {
        this.subdivide();

        for(var i = 0; i < len; i++)
        {
            this.insert(this.children[i]);
        }

        this.children.length = 0;
    }
};

Node.prototype.retrieve = function(item)
{
    if(this.nodes.length)
    {
        var index = this._findIndex(item);

        return this.nodes[index].retrieve(item);
    }

    return this.children;
};

Node.prototype.retrieveInBounds = function(bounds)
{
    var result = [];

    if(this.collidesWith(bounds))
    {
        result = result.concat(this._stuckChildren);

        if(this.children.length)
        {
            result = result.concat(this.children);
        }
        else
        {
            if(this.nodes.length)
            {
                for (var i = 0; i < this.nodes.length; i++)
                {
                    result = result.concat(this.nodes[i].retrieveInBounds(bounds));
                }
            }
        }
    }

    return result;
};


Node.prototype.collidesWith = function (bounds)
{
    var b1 = this._bounds;
    var b2 = bounds;

    return !(
            b1.x > (b2.x + b2.width)  ||
            b2.x > (b1.x + b1.width)  ||
            b1.y > (b2.y + b2.height) ||
            b2.y > (b1.y + b1.height)
       );
};

Node.prototype._findIndex = function(item)
{
    var b = this._bounds;
    var left = (item.x > b.x + b.width / 2)? false : true;
    var top = (item.y > b.y + b.height / 2)? false : true;

    //top left
    var index = Node.TOP_LEFT;
    if(left)
    {
        //left side
        if(!top)
        {
            //bottom left
            index = Node.BOTTOM_LEFT;
        }
    }
    else
    {
        //right side
        if(top)
        {
            //top right
            index = Node.TOP_RIGHT;
        }
        else
        {
            //bottom right
            index = Node.BOTTOM_RIGHT;
        }
    }

    return index;
};


Node.prototype.subdivide = function()
{
    var depth = this._depth + 1;

    var bx = this._bounds.x;
    var by = this._bounds.y;

    //floor the values
    var b_w_h = (this._bounds.width / 2)|0;
    var b_h_h = (this._bounds.height / 2)|0;
    var bx_b_w_h = bx + b_w_h;
    var by_b_h_h = by + b_h_h;

    //top left
    this.nodes[Node.TOP_LEFT] = new this._classConstructor({
        x:bx,
        y:by,
        width:b_w_h,
        height:b_h_h
    },
    depth, this._maxDepth, this._maxChildren);

    //top right
    this.nodes[Node.TOP_RIGHT] = new this._classConstructor({
        x:bx_b_w_h,
        y:by,
        width:b_w_h,
        height:b_h_h
    },
    depth, this._maxDepth, this._maxChildren);

    //bottom left
    this.nodes[Node.BOTTOM_LEFT] = new this._classConstructor({
        x:bx,
        y:by_b_h_h,
        width:b_w_h,
        height:b_h_h
    },
    depth, this._maxDepth, this._maxChildren);


    //bottom right
    this.nodes[Node.BOTTOM_RIGHT] = new this._classConstructor({
        x:bx_b_w_h,
        y:by_b_h_h,
        width:b_w_h,
        height:b_h_h
    },
    depth, this._maxDepth, this._maxChildren);
};

Node.prototype.clear = function()
{
    this.children.length = 0;

    var len = this.nodes.length;
    for(var i = 0; i < len; i++)
    {
        this.nodes[i].clear();
    }

    this.nodes.length = 0;
};


/******************** BoundsQuadTree ****************/

function BoundsNode(bounds, depth, maxChildren, maxDepth)
{
    Node.call(this, bounds, depth, maxChildren, maxDepth);
    this._stuckChildren = [];
}

BoundsNode.prototype = new Node();
BoundsNode.prototype._classConstructor = BoundsNode;
BoundsNode.prototype._stuckChildren = null;

//we use this to collect and conctenate items being retrieved. This way
//we dont have to continuously create new Array instances.
//Note, when returned from QuadTree.retrieve, we then copy the array
BoundsNode.prototype._out = [];

BoundsNode.prototype.insert = function(item)
{
    if(this.nodes.length)
    {
        var index = this._findIndex(item);
        var node = this.nodes[index];

        //todo: make _bounds bounds
        if(item.x >= node._bounds.x &&
            item.x + item.width <= node._bounds.x + node._bounds.width &&
            item.y >= node._bounds.y &&
            item.y + item.height <= node._bounds.y + node._bounds.height)
        {
            this.nodes[index].insert(item);
        }
        else
        {
            this._stuckChildren.push(item);
        }

        return;
    }

    this.children.push(item);

    var len = this.children.length;

    if(this._depth < this._maxDepth &&
        len > this._maxChildren)
    {
        this.subdivide();

        for(var i = 0; i < len; i++)
        {
            this.insert(this.children[i]);
        }

        this.children.length = 0;
    }
};

BoundsNode.prototype.getChildren = function()
{
    return this.children.concat(this._stuckChildren);
};

BoundsNode.prototype.retrieve = function(item)
{
    var out = this._out;
    out.length = 0;
    if(this.nodes.length)
    {
        var index = this._findIndex(item);

        out.push.apply(out, this.nodes[index].retrieve(item));
    }

    out.push.apply(out, this._stuckChildren);
    out.push.apply(out, this.children);

    return out;
};

BoundsNode.prototype.clear = function()
{

    this._stuckChildren.length = 0;

    //array
    this.children.length = 0;

    var len = this.nodes.length;

    if(!len)
    {
        return;
    }

    for(var i = 0; i < len; i++)
    {
        this.nodes[i].clear();
    }

    //array
    this.nodes.length = 0;

    //we could call the super clear function but for now, im just going to inline it
    //call the hidden super.clear, and make sure its called with this = this instance
    //Object.getPrototypeOf(BoundsNode.prototype).clear.call(this);
};

//BoundsNode.prototype.getChildCount

window.QuadTree = QuadTree;

/*
//http://ejohn.org/blog/objectgetprototypeof/
if ( typeof Object.getPrototypeOf !== "function" ) {
  if ( typeof "test".__proto__ === "object" ) {
    Object.getPrototypeOf = function(object){
      return object.__proto__;
    };
  } else {
    Object.getPrototypeOf = function(object){
      // May break if the constructor has been tampered with
      return object.constructor.prototype;
    };
  }
}
*/

}(this));
/* 
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


function ShapefileMapPreview() {
    if(map === undefined)
        return;
    
}
L.TileLayer.Bing = L.TileLayer.extend({
  
  supportedTypes: ['Road', 'Aerial', 'AerialWithLabels'],
  
  attributionTemplate: '<span style="display:inline-block">' +
       '<a target="_blank" href="http://www.onterrasystems.com">' +
       '</a></span></span>',
  
  initialize: function(/*String*/ apiKey, /*String*/ mapType, /*Object*/ options) {
    
    this._apiKey = apiKey;
    this._mapType = mapType;
    
    this._loadMetadata();
    
    L.Util.setOptions(this, options);
  },
  
  _loadMetadata: function() {
    
    this._callbackId = "_l_tilelayer_bing_" + (L.TileLayer.Bing._callbackId++);
    window[this._callbackId] = L.Util.bind(L.TileLayer.Bing.processMetadata, this);
    
    var params = {
      key: this._apiKey,
      jsonp: this._callbackId,
      include: 'ImageryProviders'
    },
        url = "http://dev.virtualearth.net/REST/v1/Imagery/Metadata/" +
              this._mapType + L.Util.getParamString(params),
        script = document.createElement("script");
        
    script.type = "text/javascript";
    script.src = url;
    script.id = this._callbackId;
    document.getElementsByTagName("head")[0].appendChild(script);
  },
  
  _onMetadataLoaded: function() {},
  
  onAdd: function(map, insertAtTheBottom) {
    if (!this.metadata) {
      this._onMetadataLoaded = L.Util.bind(function() {
        L.TileLayer.prototype.onAdd.call(this, map, insertAtTheBottom);
        map.on('moveend', this._updateAttribution, this);
        this._updateAttribution();
      }, this);
    } else {
      L.TileLayer.prototype.onAdd.call(this, map, insertAtTheBottom);
      map.on('moveend', this._updateAttribution, this);
      this._updateAttribution();
    }
  },
  
  onRemove: function(map) {
    if (this._map.attributionControl) {
      this._map.attributionControl.removeAttribution(this.attribution);
    }
    this._map.off('moveend', this._updateAttribution, this);
    L.TileLayer.prototype.onRemove.call(this, map);
  },
  
  getTileUrl: function(xy, z) {
    var subdomains = this.options.subdomains,
			  quadDigits = [],
			  i = z,
			  digit,
			  mask,
			  quadKey;
		// borrowed directly from OpenLayers
    for (; i > 0; --i) {
        digit = '0';
        mask = 1 << (i - 1);
        if ((xy.x & mask) != 0) {
            digit++;
        }
        if ((xy.y & mask) != 0) {
            digit++;
            digit++;
        }
        quadDigits.push(digit);
    }

		return this._url
				.replace('{subdomain}', subdomains[(xy.x + xy.y) % subdomains.length])
				.replace('{quadkey}', quadDigits.join(""));		
  },
  
  _updateAttribution: function() {
    if (this._map.attributionControl) {
      var metadata = this.metadata;
      var res = metadata.resourceSets[0].resources[0];
      var bounds = this._map.getBounds();
      var providers = res.imageryProviders, zoom = this._map.getZoom() + 1,
          copyrights = "", provider, i, ii, j, jj, bbox, coverage;
      for (i=0,ii=providers.length; i<ii; ++i) {
          provider = providers[i];
          for (j=0,jj=provider.coverageAreas.length; j<jj; ++j) {
              coverage = provider.coverageAreas[j];
              //if (zoom <= coverage.zoomMax && zoom >= coverage.zoomMin && coverage.bbox.intersects(bounds)) {
              if (zoom <= coverage.zoomMax && zoom >= coverage.zoomMin ) {
                  copyrights += provider.attribution + " ";
                  j = jj;
              }
          }
      }
      this._map.attributionControl.removeAttribution(this.attribution);
      this.attribution = this.attributionTemplate
        .replace('{logo}', 'leaflet/images/OnTerra_FL_RGB_smaller.png')
        .replace('{copyrights}', copyrights);
      this._map.attributionControl.addAttribution(this.attribution);
    }
  }    
});

L.TileLayer.Bing._callbackId = 0;

L.TileLayer.Bing.processMetadata = function(metadata) {
  if (metadata.authenticationResultCode != 'ValidCredentials') {
    throw "Invalid Bing Maps API Key"
  }
  
  if (!metadata.resourceSets.length || !metadata.resourceSets[0].resources.length) {
    throw "No resources returned, perhaps " + this._mapType + " is an invalid map type?";
  }
  
  if (metadata.statusCode != 200) {
    throw "Bing Maps API request failed with status code " + metadata.statusCode;
  }
  
  this.metadata = metadata;
  var res = metadata.resourceSets[0].resources[0],
      providers = res.imageryProviders,
      i = 0,
      j,
      provider,
      bbox,
      script = document.getElementById(this._callbackId);
  
  for (; i<providers.length; i++) {
    provider = providers[i];
    for (j=0; j<provider.coverageAreas.length; j++) {
      bbox = provider.coverageAreas[j].bbox;
      provider.coverageAreas[j].bbox = new L.LatLngBounds(new L.LatLng(bbox[0],bbox[1],true),new L.LatLng(bbox[2],bbox[3], true));
    }
  }
  
  this._url = res.imageUrl.replace('{culture}','en-US');
  this.options.subdomains = [].concat(res.imageUrlSubdomains);
  script.parentNode.removeChild(script);
  window[this._callbackId] = undefined; // cannot delete from window in IE
  delete this._callbackId;
  this._onMetadataLoaded();
}
//= require jquery
//= require jquery_ujs
//= require jquery.timers
//= require jquery.cookie
//= require jquery.throttle-debounce
//= require bootstrap.tooltip
//= require bootstrap.dropdown
//= require augment
//= require osm
//= require leaflet
//= require leaflet.osm
//= require leaflet.map
//= require leaflet.zoom
//= require leaflet.locationfilter
//= require i18n/translations
//= require oauth
//= require piwik
//= require richtext
//= require querystring

var querystring = require('querystring-component');

function remoteEditHandler(bbox, object) {
  var loaded = false,
      query = {
          left: bbox.getWest() - 0.0001,
          top: bbox.getNorth() + 0.0001,
          right: bbox.getEast() + 0.0001,
          bottom: bbox.getSouth() - 0.0001
      };

  if (object) query.select = object.type + object.id;

  var iframe = $('<iframe>')
    .hide()
    .appendTo('body')
    .attr("src", "http://127.0.0.1:8111/load_and_zoom?" + querystring.stringify(query))
    .on('load', function() {
      $(this).remove();
      loaded = true;
    });

  setTimeout(function () {
    if (!loaded) {
      alert(I18n.t('site.index.remote_failed'));
      iframe.remove();
    }
  }, 1000);

  return false;
}

/*
 * Called as the user scrolls/zooms around to maniplate hrefs of the
 * view tab and various other links
 */
function updateLinks(loc, zoom, layers, object) {
  $(".geolink").each(function(index, link) {
    var href = link.href.split(/[?#]/)[0],
      args = querystring.parse(link.search.substring(1)),
      editlink = $(link).hasClass("editlink");

    delete args['node'];
    delete args['way'];
    delete args['relation'];
    delete args['changeset'];

    if (object && editlink) {
      args[object.type] = object.id;
    }

    var query = querystring.stringify(args);
    if (query) href += '?' + query;

    args = {
      lat: loc.lat,
      lon: 'lon' in loc ? loc.lon : loc.lng,
      zoom: zoom
    };

    if (layers && !editlink) {
      args.layers = layers;
    }

    href += OSM.formatHash(args);

    link.href = href;
  });

  var editDisabled = zoom < 13;
  $('#edit_tab')
    .tooltip({placement: 'bottom'})
    .off('click.minzoom')
    .on('click.minzoom', function() { return !editDisabled; })
    .toggleClass('disabled', editDisabled)
    .attr('data-original-title', editDisabled ?
      I18n.t('javascripts.site.edit_disabled_tooltip') : '');
}

function escapeHTML(string) {
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;'
  };
  return string == null ? '' : (string + '').replace(/[&<>"']/g, function(match) {
      return htmlEscapes[match];
  });
}

function maximiseMap() {
  $("#content").addClass("maximised");
}

function minimiseMap() {
  $("#content").removeClass("maximised");
}

$(document).ready(function () {
  $("#menu-icon").on("click", function(e) {
    e.preventDefault();
    $("header").toggleClass("closed");
  });

  $("nav.primary li a").on("click", function() {
    $("header").toggleClass("closed");
  });
});

/* ============================================================
 * bootstrap-dropdown.js v2.3.2
 * http://getbootstrap.com/2.3.2/javascript.html#dropdowns
 * ============================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ============================================================ */


!function ($) {

  "use strict"; // jshint ;_;


 /* DROPDOWN CLASS DEFINITION
  * ========================= */

  var toggle = '[data-toggle=dropdown]'
    , Dropdown = function (element) {
        var $el = $(element).on('click.dropdown.data-api', this.toggle)
        $('html').on('click.dropdown.data-api', function () {
          $el.parent().removeClass('open')
        })
      }

  Dropdown.prototype = {

    constructor: Dropdown

  , toggle: function (e) {
      var $this = $(this)
        , $parent
        , isActive

      if ($this.is('.disabled, :disabled')) return

      $parent = getParent($this)

      isActive = $parent.hasClass('open')

      clearMenus()

      if (!isActive) {
        if ('ontouchstart' in document.documentElement) {
          // if mobile we we use a backdrop because click events don't delegate
          $('<div class="dropdown-backdrop"/>').insertBefore($(this)).on('click', clearMenus)
        }
        $parent.toggleClass('open')
      }

      $this.focus()

      return false
    }

  , keydown: function (e) {
      var $this
        , $items
        , $active
        , $parent
        , isActive
        , index

      if (!/(38|40|27)/.test(e.keyCode)) return

      $this = $(this)

      e.preventDefault()
      e.stopPropagation()

      if ($this.is('.disabled, :disabled')) return

      $parent = getParent($this)

      isActive = $parent.hasClass('open')

      if (!isActive || (isActive && e.keyCode == 27)) {
        if (e.which == 27) $parent.find(toggle).focus()
        return $this.click()
      }

      $items = $('[role=menu] li:not(.divider):visible a', $parent)

      if (!$items.length) return

      index = $items.index($items.filter(':focus'))

      if (e.keyCode == 38 && index > 0) index--                                        // up
      if (e.keyCode == 40 && index < $items.length - 1) index++                        // down
      if (!~index) index = 0

      $items
        .eq(index)
        .focus()
    }

  }

  function clearMenus() {
    $('.dropdown-backdrop').remove()
    $(toggle).each(function () {
      getParent($(this)).removeClass('open')
    })
  }

  function getParent($this) {
    var selector = $this.attr('data-target')
      , $parent

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && /#/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '') //strip for ie7
    }

    $parent = selector && $(selector)

    if (!$parent || !$parent.length) $parent = $this.parent()

    return $parent
  }


  /* DROPDOWN PLUGIN DEFINITION
   * ========================== */

  var old = $.fn.dropdown

  $.fn.dropdown = function (option) {
    return this.each(function () {
      var $this = $(this)
        , data = $this.data('dropdown')
      if (!data) $this.data('dropdown', (data = new Dropdown(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }

  $.fn.dropdown.Constructor = Dropdown


 /* DROPDOWN NO CONFLICT
  * ==================== */

  $.fn.dropdown.noConflict = function () {
    $.fn.dropdown = old
    return this
  }


  /* APPLY TO STANDARD DROPDOWN ELEMENTS
   * =================================== */

  $(document)
    .on('click.dropdown.data-api', clearMenus)
    .on('click.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })
    .on('click.dropdown.data-api'  , toggle, Dropdown.prototype.toggle)
    .on('keydown.dropdown.data-api', toggle + ', [role=menu]' , Dropdown.prototype.keydown)

}(window.jQuery);

/* ===========================================================
 * bootstrap-tooltip.js v2.3.2
 * http://getbootstrap.com/2.3.2/javascript.html#tooltips
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ===========================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */


!function ($) {

  "use strict"; // jshint ;_;


 /* TOOLTIP PUBLIC CLASS DEFINITION
  * =============================== */

  var Tooltip = function (element, options) {
    this.init('tooltip', element, options)
  }

  Tooltip.prototype = {

    constructor: Tooltip

  , init: function (type, element, options) {
      var eventIn
        , eventOut
        , triggers
        , trigger
        , i

      this.type = type
      this.$element = $(element)
      this.options = this.getOptions(options)
      this.enabled = true

      triggers = this.options.trigger.split(' ')

      for (i = triggers.length; i--;) {
        trigger = triggers[i]
        if (trigger == 'click') {
          this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
        } else if (trigger != 'manual') {
          eventIn = trigger == 'hover' ? 'mouseenter' : 'focus'
          eventOut = trigger == 'hover' ? 'mouseleave' : 'blur'
          this.$element.on(eventIn + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
          this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
        }
      }

      this.options.selector ?
        (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
        this.fixTitle()
    }

  , getOptions: function (options) {
      options = $.extend({}, $.fn[this.type].defaults, this.$element.data(), options)

      if (options.delay && typeof options.delay == 'number') {
        options.delay = {
          show: options.delay
        , hide: options.delay
        }
      }

      return options
    }

  , enter: function (e) {
      var defaults = $.fn[this.type].defaults
        , options = {}
        , self

      this._options && $.each(this._options, function (key, value) {
        if (defaults[key] != value) options[key] = value
      }, this)

      self = $(e.currentTarget)[this.type](options).data(this.type)

      if (!self.options.delay || !self.options.delay.show) return self.show()

      clearTimeout(this.timeout)
      self.hoverState = 'in'
      this.timeout = setTimeout(function() {
        if (self.hoverState == 'in') self.show()
      }, self.options.delay.show)
    }

  , leave: function (e) {
      var self = $(e.currentTarget)[this.type](this._options).data(this.type)

      if (this.timeout) clearTimeout(this.timeout)
      if (!self.options.delay || !self.options.delay.hide) return self.hide()

      self.hoverState = 'out'
      this.timeout = setTimeout(function() {
        if (self.hoverState == 'out') self.hide()
      }, self.options.delay.hide)
    }

  , show: function () {
      var $tip
        , pos
        , actualWidth
        , actualHeight
        , placement
        , tp
        , e = $.Event('show')

      if (this.hasContent() && this.enabled) {
        this.$element.trigger(e)
        if (e.isDefaultPrevented()) return
        $tip = this.tip()
        this.setContent()

        if (this.options.animation) {
          $tip.addClass('fade')
        }

        placement = typeof this.options.placement == 'function' ?
          this.options.placement.call(this, $tip[0], this.$element[0]) :
          this.options.placement

        $tip
          .detach()
          .css({ top: 0, left: 0, display: 'block' })

        this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)

        pos = this.getPosition()

        actualWidth = $tip[0].offsetWidth
        actualHeight = $tip[0].offsetHeight

        switch (placement) {
          case 'bottom':
            tp = {top: pos.top + pos.height, left: pos.left + pos.width / 2 - actualWidth / 2}
            break
          case 'top':
            tp = {top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2}
            break
          case 'left':
            tp = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth}
            break
          case 'right':
            tp = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width}
            break
        }

        this.applyPlacement(tp, placement)
        this.$element.trigger('shown')
      }
    }

  , applyPlacement: function(offset, placement){
      var $tip = this.tip()
        , width = $tip[0].offsetWidth
        , height = $tip[0].offsetHeight
        , actualWidth
        , actualHeight
        , delta
        , replace

      $tip
        .offset(offset)
        .addClass(placement)
        .addClass('in')

      actualWidth = $tip[0].offsetWidth
      actualHeight = $tip[0].offsetHeight

      if (placement == 'top' && actualHeight != height) {
        offset.top = offset.top + height - actualHeight
        replace = true
      }

      if (placement == 'bottom' || placement == 'top') {
        delta = 0

        if (offset.left < 0){
          delta = offset.left * -2
          offset.left = 0
          $tip.offset(offset)
          actualWidth = $tip[0].offsetWidth
          actualHeight = $tip[0].offsetHeight
        }

        this.replaceArrow(delta - width + actualWidth, actualWidth, 'left')
      } else {
        this.replaceArrow(actualHeight - height, actualHeight, 'top')
      }

      if (replace) $tip.offset(offset)
    }

  , replaceArrow: function(delta, dimension, position){
      this
        .arrow()
        .css(position, delta ? (50 * (1 - delta / dimension) + "%") : '')
    }

  , setContent: function () {
      var $tip = this.tip()
        , title = this.getTitle()

      $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
      $tip.removeClass('fade in top bottom left right')
    }

  , hide: function () {
      var that = this
        , $tip = this.tip()
        , e = $.Event('hide')

      this.$element.trigger(e)
      if (e.isDefaultPrevented()) return

      $tip.removeClass('in')

      function removeWithAnimation() {
        var timeout = setTimeout(function () {
          $tip.off($.support.transition.end).detach()
        }, 500)

        $tip.one($.support.transition.end, function () {
          clearTimeout(timeout)
          $tip.detach()
        })
      }

      $.support.transition && this.$tip.hasClass('fade') ?
        removeWithAnimation() :
        $tip.detach()

      this.$element.trigger('hidden')

      return this
    }

  , fixTitle: function () {
      var $e = this.$element
      if ($e.attr('title') || typeof($e.attr('data-original-title')) != 'string') {
        $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
      }
    }

  , hasContent: function () {
      return this.getTitle()
    }

  , getPosition: function () {
      var el = this.$element[0]
      return $.extend({}, (typeof el.getBoundingClientRect == 'function') ? el.getBoundingClientRect() : {
        width: el.offsetWidth
      , height: el.offsetHeight
      }, this.$element.offset())
    }

  , getTitle: function () {
      var title
        , $e = this.$element
        , o = this.options

      title = $e.attr('data-original-title')
        || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)

      return title
    }

  , tip: function () {
      return this.$tip = this.$tip || $(this.options.template)
    }

  , arrow: function(){
      return this.$arrow = this.$arrow || this.tip().find(".tooltip-arrow")
    }

  , validate: function () {
      if (!this.$element[0].parentNode) {
        this.hide()
        this.$element = null
        this.options = null
      }
    }

  , enable: function () {
      this.enabled = true
    }

  , disable: function () {
      this.enabled = false
    }

  , toggleEnabled: function () {
      this.enabled = !this.enabled
    }

  , toggle: function (e) {
      var self = e ? $(e.currentTarget)[this.type](this._options).data(this.type) : this
      self.tip().hasClass('in') ? self.hide() : self.show()
    }

  , destroy: function () {
      this.hide().$element.off('.' + this.type).removeData(this.type)
    }

  }


 /* TOOLTIP PLUGIN DEFINITION
  * ========================= */

  var old = $.fn.tooltip

  $.fn.tooltip = function ( option ) {
    return this.each(function () {
      var $this = $(this)
        , data = $this.data('tooltip')
        , options = typeof option == 'object' && option
      if (!data) $this.data('tooltip', (data = new Tooltip(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  $.fn.tooltip.Constructor = Tooltip

  $.fn.tooltip.defaults = {
    animation: true
  , placement: 'top'
  , selector: false
  , template: '<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>'
  , trigger: 'hover focus'
  , title: ''
  , delay: 0
  , html: false
  , container: false
  }


 /* TOOLTIP NO CONFLICT
  * =================== */

  $.fn.tooltip.noConflict = function () {
    $.fn.tooltip = old
    return this
  }

}(window.jQuery);

(function(){d3.csv = function(url, callback) {
  d3.text(url, "text/csv", function(text) {
    callback(text && d3.csv.parse(text));
  });
};
d3.csv.parse = function(text) {
  var header;
  return d3.csv.parseRows(text, function(row, i) {
    if (i) {
      var o = {}, j = -1, m = header.length;
      while (++j < m) o[header[j]] = row[j];
      return o;
    } else {
      header = row;
      return null;
    }
  });
};

d3.csv.parseRows = function(text, f) {
  var EOL = {}, // sentinel value for end-of-line
      EOF = {}, // sentinel value for end-of-file
      rows = [], // output rows
      re = /\r\n|[,\r\n]/g, // field separator regex
      n = 0, // the current line number
      t, // the current token
      eol; // is the current token followed by EOL?

  re.lastIndex = 0; // work-around bug in FF 3.6

  /** @private Returns the next token. */
  function token() {
    if (re.lastIndex >= text.length) return EOF; // special case: end of file
    if (eol) { eol = false; return EOL; } // special case: end of line

    // special case: quotes
    var j = re.lastIndex;
    if (text.charCodeAt(j) === 34) {
      var i = j;
      while (i++ < text.length) {
        if (text.charCodeAt(i) === 34) {
          if (text.charCodeAt(i + 1) !== 34) break;
          i++;
        }
      }
      re.lastIndex = i + 2;
      var c = text.charCodeAt(i + 1);
      if (c === 13) {
        eol = true;
        if (text.charCodeAt(i + 2) === 10) re.lastIndex++;
      } else if (c === 10) {
        eol = true;
      }
      return text.substring(j + 1, i).replace(/""/g, "\"");
    }

    // common case
    var m = re.exec(text);
    if (m) {
      eol = m[0].charCodeAt(0) !== 44;
      return text.substring(j, m.index);
    }
    re.lastIndex = text.length;
    return text.substring(j);
  }

  while ((t = token()) !== EOF) {
    var a = [];
    while ((t !== EOL) && (t !== EOF)) {
      a.push(t);
      t = token();
    }
    if (f && !(a = f(a, n++))) continue;
    rows.push(a);
  }

  return rows;
};
d3.csv.format = function(rows) {
  return rows.map(d3_csv_formatRow).join("\n");
};

function d3_csv_formatRow(row) {
  return row.map(d3_csv_formatValue).join(",");
}

function d3_csv_formatValue(text) {
  return /[",\n]/.test(text)
      ? "\"" + text.replace(/\"/g, "\"\"") + "\""
      : text;
}
})();

(function(){d3.geo = {};

var d3_geo_radians = Math.PI / 180;
// TODO clip input coordinates on opposite hemisphere
d3.geo.azimuthal = function() {
  var mode = "orthographic", // or stereographic, gnomonic, equidistant or equalarea
      origin,
      scale = 200,
      translate = [480, 250],
      x0,
      y0,
      cy0,
      sy0;

  function azimuthal(coordinates) {
    var x1 = coordinates[0] * d3_geo_radians - x0,
        y1 = coordinates[1] * d3_geo_radians,
        cx1 = Math.cos(x1),
        sx1 = Math.sin(x1),
        cy1 = Math.cos(y1),
        sy1 = Math.sin(y1),
        cc = mode !== "orthographic" ? sy0 * sy1 + cy0 * cy1 * cx1 : null,
        c,
        k = mode === "stereographic" ? 1 / (1 + cc)
          : mode === "gnomonic" ? 1 / cc
          : mode === "equidistant" ? (c = Math.acos(cc), c ? c / Math.sin(c) : 0)
          : mode === "equalarea" ? Math.sqrt(2 / (1 + cc))
          : 1,
        x = k * cy1 * sx1,
        y = k * (sy0 * cy1 * cx1 - cy0 * sy1);
    return [
      scale * x + translate[0],
      scale * y + translate[1]
    ];
  }

  azimuthal.invert = function(coordinates) {
    var x = (coordinates[0] - translate[0]) / scale,
        y = (coordinates[1] - translate[1]) / scale,
        p = Math.sqrt(x * x + y * y),
        c = mode === "stereographic" ? 2 * Math.atan(p)
          : mode === "gnomonic" ? Math.atan(p)
          : mode === "equidistant" ? p
          : mode === "equalarea" ? 2 * Math.asin(.5 * p)
          : Math.asin(p),
        sc = Math.sin(c),
        cc = Math.cos(c);
    return [
      (x0 + Math.atan2(x * sc, p * cy0 * cc + y * sy0 * sc)) / d3_geo_radians,
      Math.asin(cc * sy0 - (p ? (y * sc * cy0) / p : 0)) / d3_geo_radians
    ];
  };

  azimuthal.mode = function(x) {
    if (!arguments.length) return mode;
    mode = x + "";
    return azimuthal;
  };

  azimuthal.origin = function(x) {
    if (!arguments.length) return origin;
    origin = x;
    x0 = origin[0] * d3_geo_radians;
    y0 = origin[1] * d3_geo_radians;
    cy0 = Math.cos(y0);
    sy0 = Math.sin(y0);
    return azimuthal;
  };

  azimuthal.scale = function(x) {
    if (!arguments.length) return scale;
    scale = +x;
    return azimuthal;
  };

  azimuthal.translate = function(x) {
    if (!arguments.length) return translate;
    translate = [+x[0], +x[1]];
    return azimuthal;
  };

  return azimuthal.origin([0, 0]);
};
// Derived from Tom Carden's Albers implementation for Protovis.
// http://gist.github.com/476238
// http://mathworld.wolfram.com/AlbersEqual-AreaConicProjection.html

d3.geo.albers = function() {
  var origin = [-98, 38],
      parallels = [29.5, 45.5],
      scale = 1000,
      translate = [480, 250],
      lng0, // d3_geo_radians * origin[0]
      n,
      C,
      p0;

  function albers(coordinates) {
    var t = n * (d3_geo_radians * coordinates[0] - lng0),
        p = Math.sqrt(C - 2 * n * Math.sin(d3_geo_radians * coordinates[1])) / n;
    return [
      scale * p * Math.sin(t) + translate[0],
      scale * (p * Math.cos(t) - p0) + translate[1]
    ];
  }

  albers.invert = function(coordinates) {
    var x = (coordinates[0] - translate[0]) / scale,
        y = (coordinates[1] - translate[1]) / scale,
        p0y = p0 + y,
        t = Math.atan2(x, p0y),
        p = Math.sqrt(x * x + p0y * p0y);
    return [
      (lng0 + t / n) / d3_geo_radians,
      Math.asin((C - p * p * n * n) / (2 * n)) / d3_geo_radians
    ];
  };

  function reload() {
    var phi1 = d3_geo_radians * parallels[0],
        phi2 = d3_geo_radians * parallels[1],
        lat0 = d3_geo_radians * origin[1],
        s = Math.sin(phi1),
        c = Math.cos(phi1);
    lng0 = d3_geo_radians * origin[0];
    n = .5 * (s + Math.sin(phi2));
    C = c * c + 2 * n * s;
    p0 = Math.sqrt(C - 2 * n * Math.sin(lat0)) / n;
    return albers;
  }

  albers.origin = function(x) {
    if (!arguments.length) return origin;
    origin = [+x[0], +x[1]];
    return reload();
  };

  albers.parallels = function(x) {
    if (!arguments.length) return parallels;
    parallels = [+x[0], +x[1]];
    return reload();
  };

  albers.scale = function(x) {
    if (!arguments.length) return scale;
    scale = +x;
    return albers;
  };

  albers.translate = function(x) {
    if (!arguments.length) return translate;
    translate = [+x[0], +x[1]];
    return albers;
  };

  return reload();
};

// A composite projection for the United States, 960x500. The set of standard
// parallels for each region comes from USGS, which is published here:
// http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers
// TODO allow the composite projection to be rescaled?
d3.geo.albersUsa = function() {
  var lower48 = d3.geo.albers();

  var alaska = d3.geo.albers()
      .origin([-160, 60])
      .parallels([55, 65]);

  var hawaii = d3.geo.albers()
      .origin([-160, 20])
      .parallels([8, 18]);

  var puertoRico = d3.geo.albers()
      .origin([-60, 10])
      .parallels([8, 18]);

  function albersUsa(coordinates) {
    var lon = coordinates[0],
        lat = coordinates[1];
    return (lat > 50 ? alaska
        : lon < -140 ? hawaii
        : lat < 21 ? puertoRico
        : lower48)(coordinates);
  }

  albersUsa.scale = function(x) {
    if (!arguments.length) return lower48.scale();
    lower48.scale(x);
    alaska.scale(x * .6);
    hawaii.scale(x);
    puertoRico.scale(x * 1.5);
    return albersUsa.translate(lower48.translate());
  };

  albersUsa.translate = function(x) {
    if (!arguments.length) return lower48.translate();
    var dz = lower48.scale() / 1000,
        dx = x[0],
        dy = x[1];
    lower48.translate(x);
    alaska.translate([dx - 400 * dz, dy + 170 * dz]);
    hawaii.translate([dx - 190 * dz, dy + 200 * dz]);
    puertoRico.translate([dx + 580 * dz, dy + 430 * dz]);
    return albersUsa;
  };

  return albersUsa.scale(lower48.scale());
};
d3.geo.bonne = function() {
  var scale = 200,
      translate = [480, 250],
      x0, // origin longitude in radians
      y0, // origin latitude in radians
      y1, // parallel latitude in radians
      c1; // cot(y1)

  function bonne(coordinates) {
    var x = coordinates[0] * d3_geo_radians - x0,
        y = coordinates[1] * d3_geo_radians - y0;
    if (y1) {
      var p = c1 + y1 - y, E = x * Math.cos(y) / p;
      x = p * Math.sin(E);
      y = p * Math.cos(E) - c1;
    } else {
      x *= Math.cos(y);
      y *= -1;
    }
    return [
      scale * x + translate[0],
      scale * y + translate[1]
    ];
  }

  bonne.invert = function(coordinates) {
    var x = (coordinates[0] - translate[0]) / scale,
        y = (coordinates[1] - translate[1]) / scale;
    if (y1) {
      var c = c1 + y, p = Math.sqrt(x * x + c * c);
      y = c1 + y1 - p;
      x = x0 + p * Math.atan2(x, c) / Math.cos(y);
    } else {
      y *= -1;
      x /= Math.cos(y);
    }
    return [
      x / d3_geo_radians,
      y / d3_geo_radians
    ];
  };

  // 90° for Werner, 0° for Sinusoidal
  bonne.parallel = function(x) {
    if (!arguments.length) return y1 / d3_geo_radians;
    c1 = 1 / Math.tan(y1 = x * d3_geo_radians);
    return bonne;
  };

  bonne.origin = function(x) {
    if (!arguments.length) return [x0 / d3_geo_radians, y0 / d3_geo_radians];
    x0 = x[0] * d3_geo_radians;
    y0 = x[1] * d3_geo_radians;
    return bonne;
  };

  bonne.scale = function(x) {
    if (!arguments.length) return scale;
    scale = +x;
    return bonne;
  };

  bonne.translate = function(x) {
    if (!arguments.length) return translate;
    translate = [+x[0], +x[1]];
    return bonne;
  };

  return bonne.origin([0, 0]).parallel(45);
};
d3.geo.equirectangular = function() {
  var scale = 500,
      translate = [480, 250];

  function equirectangular(coordinates) {
    var x = coordinates[0] / 360,
        y = -coordinates[1] / 360;
    return [
      scale * x + translate[0],
      scale * y + translate[1]
    ];
  }

  equirectangular.invert = function(coordinates) {
    var x = (coordinates[0] - translate[0]) / scale,
        y = (coordinates[1] - translate[1]) / scale;
    return [
      360 * x,
      -360 * y
    ];
  };

  equirectangular.scale = function(x) {
    if (!arguments.length) return scale;
    scale = +x;
    return equirectangular;
  };

  equirectangular.translate = function(x) {
    if (!arguments.length) return translate;
    translate = [+x[0], +x[1]];
    return equirectangular;
  };

  return equirectangular;
};
d3.geo.mercator = function() {
  var scale = 500,
      translate = [480, 250];

  function mercator(coordinates) {
    var x = coordinates[0] / 360,
        y = -(Math.log(Math.tan(Math.PI / 4 + coordinates[1] * d3_geo_radians / 2)) / d3_geo_radians) / 360;
    return [
      scale * x + translate[0],
      scale * Math.max(-.5, Math.min(.5, y)) + translate[1]
    ];
  }

  mercator.invert = function(coordinates) {
    var x = (coordinates[0] - translate[0]) / scale,
        y = (coordinates[1] - translate[1]) / scale;
    return [
      360 * x,
      2 * Math.atan(Math.exp(-360 * y * d3_geo_radians)) / d3_geo_radians - 90
    ];
  };

  mercator.scale = function(x) {
    if (!arguments.length) return scale;
    scale = +x;
    return mercator;
  };

  mercator.translate = function(x) {
    if (!arguments.length) return translate;
    translate = [+x[0], +x[1]];
    return mercator;
  };

  return mercator;
};
function d3_geo_type(types, defaultValue) {
  return function(object) {
    return object && object.type in types ? types[object.type](object) : defaultValue;
  };
}
/**
 * Returns a function that, given a GeoJSON object (e.g., a feature), returns
 * the corresponding SVG path. The function can be customized by overriding the
 * projection. Point features are mapped to circles with a default radius of
 * 4.5px; the radius can be specified either as a constant or a function that
 * is evaluated per object.
 */
d3.geo.path = function() {
  var pointRadius = 4.5,
      pointCircle = d3_path_circle(pointRadius),
      projection = d3.geo.albersUsa();

  function path(d, i) {
    if (typeof pointRadius === "function") {
      pointCircle = d3_path_circle(pointRadius.apply(this, arguments));
    }
    return pathType(d) || null;
  }

  function project(coordinates) {
    return projection(coordinates).join(",");
  }

  var pathType = d3_geo_type({

    FeatureCollection: function(o) {
      var path = [],
          features = o.features,
          i = -1, // features.index
          n = features.length;
      while (++i < n) path.push(pathType(features[i].geometry));
      return path.join("");
    },

    Feature: function(o) {
      return pathType(o.geometry);
    },

    Point: function(o) {
      return "M" + project(o.coordinates) + pointCircle;
    },

    MultiPoint: function(o) {
      var path = [],
          coordinates = o.coordinates,
          i = -1, // coordinates.index
          n = coordinates.length;
      while (++i < n) path.push("M", project(coordinates[i]), pointCircle);
      return path.join("");
    },

    LineString: function(o) {
      var path = ["M"],
          coordinates = o.coordinates,
          i = -1, // coordinates.index
          n = coordinates.length;
      while (++i < n) path.push(project(coordinates[i]), "L");
      path.pop();
      return path.join("");
    },

    MultiLineString: function(o) {
      var path = [],
          coordinates = o.coordinates,
          i = -1, // coordinates.index
          n = coordinates.length,
          subcoordinates, // coordinates[i]
          j, // subcoordinates.index
          m; // subcoordinates.length
      while (++i < n) {
        subcoordinates = coordinates[i];
        j = -1;
        m = subcoordinates.length;
        path.push("M");
        while (++j < m) path.push(project(subcoordinates[j]), "L");
        path.pop();
      }
      return path.join("");
    },

    Polygon: function(o) {
      var path = [],
          coordinates = o.coordinates,
          i = -1, // coordinates.index
          n = coordinates.length,
          subcoordinates, // coordinates[i]
          j, // subcoordinates.index
          m; // subcoordinates.length
      while (++i < n) {
        subcoordinates = coordinates[i];
        j = -1;
        if ((m = subcoordinates.length - 1) > 0) {
          path.push("M");
          while (++j < m) path.push(project(subcoordinates[j]), "L");
          path[path.length - 1] = "Z";
        }
      }
      return path.join("");
    },

    MultiPolygon: function(o) {
      var path = [],
          coordinates = o.coordinates,
          i = -1, // coordinates index
          n = coordinates.length,
          subcoordinates, // coordinates[i]
          j, // subcoordinates index
          m, // subcoordinates.length
          subsubcoordinates, // subcoordinates[j]
          k, // subsubcoordinates index
          p; // subsubcoordinates.length
      while (++i < n) {
        subcoordinates = coordinates[i];
        j = -1;
        m = subcoordinates.length;
        while (++j < m) {
          subsubcoordinates = subcoordinates[j];
          k = -1;
          if ((p = subsubcoordinates.length - 1) > 0) {
            path.push("M");
            while (++k < p) path.push(project(subsubcoordinates[k]), "L");
            path[path.length - 1] = "Z";
          }
        }
      }
      return path.join("");
    },

    GeometryCollection: function(o) {
      var path = [],
          geometries = o.geometries,
          i = -1, // geometries index
          n = geometries.length;
      while (++i < n) path.push(pathType(geometries[i]));
      return path.join("");
    }

  });

  var areaType = path.area = d3_geo_type({

    FeatureCollection: function(o) {
      var area = 0,
          features = o.features,
          i = -1, // features.index
          n = features.length;
      while (++i < n) area += areaType(features[i]);
      return area;
    },

    Feature: function(o) {
      return areaType(o.geometry);
    },

    Polygon: function(o) {
      return polygonArea(o.coordinates);
    },

    MultiPolygon: function(o) {
      var sum = 0,
          coordinates = o.coordinates,
          i = -1, // coordinates index
          n = coordinates.length;
      while (++i < n) sum += polygonArea(coordinates[i]);
      return sum;
    },

    GeometryCollection: function(o) {
      var sum = 0,
          geometries = o.geometries,
          i = -1, // geometries index
          n = geometries.length;
      while (++i < n) sum += areaType(geometries[i]);
      return sum;
    }

  }, 0);

  function polygonArea(coordinates) {
    var sum = area(coordinates[0]), // exterior ring
        i = 0, // coordinates.index
        n = coordinates.length;
    while (++i < n) sum -= area(coordinates[i]); // holes
    return sum;
  }

  function polygonCentroid(coordinates) {
    var polygon = d3.geom.polygon(coordinates[0].map(projection)), // exterior ring
        area = polygon.area(),
        centroid = polygon.centroid(area < 0 ? (area *= -1, 1) : -1),
        x = centroid[0],
        y = centroid[1],
        z = area,
        i = 0, // coordinates index
        n = coordinates.length;
    while (++i < n) {
      polygon = d3.geom.polygon(coordinates[i].map(projection)); // holes
      area = polygon.area();
      centroid = polygon.centroid(area < 0 ? (area *= -1, 1) : -1);
      x -= centroid[0];
      y -= centroid[1];
      z -= area;
    }
    return [x, y, 6 * z]; // weighted centroid
  }

  var centroidType = path.centroid = d3_geo_type({

    // TODO FeatureCollection
    // TODO Point
    // TODO MultiPoint
    // TODO LineString
    // TODO MultiLineString
    // TODO GeometryCollection

    Feature: function(o) {
      return centroidType(o.geometry);
    },

    Polygon: function(o) {
      var centroid = polygonCentroid(o.coordinates);
      return [centroid[0] / centroid[2], centroid[1] / centroid[2]];
    },

    MultiPolygon: function(o) {
      var area = 0,
          coordinates = o.coordinates,
          centroid,
          x = 0,
          y = 0,
          z = 0,
          i = -1, // coordinates index
          n = coordinates.length;
      while (++i < n) {
        centroid = polygonCentroid(coordinates[i]);
        x += centroid[0];
        y += centroid[1];
        z += centroid[2];
      }
      return [x / z, y / z];
    }

  });

  function area(coordinates) {
    return Math.abs(d3.geom.polygon(coordinates.map(projection)).area());
  }

  path.projection = function(x) {
    projection = x;
    return path;
  };

  path.pointRadius = function(x) {
    if (typeof x === "function") pointRadius = x;
    else {
      pointRadius = +x;
      pointCircle = d3_path_circle(pointRadius);
    }
    return path;
  };

  return path;
};

function d3_path_circle(radius) {
  return "m0," + radius
      + "a" + radius + "," + radius + " 0 1,1 0," + (-2 * radius)
      + "a" + radius + "," + radius + " 0 1,1 0," + (+2 * radius)
      + "z";
}
/**
 * Given a GeoJSON object, returns the corresponding bounding box. The bounding
 * box is represented by a two-dimensional array: [[left, bottom], [right,
 * top]], where left is the minimum longitude, bottom is the minimum latitude,
 * right is maximum longitude, and top is the maximum latitude.
 */
d3.geo.bounds = function(feature) {
  var left = Infinity,
      bottom = Infinity,
      right = -Infinity,
      top = -Infinity;
  d3_geo_bounds(feature, function(x, y) {
    if (x < left) left = x;
    if (x > right) right = x;
    if (y < bottom) bottom = y;
    if (y > top) top = y;
  });
  return [[left, bottom], [right, top]];
};

function d3_geo_bounds(o, f) {
  if (o.type in d3_geo_boundsTypes) d3_geo_boundsTypes[o.type](o, f);
}

var d3_geo_boundsTypes = {
  Feature: d3_geo_boundsFeature,
  FeatureCollection: d3_geo_boundsFeatureCollection,
  LineString: d3_geo_boundsLineString,
  MultiLineString: d3_geo_boundsMultiLineString,
  MultiPoint: d3_geo_boundsLineString,
  MultiPolygon: d3_geo_boundsMultiPolygon,
  Point: d3_geo_boundsPoint,
  Polygon: d3_geo_boundsPolygon
};

function d3_geo_boundsFeature(o, f) {
  d3_geo_bounds(o.geometry, f);
}

function d3_geo_boundsFeatureCollection(o, f) {
  for (var a = o.features, i = 0, n = a.length; i < n; i++) {
    d3_geo_bounds(a[i].geometry, f);
  }
}

function d3_geo_boundsLineString(o, f) {
  for (var a = o.coordinates, i = 0, n = a.length; i < n; i++) {
    f.apply(null, a[i]);
  }
}

function d3_geo_boundsMultiLineString(o, f) {
  for (var a = o.coordinates, i = 0, n = a.length; i < n; i++) {
    for (var b = a[i], j = 0, m = b.length; j < m; j++) {
      f.apply(null, b[j]);
    }
  }
}

function d3_geo_boundsMultiPolygon(o, f) {
  for (var a = o.coordinates, i = 0, n = a.length; i < n; i++) {
    for (var b = a[i][0], j = 0, m = b.length; j < m; j++) {
      f.apply(null, b[j]);
    }
  }
}

function d3_geo_boundsPoint(o, f) {
  f.apply(null, o.coordinates);
}

function d3_geo_boundsPolygon(o, f) {
  for (var a = o.coordinates[0], i = 0, n = a.length; i < n; i++) {
    f.apply(null, a[i]);
  }
}
// TODO breakAtDateLine?

d3.geo.circle = function() {
  var origin = [0, 0],
      degrees = 90 - 1e-2,
      radians = degrees * d3_geo_radians,
      arc = d3.geo.greatArc().target(Object);

  function circle() {
    // TODO render a circle as a Polygon
  }

  function visible(point) {
    return arc.distance(point) < radians;
  }

  circle.clip = function(d) {
    arc.source(typeof origin === "function" ? origin.apply(this, arguments) : origin);
    return clipType(d);
  };

  var clipType = d3_geo_type({

    FeatureCollection: function(o) {
      var features = o.features.map(clipType).filter(Object);
      return features && (o = Object.create(o), o.features = features, o);
    },

    Feature: function(o) {
      var geometry = clipType(o.geometry);
      return geometry && (o = Object.create(o), o.geometry = geometry, o);
    },

    Point: function(o) {
      return visible(o.coordinates) && o;
    },

    MultiPoint: function(o) {
      var coordinates = o.coordinates.filter(visible);
      return coordinates.length && {
        type: o.type,
        coordinates: coordinates
      };
    },

    LineString: function(o) {
      var coordinates = clip(o.coordinates);
      return coordinates.length && (o = Object.create(o), o.coordinates = coordinates, o);
    },

    MultiLineString: function(o) {
      var coordinates = o.coordinates.map(clip).filter(function(d) { return d.length; });
      return coordinates.length && (o = Object.create(o), o.coordinates = coordinates, o);
    },

    Polygon: function(o) {
      var coordinates = o.coordinates.map(clip);
      return coordinates[0].length && (o = Object.create(o), o.coordinates = coordinates, o);
    },

    MultiPolygon: function(o) {
      var coordinates = o.coordinates.map(function(d) { return d.map(clip); }).filter(function(d) { return d[0].length; });
      return coordinates.length && (o = Object.create(o), o.coordinates = coordinates, o);
    },

    GeometryCollection: function(o) {
      var geometries = o.geometries.map(clipType).filter(Object);
      return geometries.length && (o = Object.create(o), o.geometries = geometries, o);
    }

  });

  function clip(coordinates) {
    var i = -1,
        n = coordinates.length,
        clipped = [],
        p0,
        p1,
        p2,
        d0,
        d1;

    while (++i < n) {
      d1 = arc.distance(p2 = coordinates[i]);
      if (d1 < radians) {
        if (p1) clipped.push(d3_geo_greatArcInterpolate(p1, p2)((d0 - radians) / (d0 - d1)));
        clipped.push(p2);
        p0 = p1 = null;
      } else {
        p1 = p2;
        if (!p0 && clipped.length) {
          clipped.push(d3_geo_greatArcInterpolate(clipped[clipped.length - 1], p1)((radians - d0) / (d1 - d0)));
          p0 = p1;
        }
      }
      d0 = d1;
    }

    if (p1 && clipped.length) {
      d1 = arc.distance(p2 = clipped[0]);
      clipped.push(d3_geo_greatArcInterpolate(p1, p2)((d0 - radians) / (d0 - d1)));
    }

    return resample(clipped);
  }

  // Resample coordinates, creating great arcs between each.
  function resample(coordinates) {
    var i = 0,
        n = coordinates.length,
        j,
        m,
        resampled = n ? [coordinates[0]] : coordinates,
        resamples,
        origin = arc.source();

    while (++i < n) {
      resamples = arc.source(coordinates[i - 1])(coordinates[i]).coordinates;
      for (j = 0, m = resamples.length; ++j < m;) resampled.push(resamples[j]);
    }

    arc.source(origin);
    return resampled;
  }

  circle.origin = function(x) {
    if (!arguments.length) return origin;
    origin = x;
    return circle;
  };

  circle.angle = function(x) {
    if (!arguments.length) return degrees;
    radians = (degrees = +x) * d3_geo_radians;
    return circle;
  };

  // Precision is specified in degrees.
  circle.precision = function(x) {
    if (!arguments.length) return arc.precision();
    arc.precision(x);
    return circle;
  };

  return circle;
}
d3.geo.greatArc = function() {
  var source = d3_geo_greatArcSource,
      target = d3_geo_greatArcTarget,
      precision = 6 * d3_geo_radians;

  function greatArc() {
    var a = typeof source === "function" ? source.apply(this, arguments) : source,
        b = typeof target === "function" ? target.apply(this, arguments) : target,
        i = d3_geo_greatArcInterpolate(a, b),
        dt = precision / i.d,
        t = 0,
        coordinates = [a];
    while ((t += dt) < 1) coordinates.push(i(t));
    coordinates.push(b);
    return {
      type: "LineString",
      coordinates: coordinates
    };
  }

  // Length returned in radians; multiply by radius for distance.
  greatArc.distance = function() {
    var a = typeof source === "function" ? source.apply(this, arguments) : source,
        b = typeof target === "function" ? target.apply(this, arguments) : target;
     return d3_geo_greatArcInterpolate(a, b).d;
  };

  greatArc.source = function(x) {
    if (!arguments.length) return source;
    source = x;
    return greatArc;
  };

  greatArc.target = function(x) {
    if (!arguments.length) return target;
    target = x;
    return greatArc;
  };

  // Precision is specified in degrees.
  greatArc.precision = function(x) {
    if (!arguments.length) return precision / d3_geo_radians;
    precision = x * d3_geo_radians;
    return greatArc;
  };

  return greatArc;
};

function d3_geo_greatArcSource(d) {
  return d.source;
}

function d3_geo_greatArcTarget(d) {
  return d.target;
}

function d3_geo_greatArcInterpolate(a, b) {
  var x0 = a[0] * d3_geo_radians, cx0 = Math.cos(x0), sx0 = Math.sin(x0),
      y0 = a[1] * d3_geo_radians, cy0 = Math.cos(y0), sy0 = Math.sin(y0),
      x1 = b[0] * d3_geo_radians, cx1 = Math.cos(x1), sx1 = Math.sin(x1),
      y1 = b[1] * d3_geo_radians, cy1 = Math.cos(y1), sy1 = Math.sin(y1),
      d = interpolate.d = Math.acos(Math.max(-1, Math.min(1, sy0 * sy1 + cy0 * cy1 * Math.cos(x1 - x0)))),
      sd = Math.sin(d);

  // From http://williams.best.vwh.net/avform.htm#Intermediate
  function interpolate(t) {
    var A = Math.sin(d - (t *= d)) / sd,
        B = Math.sin(t) / sd,
        x = A * cy0 * cx0 + B * cy1 * cx1,
        y = A * cy0 * sx0 + B * cy1 * sx1,
        z = A * sy0       + B * sy1;
    return [
      Math.atan2(y, x) / d3_geo_radians,
      Math.atan2(z, Math.sqrt(x * x + y * y)) / d3_geo_radians
    ];
  }

  return interpolate;
}
d3.geo.greatCircle = d3.geo.circle;
})();

(function(){d3.geom = {};
/**
 * Computes a contour for a given input grid function using the <a
 * href="http://en.wikipedia.org/wiki/Marching_squares">marching
 * squares</a> algorithm. Returns the contour polygon as an array of points.
 *
 * @param grid a two-input function(x, y) that returns true for values
 * inside the contour and false for values outside the contour.
 * @param start an optional starting point [x, y] on the grid.
 * @returns polygon [[x1, y1], [x2, y2], …]
 */
d3.geom.contour = function(grid, start) {
  var s = start || d3_geom_contourStart(grid), // starting point
      c = [],    // contour polygon
      x = s[0],  // current x position
      y = s[1],  // current y position
      dx = 0,    // next x direction
      dy = 0,    // next y direction
      pdx = NaN, // previous x direction
      pdy = NaN, // previous y direction
      i = 0;

  do {
    // determine marching squares index
    i = 0;
    if (grid(x-1, y-1)) i += 1;
    if (grid(x,   y-1)) i += 2;
    if (grid(x-1, y  )) i += 4;
    if (grid(x,   y  )) i += 8;

    // determine next direction
    if (i === 6) {
      dx = pdy === -1 ? -1 : 1;
      dy = 0;
    } else if (i === 9) {
      dx = 0;
      dy = pdx === 1 ? -1 : 1;
    } else {
      dx = d3_geom_contourDx[i];
      dy = d3_geom_contourDy[i];
    }

    // update contour polygon
    if (dx != pdx && dy != pdy) {
      c.push([x, y]);
      pdx = dx;
      pdy = dy;
    }

    x += dx;
    y += dy;
  } while (s[0] != x || s[1] != y);

  return c;
};

// lookup tables for marching directions
var d3_geom_contourDx = [1, 0, 1, 1,-1, 0,-1, 1,0, 0,0,0,-1, 0,-1,NaN],
    d3_geom_contourDy = [0,-1, 0, 0, 0,-1, 0, 0,1,-1,1,1, 0,-1, 0,NaN];

function d3_geom_contourStart(grid) {
  var x = 0,
      y = 0;

  // search for a starting point; begin at origin
  // and proceed along outward-expanding diagonals
  while (true) {
    if (grid(x,y)) {
      return [x,y];
    }
    if (x === 0) {
      x = y + 1;
      y = 0;
    } else {
      x = x - 1;
      y = y + 1;
    }
  }
}
/**
 * Computes the 2D convex hull of a set of points using Graham's scanning
 * algorithm. The algorithm has been implemented as described in Cormen,
 * Leiserson, and Rivest's Introduction to Algorithms. The running time of
 * this algorithm is O(n log n), where n is the number of input points.
 *
 * @param vertices [[x1, y1], [x2, y2], …]
 * @returns polygon [[x1, y1], [x2, y2], …]
 */
d3.geom.hull = function(vertices) {
  if (vertices.length < 3) return [];

  var len = vertices.length,
      plen = len - 1,
      points = [],
      stack = [],
      i, j, h = 0, x1, y1, x2, y2, u, v, a, sp;

  // find the starting ref point: leftmost point with the minimum y coord
  for (i=1; i<len; ++i) {
    if (vertices[i][1] < vertices[h][1]) {
      h = i;
    } else if (vertices[i][1] == vertices[h][1]) {
      h = (vertices[i][0] < vertices[h][0] ? i : h);
    }
  }

  // calculate polar angles from ref point and sort
  for (i=0; i<len; ++i) {
    if (i === h) continue;
    y1 = vertices[i][1] - vertices[h][1];
    x1 = vertices[i][0] - vertices[h][0];
    points.push({angle: Math.atan2(y1, x1), index: i});
  }
  points.sort(function(a, b) { return a.angle - b.angle; });

  // toss out duplicate angles
  a = points[0].angle;
  v = points[0].index;
  u = 0;
  for (i=1; i<plen; ++i) {
    j = points[i].index;
    if (a == points[i].angle) {
      // keep angle for point most distant from the reference
      x1 = vertices[v][0] - vertices[h][0];
      y1 = vertices[v][1] - vertices[h][1];
      x2 = vertices[j][0] - vertices[h][0];
      y2 = vertices[j][1] - vertices[h][1];
      if ((x1*x1 + y1*y1) >= (x2*x2 + y2*y2)) {
        points[i].index = -1;
      } else {
        points[u].index = -1;
        a = points[i].angle;
        u = i;
        v = j;
      }
    } else {
      a = points[i].angle;
      u = i;
      v = j;
    }
  }

  // initialize the stack
  stack.push(h);
  for (i=0, j=0; i<2; ++j) {
    if (points[j].index !== -1) {
      stack.push(points[j].index);
      i++;
    }
  }
  sp = stack.length;

  // do graham's scan
  for (; j<plen; ++j) {
    if (points[j].index === -1) continue; // skip tossed out points
    while (!d3_geom_hullCCW(stack[sp-2], stack[sp-1], points[j].index, vertices)) {
      --sp;
    }
    stack[sp++] = points[j].index;
  }

  // construct the hull
  var poly = [];
  for (i=0; i<sp; ++i) {
    poly.push(vertices[stack[i]]);
  }
  return poly;
}

// are three points in counter-clockwise order?
function d3_geom_hullCCW(i1, i2, i3, v) {
  var t, a, b, c, d, e, f;
  t = v[i1]; a = t[0]; b = t[1];
  t = v[i2]; c = t[0]; d = t[1];
  t = v[i3]; e = t[0]; f = t[1];
  return ((f-b)*(c-a) - (d-b)*(e-a)) > 0;
}
// Note: requires coordinates to be counterclockwise and convex!
d3.geom.polygon = function(coordinates) {

  coordinates.area = function() {
    var i = 0,
        n = coordinates.length,
        a = coordinates[n - 1][0] * coordinates[0][1],
        b = coordinates[n - 1][1] * coordinates[0][0];
    while (++i < n) {
      a += coordinates[i - 1][0] * coordinates[i][1];
      b += coordinates[i - 1][1] * coordinates[i][0];
    }
    return (b - a) * .5;
  };

  coordinates.centroid = function(k) {
    var i = -1,
        n = coordinates.length - 1,
        x = 0,
        y = 0,
        a,
        b,
        c;
    if (!arguments.length) k = -1 / (6 * coordinates.area());
    while (++i < n) {
      a = coordinates[i];
      b = coordinates[i + 1];
      c = a[0] * b[1] - b[0] * a[1];
      x += (a[0] + b[0]) * c;
      y += (a[1] + b[1]) * c;
    }
    return [x * k, y * k];
  };

  // The Sutherland-Hodgman clipping algorithm.
  coordinates.clip = function(subject) {
    var input,
        i = -1,
        n = coordinates.length,
        j,
        m,
        a = coordinates[n - 1],
        b,
        c,
        d;
    while (++i < n) {
      input = subject.slice();
      subject.length = 0;
      b = coordinates[i];
      c = input[(m = input.length) - 1];
      j = -1;
      while (++j < m) {
        d = input[j];
        if (d3_geom_polygonInside(d, a, b)) {
          if (!d3_geom_polygonInside(c, a, b)) {
            subject.push(d3_geom_polygonIntersect(c, d, a, b));
          }
          subject.push(d);
        } else if (d3_geom_polygonInside(c, a, b)) {
          subject.push(d3_geom_polygonIntersect(c, d, a, b));
        }
        c = d;
      }
      a = b;
    }
    return subject;
  };

  return coordinates;
};

function d3_geom_polygonInside(p, a, b) {
  return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
}

// Intersect two infinite lines cd and ab.
function d3_geom_polygonIntersect(c, d, a, b) {
  var x1 = c[0], x2 = d[0], x3 = a[0], x4 = b[0],
      y1 = c[1], y2 = d[1], y3 = a[1], y4 = b[1],
      x13 = x1 - x3,
      x21 = x2 - x1,
      x43 = x4 - x3,
      y13 = y1 - y3,
      y21 = y2 - y1,
      y43 = y4 - y3,
      ua = (x43 * y13 - y43 * x13) / (y43 * x21 - x43 * y21);
  return [x1 + ua * x21, y1 + ua * y21];
}
// Adapted from Nicolas Garcia Belmonte's JIT implementation:
// http://blog.thejit.org/2010/02/12/voronoi-tessellation/
// http://blog.thejit.org/assets/voronoijs/voronoi.js
// See lib/jit/LICENSE for details.

// Notes:
//
// This implementation does not clip the returned polygons, so if you want to
// clip them to a particular shape you will need to do that either in SVG or by
// post-processing with d3.geom.polygon's clip method.
//
// If any vertices are coincident or have NaN positions, the behavior of this
// method is undefined. Most likely invalid polygons will be returned. You
// should filter invalid points, and consolidate coincident points, before
// computing the tessellation.

/**
 * @param vertices [[x1, y1], [x2, y2], …]
 * @returns polygons [[[x1, y1], [x2, y2], …], …]
 */
d3.geom.voronoi = function(vertices) {
  var polygons = vertices.map(function() { return []; });

  d3_voronoi_tessellate(vertices, function(e) {
    var s1,
        s2,
        x1,
        x2,
        y1,
        y2;
    if (e.a === 1 && e.b >= 0) {
      s1 = e.ep.r;
      s2 = e.ep.l;
    } else {
      s1 = e.ep.l;
      s2 = e.ep.r;
    }
    if (e.a === 1) {
      y1 = s1 ? s1.y : -1e6;
      x1 = e.c - e.b * y1;
      y2 = s2 ? s2.y : 1e6;
      x2 = e.c - e.b * y2;
    } else {
      x1 = s1 ? s1.x : -1e6;
      y1 = e.c - e.a * x1;
      x2 = s2 ? s2.x : 1e6;
      y2 = e.c - e.a * x2;
    }
    var v1 = [x1, y1],
        v2 = [x2, y2];
    polygons[e.region.l.index].push(v1, v2);
    polygons[e.region.r.index].push(v1, v2);
  });

  // Reconnect the polygon segments into counterclockwise loops.
  return polygons.map(function(polygon, i) {
    var cx = vertices[i][0],
        cy = vertices[i][1];
    polygon.forEach(function(v) {
      v.angle = Math.atan2(v[0] - cx, v[1] - cy);
    });
    return polygon.sort(function(a, b) {
      return a.angle - b.angle;
    }).filter(function(d, i) {
      return !i || (d.angle - polygon[i - 1].angle > 1e-10);
    });
  });
};

var d3_voronoi_opposite = {"l": "r", "r": "l"};

function d3_voronoi_tessellate(vertices, callback) {

  var Sites = {
    list: vertices
      .map(function(v, i) {
        return {
          index: i,
          x: v[0],
          y: v[1]
        };
      })
      .sort(function(a, b) {
        return a.y < b.y ? -1
          : a.y > b.y ? 1
          : a.x < b.x ? -1
          : a.x > b.x ? 1
          : 0;
      }),
    bottomSite: null
  };

  var EdgeList = {
    list: [],
    leftEnd: null,
    rightEnd: null,

    init: function() {
      EdgeList.leftEnd = EdgeList.createHalfEdge(null, "l");
      EdgeList.rightEnd = EdgeList.createHalfEdge(null, "l");
      EdgeList.leftEnd.r = EdgeList.rightEnd;
      EdgeList.rightEnd.l = EdgeList.leftEnd;
      EdgeList.list.unshift(EdgeList.leftEnd, EdgeList.rightEnd);
    },

    createHalfEdge: function(edge, side) {
      return {
        edge: edge,
        side: side,
        vertex: null,
        "l": null,
        "r": null
      };
    },

    insert: function(lb, he) {
      he.l = lb;
      he.r = lb.r;
      lb.r.l = he;
      lb.r = he;
    },

    leftBound: function(p) {
      var he = EdgeList.leftEnd;
      do {
        he = he.r;
      } while (he != EdgeList.rightEnd && Geom.rightOf(he, p));
      he = he.l;
      return he;
    },

    del: function(he) {
      he.l.r = he.r;
      he.r.l = he.l;
      he.edge = null;
    },

    right: function(he) {
      return he.r;
    },

    left: function(he) {
      return he.l;
    },

    leftRegion: function(he) {
      return he.edge == null
          ? Sites.bottomSite
          : he.edge.region[he.side];
    },

    rightRegion: function(he) {
      return he.edge == null
          ? Sites.bottomSite
          : he.edge.region[d3_voronoi_opposite[he.side]];
    }
  };

  var Geom = {

    bisect: function(s1, s2) {
      var newEdge = {
        region: {"l": s1, "r": s2},
        ep: {"l": null, "r": null}
      };

      var dx = s2.x - s1.x,
          dy = s2.y - s1.y,
          adx = dx > 0 ? dx : -dx,
          ady = dy > 0 ? dy : -dy;

      newEdge.c = s1.x * dx + s1.y * dy
          + (dx * dx + dy * dy) * .5;

      if (adx > ady) {
        newEdge.a = 1;
        newEdge.b = dy / dx;
        newEdge.c /= dx;
      } else {
        newEdge.b = 1;
        newEdge.a = dx / dy;
        newEdge.c /= dy;
      }

      return newEdge;
    },

    intersect: function(el1, el2) {
      var e1 = el1.edge,
          e2 = el2.edge;
      if (!e1 || !e2 || (e1.region.r == e2.region.r)) {
        return null;
      }
      var d = (e1.a * e2.b) - (e1.b * e2.a);
      if (Math.abs(d) < 1e-10) {
        return null;
      }
      var xint = (e1.c * e2.b - e2.c * e1.b) / d,
          yint = (e2.c * e1.a - e1.c * e2.a) / d,
          e1r = e1.region.r,
          e2r = e2.region.r,
          el,
          e;
      if ((e1r.y < e2r.y) ||
         (e1r.y == e2r.y && e1r.x < e2r.x)) {
        el = el1;
        e = e1;
      } else {
        el = el2;
        e = e2;
      }
      var rightOfSite = (xint >= e.region.r.x);
      if ((rightOfSite && (el.side === "l")) ||
        (!rightOfSite && (el.side === "r"))) {
        return null;
      }
      return {
        x: xint,
        y: yint
      };
    },

    rightOf: function(he, p) {
      var e = he.edge,
          topsite = e.region.r,
          rightOfSite = (p.x > topsite.x);

      if (rightOfSite && (he.side === "l")) {
        return 1;
      }
      if (!rightOfSite && (he.side === "r")) {
        return 0;
      }
      if (e.a === 1) {
        var dyp = p.y - topsite.y,
            dxp = p.x - topsite.x,
            fast = 0,
            above = 0;

        if ((!rightOfSite && (e.b < 0)) ||
          (rightOfSite && (e.b >= 0))) {
          above = fast = (dyp >= e.b * dxp);
        } else {
          above = ((p.x + p.y * e.b) > e.c);
          if (e.b < 0) {
            above = !above;
          }
          if (!above) {
            fast = 1;
          }
        }
        if (!fast) {
          var dxs = topsite.x - e.region.l.x;
          above = (e.b * (dxp * dxp - dyp * dyp)) <
            (dxs * dyp * (1 + 2 * dxp / dxs + e.b * e.b));

          if (e.b < 0) {
            above = !above;
          }
        }
      } else /* e.b == 1 */ {
        var yl = e.c - e.a * p.x,
            t1 = p.y - yl,
            t2 = p.x - topsite.x,
            t3 = yl - topsite.y;

        above = (t1 * t1) > (t2 * t2 + t3 * t3);
      }
      return he.side === "l" ? above : !above;
    },

    endPoint: function(edge, side, site) {
      edge.ep[side] = site;
      if (!edge.ep[d3_voronoi_opposite[side]]) return;
      callback(edge);
    },

    distance: function(s, t) {
      var dx = s.x - t.x,
          dy = s.y - t.y;
      return Math.sqrt(dx * dx + dy * dy);
    }
  };

  var EventQueue = {
    list: [],

    insert: function(he, site, offset) {
      he.vertex = site;
      he.ystar = site.y + offset;
      for (var i=0, list=EventQueue.list, l=list.length; i<l; i++) {
        var next = list[i];
        if (he.ystar > next.ystar ||
          (he.ystar == next.ystar &&
          site.x > next.vertex.x)) {
          continue;
        } else {
          break;
        }
      }
      list.splice(i, 0, he);
    },

    del: function(he) {
      for (var i=0, ls=EventQueue.list, l=ls.length; i<l && (ls[i] != he); ++i) {}
      ls.splice(i, 1);
    },

    empty: function() { return EventQueue.list.length === 0; },

    nextEvent: function(he) {
      for (var i=0, ls=EventQueue.list, l=ls.length; i<l; ++i) {
        if (ls[i] == he) return ls[i+1];
      }
      return null;
    },

    min: function() {
      var elem = EventQueue.list[0];
      return {
        x: elem.vertex.x,
        y: elem.ystar
      };
    },

    extractMin: function() {
      return EventQueue.list.shift();
    }
  };

  EdgeList.init();
  Sites.bottomSite = Sites.list.shift();

  var newSite = Sites.list.shift(), newIntStar;
  var lbnd, rbnd, llbnd, rrbnd, bisector;
  var bot, top, temp, p, v;
  var e, pm;

  while (true) {
    if (!EventQueue.empty()) {
      newIntStar = EventQueue.min();
    }
    if (newSite && (EventQueue.empty()
      || newSite.y < newIntStar.y
      || (newSite.y == newIntStar.y
      && newSite.x < newIntStar.x))) { //new site is smallest
      lbnd = EdgeList.leftBound(newSite);
      rbnd = EdgeList.right(lbnd);
      bot = EdgeList.rightRegion(lbnd);
      e = Geom.bisect(bot, newSite);
      bisector = EdgeList.createHalfEdge(e, "l");
      EdgeList.insert(lbnd, bisector);
      p = Geom.intersect(lbnd, bisector);
      if (p) {
        EventQueue.del(lbnd);
        EventQueue.insert(lbnd, p, Geom.distance(p, newSite));
      }
      lbnd = bisector;
      bisector = EdgeList.createHalfEdge(e, "r");
      EdgeList.insert(lbnd, bisector);
      p = Geom.intersect(bisector, rbnd);
      if (p) {
        EventQueue.insert(bisector, p, Geom.distance(p, newSite));
      }
      newSite = Sites.list.shift();
    } else if (!EventQueue.empty()) { //intersection is smallest
      lbnd = EventQueue.extractMin();
      llbnd = EdgeList.left(lbnd);
      rbnd = EdgeList.right(lbnd);
      rrbnd = EdgeList.right(rbnd);
      bot = EdgeList.leftRegion(lbnd);
      top = EdgeList.rightRegion(rbnd);
      v = lbnd.vertex;
      Geom.endPoint(lbnd.edge, lbnd.side, v);
      Geom.endPoint(rbnd.edge, rbnd.side, v);
      EdgeList.del(lbnd);
      EventQueue.del(rbnd);
      EdgeList.del(rbnd);
      pm = "l";
      if (bot.y > top.y) {
        temp = bot;
        bot = top;
        top = temp;
        pm = "r";
      }
      e = Geom.bisect(bot, top);
      bisector = EdgeList.createHalfEdge(e, pm);
      EdgeList.insert(llbnd, bisector);
      Geom.endPoint(e, d3_voronoi_opposite[pm], v);
      p = Geom.intersect(llbnd, bisector);
      if (p) {
        EventQueue.del(llbnd);
        EventQueue.insert(llbnd, p, Geom.distance(p, bot));
      }
      p = Geom.intersect(bisector, rrbnd);
      if (p) {
        EventQueue.insert(bisector, p, Geom.distance(p, bot));
      }
    } else {
      break;
    }
  }//end while

  for (lbnd = EdgeList.right(EdgeList.leftEnd);
      lbnd != EdgeList.rightEnd;
      lbnd = EdgeList.right(lbnd)) {
    callback(lbnd.edge);
  }
}
/**
* @param vertices [[x1, y1], [x2, y2], …]
* @returns triangles [[[x1, y1], [x2, y2], [x3, y3]], …]
 */
d3.geom.delaunay = function(vertices) {
  var edges = vertices.map(function() { return []; }),
      triangles = [];

  // Use the Voronoi tessellation to determine Delaunay edges.
  d3_voronoi_tessellate(vertices, function(e) {
    edges[e.region.l.index].push(vertices[e.region.r.index]);
  });

  // Reconnect the edges into counterclockwise triangles.
  edges.forEach(function(edge, i) {
    var v = vertices[i],
        cx = v[0],
        cy = v[1];
    edge.forEach(function(v) {
      v.angle = Math.atan2(v[0] - cx, v[1] - cy);
    });
    edge.sort(function(a, b) {
      return a.angle - b.angle;
    });
    for (var j = 0, m = edge.length - 1; j < m; j++) {
      triangles.push([v, edge[j], edge[j + 1]]);
    }
  });

  return triangles;
};
// Constructs a new quadtree for the specified array of points. A quadtree is a
// two-dimensional recursive spatial subdivision. This implementation uses
// square partitions, dividing each square into four equally-sized squares. Each
// point exists in a unique node; if multiple points are in the same position,
// some points may be stored on internal nodes rather than leaf nodes. Quadtrees
// can be used to accelerate various spatial operations, such as the Barnes-Hut
// approximation for computing n-body forces, or collision detection.
d3.geom.quadtree = function(points, x1, y1, x2, y2) {
  var p,
      i = -1,
      n = points.length;

  // Type conversion for deprecated API.
  if (n && isNaN(points[0].x)) points = points.map(d3_geom_quadtreePoint);

  // Allow bounds to be specified explicitly.
  if (arguments.length < 5) {
    if (arguments.length === 3) {
      y2 = x2 = y1;
      y1 = x1;
    } else {
      x1 = y1 = Infinity;
      x2 = y2 = -Infinity;

      // Compute bounds.
      while (++i < n) {
        p = points[i];
        if (p.x < x1) x1 = p.x;
        if (p.y < y1) y1 = p.y;
        if (p.x > x2) x2 = p.x;
        if (p.y > y2) y2 = p.y;
      }

      // Squarify the bounds.
      var dx = x2 - x1,
          dy = y2 - y1;
      if (dx > dy) y2 = y1 + dx;
      else x2 = x1 + dy;
    }
  }

  // Recursively inserts the specified point p at the node n or one of its
  // descendants. The bounds are defined by [x1, x2] and [y1, y2].
  function insert(n, p, x1, y1, x2, y2) {
    if (isNaN(p.x) || isNaN(p.y)) return; // ignore invalid points
    if (n.leaf) {
      var v = n.point;
      if (v) {
        // If the point at this leaf node is at the same position as the new
        // point we are adding, we leave the point associated with the
        // internal node while adding the new point to a child node. This
        // avoids infinite recursion.
        if ((Math.abs(v.x - p.x) + Math.abs(v.y - p.y)) < .01) {
          insertChild(n, p, x1, y1, x2, y2);
        } else {
          n.point = null;
          insertChild(n, v, x1, y1, x2, y2);
          insertChild(n, p, x1, y1, x2, y2);
        }
      } else {
        n.point = p;
      }
    } else {
      insertChild(n, p, x1, y1, x2, y2);
    }
  }

  // Recursively inserts the specified point p into a descendant of node n. The
  // bounds are defined by [x1, x2] and [y1, y2].
  function insertChild(n, p, x1, y1, x2, y2) {
    // Compute the split point, and the quadrant in which to insert p.
    var sx = (x1 + x2) * .5,
        sy = (y1 + y2) * .5,
        right = p.x >= sx,
        bottom = p.y >= sy,
        i = (bottom << 1) + right;

    // Recursively insert into the child node.
    n.leaf = false;
    n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());

    // Update the bounds as we recurse.
    if (right) x1 = sx; else x2 = sx;
    if (bottom) y1 = sy; else y2 = sy;
    insert(n, p, x1, y1, x2, y2);
  }

  // Create the root node.
  var root = d3_geom_quadtreeNode();

  root.add = function(p) {
    insert(root, p, x1, y1, x2, y2);
  };

  root.visit = function(f) {
    d3_geom_quadtreeVisit(f, root, x1, y1, x2, y2);
  };

  // Insert all points.
  points.forEach(root.add);
  return root;
};

function d3_geom_quadtreeNode() {
  return {
    leaf: true,
    nodes: [],
    point: null
  };
}

function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
  if (!f(node, x1, y1, x2, y2)) {
    var sx = (x1 + x2) * .5,
        sy = (y1 + y2) * .5,
        children = node.nodes;
    if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
    if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
    if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
    if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
  }
}

function d3_geom_quadtreePoint(p) {
  return {
    x: p[0],
    y: p[1]
  };
}
})();

(function(){if (!Date.now) Date.now = function() {
  return +new Date;
};
try {
  document.createElement("div").style.setProperty("opacity", 0, "");
} catch (error) {
  var d3_style_prototype = CSSStyleDeclaration.prototype,
      d3_style_setProperty = d3_style_prototype.setProperty;
  d3_style_prototype.setProperty = function(name, value, priority) {
    d3_style_setProperty.call(this, name, value + "", priority);
  };
}
d3 = {version: "2.5.0"}; // semver
var d3_array = d3_arraySlice; // conversion for NodeLists

function d3_arrayCopy(pseudoarray) {
  var i = -1, n = pseudoarray.length, array = [];
  while (++i < n) array.push(pseudoarray[i]);
  return array;
}

function d3_arraySlice(pseudoarray) {
  return Array.prototype.slice.call(pseudoarray);
}

try {
  d3_array(document.documentElement.childNodes)[0].nodeType;
} catch(e) {
  d3_array = d3_arrayCopy;
}

var d3_arraySubclass = [].__proto__?

// Until ECMAScript supports array subclassing, prototype injection works well.
function(array, prototype) {
  array.__proto__ = prototype;
}:

// And if your browser doesn't support __proto__, we'll use direct extension.
function(array, prototype) {
  for (var property in prototype) array[property] = prototype[property];
};
function d3_this() {
  return this;
}
d3.functor = function(v) {
  return typeof v === "function" ? v : function() { return v; };
};
// A getter-setter method that preserves the appropriate `this` context.
d3.rebind = function(object, method) {
  return function() {
    var x = method.apply(object, arguments);
    return arguments.length ? object : x;
  };
};
d3.ascending = function(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
};
d3.descending = function(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
};
d3.mean = function(array, f) {
  var n = array.length,
      a,
      m = 0,
      i = -1,
      j = 0;
  if (arguments.length === 1) {
    while (++i < n) if (d3_number(a = array[i])) m += (a - m) / ++j;
  } else {
    while (++i < n) if (d3_number(a = f.call(array, array[i], i))) m += (a - m) / ++j;
  }
  return j ? m : undefined;
};
d3.median = function(array, f) {
  if (arguments.length > 1) array = array.map(f);
  array = array.filter(d3_number);
  return array.length ? d3.quantile(array.sort(d3.ascending), .5) : undefined;
};
d3.min = function(array, f) {
  var i = -1,
      n = array.length,
      a,
      b;
  if (arguments.length === 1) {
    while (++i < n && ((a = array[i]) == null || a != a)) a = undefined;
    while (++i < n) if ((b = array[i]) != null && a > b) a = b;
  } else {
    while (++i < n && ((a = f.call(array, array[i], i)) == null || a != a)) a = undefined;
    while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
  }
  return a;
};
d3.max = function(array, f) {
  var i = -1,
      n = array.length,
      a,
      b;
  if (arguments.length === 1) {
    while (++i < n && ((a = array[i]) == null || a != a)) a = undefined;
    while (++i < n) if ((b = array[i]) != null && b > a) a = b;
  } else {
    while (++i < n && ((a = f.call(array, array[i], i)) == null || a != a)) a = undefined;
    while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
  }
  return a;
};
d3.extent = function(array, f) {
  var i = -1,
      n = array.length,
      a,
      b,
      c;
  if (arguments.length === 1) {
    while (++i < n && ((a = c = array[i]) == null || a != a)) a = c = undefined;
    while (++i < n) if ((b = array[i]) != null) {
      if (a > b) a = b;
      if (c < b) c = b;
    }
  } else {
    while (++i < n && ((a = c = f.call(array, array[i], i)) == null || a != a)) a = undefined;
    while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
      if (a > b) a = b;
      if (c < b) c = b;
    }
  }
  return [a, c];
};
d3.random = {
  normal: function(mean, deviation) {
    if (arguments.length < 2) deviation = 1;
    if (arguments.length < 1) mean = 0;
    return function() {
      var x, y, r;
      do {
        x = Math.random() * 2 - 1;
        y = Math.random() * 2 - 1;
        r = x * x + y * y;
      } while (!r || r > 1);
      return mean + deviation * x * Math.sqrt(-2 * Math.log(r) / r);
    };
  }
};
function d3_number(x) {
  return x != null && !isNaN(x);
}
d3.sum = function(array, f) {
  var s = 0,
      n = array.length,
      a,
      i = -1;

  if (arguments.length === 1) {
    while (++i < n) if (!isNaN(a = +array[i])) s += a;
  } else {
    while (++i < n) if (!isNaN(a = +f.call(array, array[i], i))) s += a;
  }

  return s;
};
// R-7 per <http://en.wikipedia.org/wiki/Quantile>
d3.quantile = function(values, p) {
  var H = (values.length - 1) * p + 1,
      h = Math.floor(H),
      v = values[h - 1],
      e = H - h;
  return e ? v + e * (values[h] - v) : v;
};
d3.zip = function() {
  if (!(n = arguments.length)) return [];
  for (var i = -1, m = d3.min(arguments, d3_zipLength), zips = new Array(m); ++i < m;) {
    for (var j = -1, n, zip = zips[i] = new Array(n); ++j < n;) {
      zip[j] = arguments[j][i];
    }
  }
  return zips;
};

function d3_zipLength(d) {
  return d.length;
}
// Locate the insertion point for x in a to maintain sorted order. The
// arguments lo and hi may be used to specify a subset of the array which should
// be considered; by default the entire array is used. If x is already present
// in a, the insertion point will be before (to the left of) any existing
// entries. The return value is suitable for use as the first argument to
// `array.splice` assuming that a is already sorted.
//
// The returned insertion point i partitions the array a into two halves so that
// all v < x for v in a[lo:i] for the left side and all v >= x for v in a[i:hi]
// for the right side.
d3.bisectLeft = function(a, x, lo, hi) {
  if (arguments.length < 3) lo = 0;
  if (arguments.length < 4) hi = a.length;
  while (lo < hi) {
    var mid = (lo + hi) >> 1;
    if (a[mid] < x) lo = mid + 1;
    else hi = mid;
  }
  return lo;
};

// Similar to bisectLeft, but returns an insertion point which comes after (to
// the right of) any existing entries of x in a.
//
// The returned insertion point i partitions the array into two halves so that
// all v <= x for v in a[lo:i] for the left side and all v > x for v in a[i:hi]
// for the right side.
d3.bisect =
d3.bisectRight = function(a, x, lo, hi) {
  if (arguments.length < 3) lo = 0;
  if (arguments.length < 4) hi = a.length;
  while (lo < hi) {
    var mid = (lo + hi) >> 1;
    if (x < a[mid]) hi = mid;
    else lo = mid + 1;
  }
  return lo;
};
d3.first = function(array, f) {
  var i = 0,
      n = array.length,
      a = array[0],
      b;
  if (arguments.length === 1) f = d3.ascending;
  while (++i < n) {
    if (f.call(array, a, b = array[i]) > 0) {
      a = b;
    }
  }
  return a;
};
d3.last = function(array, f) {
  var i = 0,
      n = array.length,
      a = array[0],
      b;
  if (arguments.length === 1) f = d3.ascending;
  while (++i < n) {
    if (f.call(array, a, b = array[i]) <= 0) {
      a = b;
    }
  }
  return a;
};
d3.nest = function() {
  var nest = {},
      keys = [],
      sortKeys = [],
      sortValues,
      rollup;

  function map(array, depth) {
    if (depth >= keys.length) return rollup
        ? rollup.call(nest, array) : (sortValues
        ? array.sort(sortValues)
        : array);

    var i = -1,
        n = array.length,
        key = keys[depth++],
        keyValue,
        object,
        o = {};

    while (++i < n) {
      if ((keyValue = key(object = array[i])) in o) {
        o[keyValue].push(object);
      } else {
        o[keyValue] = [object];
      }
    }

    for (keyValue in o) {
      o[keyValue] = map(o[keyValue], depth);
    }

    return o;
  }

  function entries(map, depth) {
    if (depth >= keys.length) return map;

    var a = [],
        sortKey = sortKeys[depth++],
        key;

    for (key in map) {
      a.push({key: key, values: entries(map[key], depth)});
    }

    if (sortKey) a.sort(function(a, b) {
      return sortKey(a.key, b.key);
    });

    return a;
  }

  nest.map = function(array) {
    return map(array, 0);
  };

  nest.entries = function(array) {
    return entries(map(array, 0), 0);
  };

  nest.key = function(d) {
    keys.push(d);
    return nest;
  };

  // Specifies the order for the most-recently specified key.
  // Note: only applies to entries. Map keys are unordered!
  nest.sortKeys = function(order) {
    sortKeys[keys.length - 1] = order;
    return nest;
  };

  // Specifies the order for leaf values.
  // Applies to both maps and entries array.
  nest.sortValues = function(order) {
    sortValues = order;
    return nest;
  };

  nest.rollup = function(f) {
    rollup = f;
    return nest;
  };

  return nest;
};
d3.keys = function(map) {
  var keys = [];
  for (var key in map) keys.push(key);
  return keys;
};
d3.values = function(map) {
  var values = [];
  for (var key in map) values.push(map[key]);
  return values;
};
d3.entries = function(map) {
  var entries = [];
  for (var key in map) entries.push({key: key, value: map[key]});
  return entries;
};
d3.permute = function(array, indexes) {
  var permutes = [],
      i = -1,
      n = indexes.length;
  while (++i < n) permutes[i] = array[indexes[i]];
  return permutes;
};
d3.merge = function(arrays) {
  return Array.prototype.concat.apply([], arrays);
};
d3.split = function(array, f) {
  var arrays = [],
      values = [],
      value,
      i = -1,
      n = array.length;
  if (arguments.length < 2) f = d3_splitter;
  while (++i < n) {
    if (f.call(values, value = array[i], i)) {
      values = [];
    } else {
      if (!values.length) arrays.push(values);
      values.push(value);
    }
  }
  return arrays;
};

function d3_splitter(d) {
  return d == null;
}
function d3_collapse(s) {
  return s.replace(/(^\s+)|(\s+$)/g, "").replace(/\s+/g, " ");
}
/**
 * @param {number} start
 * @param {number=} stop
 * @param {number=} step
 */
d3.range = function(start, stop, step) {
  if (arguments.length < 3) {
    step = 1;
    if (arguments.length < 2) {
      stop = start;
      start = 0;
    }
  }
  if ((stop - start) / step == Infinity) throw new Error("infinite range");
  var range = [],
       i = -1,
       j;
  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);
  else while ((j = start + step * ++i) < stop) range.push(j);
  return range;
};
d3.requote = function(s) {
  return s.replace(d3_requote_re, "\\$&");
};

var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
d3.round = function(x, n) {
  return n
      ? Math.round(x * Math.pow(10, n)) * Math.pow(10, -n)
      : Math.round(x);
};
d3.xhr = function(url, mime, callback) {
  var req = new XMLHttpRequest;
  if (arguments.length < 3) callback = mime;
  else if (mime && req.overrideMimeType) req.overrideMimeType(mime);
  req.open("GET", url, true);
  req.onreadystatechange = function() {
    if (req.readyState === 4) callback(req.status < 300 ? req : null);
  };
  req.send(null);
};
d3.text = function(url, mime, callback) {
  function ready(req) {
    callback(req && req.responseText);
  }
  if (arguments.length < 3) {
    callback = mime;
    mime = null;
  }
  d3.xhr(url, mime, ready);
};
d3.json = function(url, callback) {
  d3.text(url, "application/json", function(text) {
    callback(text ? JSON.parse(text) : null);
  });
};
d3.html = function(url, callback) {
  d3.text(url, "text/html", function(text) {
    if (text != null) { // Treat empty string as valid HTML.
      var range = document.createRange();
      range.selectNode(document.body);
      text = range.createContextualFragment(text);
    }
    callback(text);
  });
};
d3.xml = function(url, mime, callback) {
  function ready(req) {
    callback(req && req.responseXML);
  }
  if (arguments.length < 3) {
    callback = mime;
    mime = null;
  }
  d3.xhr(url, mime, ready);
};
d3.ns = {

  prefix: {
    svg: "http://www.w3.org/2000/svg",
    xhtml: "http://www.w3.org/1999/xhtml",
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  },

  qualify: function(name) {
    var i = name.indexOf(":");
    return i < 0 ? name : {
      space: d3.ns.prefix[name.substring(0, i)],
      local: name.substring(i + 1)
    };
  }

};
d3.dispatch = function() {
  var dispatch = new d3_dispatch(),
      i = -1,
      n = arguments.length;
  while (++i < n) dispatch[arguments[i]] = d3_dispatch_event();
  return dispatch;
};

function d3_dispatch() {}

d3_dispatch.prototype.on = function(type, listener) {
  var i = type.indexOf("."),
      name = "";

  // Extract optional namespace, e.g., "click.foo"
  if (i > 0) {
    name = type.substring(i + 1);
    type = type.substring(0, i);
  }

  this[type].on(name, listener);
};

function d3_dispatch_event() {
  var listeners = [],
      listenerByName = {};

  function dispatch() {
    var z = listeners, // defensive reference
        i = -1,
        n = z.length,
        l;
    while (++i < n) if ((l = z[i])._on) l.apply(this, arguments);
  }

  dispatch.on = function(name, listener) {
    var l, i;

    // remove the old listener, if any
    if (l = listenerByName[name]) {
      l._on = false;
      listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
      delete listenerByName[name];
    }

    // add the new listener, if any
    if (listener) {
      listener._on = true;
      listeners.push(listener);
      listenerByName[name] = listener;
    }

    return dispatch;
  };

  return dispatch;
};
// TODO align
d3.format = function(specifier) {
  var match = d3_format_re.exec(specifier),
      fill = match[1] || " ",
      sign = match[3] || "",
      zfill = match[5],
      width = +match[6],
      comma = match[7],
      precision = match[8],
      type = match[9],
      scale = 1,
      suffix = "",
      integer = false;

  if (precision) precision = +precision.substring(1);

  if (zfill) {
    fill = "0"; // TODO align = "=";
    if (comma) width -= Math.floor((width - 1) / 4);
  }

  switch (type) {
    case "n": comma = true; type = "g"; break;
    case "%": scale = 100; suffix = "%"; type = "f"; break;
    case "p": scale = 100; suffix = "%"; type = "r"; break;
    case "d": integer = true; precision = 0; break;
    case "s": scale = -1; type = "r"; break;
  }

  // If no precision is specified for r, fallback to general notation.
  if (type == "r" && !precision) type = "g";

  type = d3_format_types[type] || d3_format_typeDefault;

  return function(value) {

    // Return the empty string for floats formatted as ints.
    if (integer && (value % 1)) return "";

    // Convert negative to positive, and record the sign prefix.
    var negative = (value < 0) && (value = -value) ? "\u2212" : sign;

    // Apply the scale, computing it from the value's exponent for si format.
    if (scale < 0) {
      var prefix = d3.formatPrefix(value, precision);
      value *= prefix.scale;
      suffix = prefix.symbol;
    } else {
      value *= scale;
    }

    // Convert to the desired precision.
    value = type(value, precision);

    // If the fill character is 0, the sign and group is applied after the fill.
    if (zfill) {
      var length = value.length + negative.length;
      if (length < width) value = new Array(width - length + 1).join(fill) + value;
      if (comma) value = d3_format_group(value);
      value = negative + value;
    }

    // Otherwise (e.g., space-filling), the sign and group is applied before.
    else {
      if (comma) value = d3_format_group(value);
      value = negative + value;
      var length = value.length;
      if (length < width) value = new Array(width - length + 1).join(fill) + value;
    }

    return value + suffix;
  };
};

// [[fill]align][sign][#][0][width][,][.precision][type]
var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?(#)?(0)?([0-9]+)?(,)?(\.[0-9]+)?([a-zA-Z%])?/;

var d3_format_types = {
  g: function(x, p) { return x.toPrecision(p); },
  e: function(x, p) { return x.toExponential(p); },
  f: function(x, p) { return x.toFixed(p); },
  r: function(x, p) { return d3.round(x, p = d3_format_precision(x, p)).toFixed(Math.max(0, Math.min(20, p))); }
};

function d3_format_precision(x, p) {
  return p - (x ? 1 + Math.floor(Math.log(x + Math.pow(10, 1 + Math.floor(Math.log(x) / Math.LN10) - p)) / Math.LN10) : 1);
}

function d3_format_typeDefault(x) {
  return x + "";
}

// Apply comma grouping for thousands.
function d3_format_group(value) {
  var i = value.lastIndexOf("."),
      f = i >= 0 ? value.substring(i) : (i = value.length, ""),
      t = [];
  while (i > 0) t.push(value.substring(i -= 3, i + 3));
  return t.reverse().join(",") + f;
}
var d3_formatPrefixes = ["y","z","a","f","p","n","μ","m","","k","M","G","T","P","E","Z","Y"].map(d3_formatPrefix);

d3.formatPrefix = function(value, precision) {
  var i = 0;
  if (value) {
    if (value < 0) value *= -1;
    if (precision) value = d3.round(value, d3_format_precision(value, precision));
    i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
    i = Math.max(-24, Math.min(24, Math.floor((i <= 0 ? i + 1 : i - 1) / 3) * 3));
  }
  return d3_formatPrefixes[8 + i / 3];
};

function d3_formatPrefix(d, i) {
  return {
    scale: Math.pow(10, (8 - i) * 3),
    symbol: d
  };
}

/*
 * TERMS OF USE - EASING EQUATIONS
 *
 * Open source under the BSD License.
 *
 * Copyright 2001 Robert Penner
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * - Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * - Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * - Neither the name of the author nor the names of contributors may be used to
 *   endorse or promote products derived from this software without specific
 *   prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

var d3_ease_quad = d3_ease_poly(2),
    d3_ease_cubic = d3_ease_poly(3);

var d3_ease = {
  linear: function() { return d3_ease_linear; },
  poly: d3_ease_poly,
  quad: function() { return d3_ease_quad; },
  cubic: function() { return d3_ease_cubic; },
  sin: function() { return d3_ease_sin; },
  exp: function() { return d3_ease_exp; },
  circle: function() { return d3_ease_circle; },
  elastic: d3_ease_elastic,
  back: d3_ease_back,
  bounce: function() { return d3_ease_bounce; }
};

var d3_ease_mode = {
  "in": function(f) { return f; },
  "out": d3_ease_reverse,
  "in-out": d3_ease_reflect,
  "out-in": function(f) { return d3_ease_reflect(d3_ease_reverse(f)); }
};

d3.ease = function(name) {
  var i = name.indexOf("-"),
      t = i >= 0 ? name.substring(0, i) : name,
      m = i >= 0 ? name.substring(i + 1) : "in";
  return d3_ease_clamp(d3_ease_mode[m](d3_ease[t].apply(null, Array.prototype.slice.call(arguments, 1))));
};

function d3_ease_clamp(f) {
  return function(t) {
    return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
  };
}

function d3_ease_reverse(f) {
  return function(t) {
    return 1 - f(1 - t);
  };
}

function d3_ease_reflect(f) {
  return function(t) {
    return .5 * (t < .5 ? f(2 * t) : (2 - f(2 - 2 * t)));
  };
}

function d3_ease_linear(t) {
  return t;
}

function d3_ease_poly(e) {
  return function(t) {
    return Math.pow(t, e);
  }
}

function d3_ease_sin(t) {
  return 1 - Math.cos(t * Math.PI / 2);
}

function d3_ease_exp(t) {
  return Math.pow(2, 10 * (t - 1));
}

function d3_ease_circle(t) {
  return 1 - Math.sqrt(1 - t * t);
}

function d3_ease_elastic(a, p) {
  var s;
  if (arguments.length < 2) p = 0.45;
  if (arguments.length < 1) { a = 1; s = p / 4; }
  else s = p / (2 * Math.PI) * Math.asin(1 / a);
  return function(t) {
    return 1 + a * Math.pow(2, 10 * -t) * Math.sin((t - s) * 2 * Math.PI / p);
  };
}

function d3_ease_back(s) {
  if (!s) s = 1.70158;
  return function(t) {
    return t * t * ((s + 1) * t - s);
  };
}

function d3_ease_bounce(t) {
  return t < 1 / 2.75 ? 7.5625 * t * t
      : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75
      : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375
      : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
}
d3.event = null;

function d3_eventCancel() {
  d3.event.stopPropagation();
  d3.event.preventDefault();
}
d3.interpolate = function(a, b) {
  var i = d3.interpolators.length, f;
  while (--i >= 0 && !(f = d3.interpolators[i](a, b)));
  return f;
};

d3.interpolateNumber = function(a, b) {
  b -= a;
  return function(t) { return a + b * t; };
};

d3.interpolateRound = function(a, b) {
  b -= a;
  return function(t) { return Math.round(a + b * t); };
};

d3.interpolateString = function(a, b) {
  var m, // current match
      i, // current index
      j, // current index (for coallescing)
      s0 = 0, // start index of current string prefix
      s1 = 0, // end index of current string prefix
      s = [], // string constants and placeholders
      q = [], // number interpolators
      n, // q.length
      o;

  // Reset our regular expression!
  d3_interpolate_number.lastIndex = 0;

  // Find all numbers in b.
  for (i = 0; m = d3_interpolate_number.exec(b); ++i) {
    if (m.index) s.push(b.substring(s0, s1 = m.index));
    q.push({i: s.length, x: m[0]});
    s.push(null);
    s0 = d3_interpolate_number.lastIndex;
  }
  if (s0 < b.length) s.push(b.substring(s0));

  // Find all numbers in a.
  for (i = 0, n = q.length; (m = d3_interpolate_number.exec(a)) && i < n; ++i) {
    o = q[i];
    if (o.x == m[0]) { // The numbers match, so coallesce.
      if (o.i) {
        if (s[o.i + 1] == null) { // This match is followed by another number.
          s[o.i - 1] += o.x;
          s.splice(o.i, 1);
          for (j = i + 1; j < n; ++j) q[j].i--;
        } else { // This match is followed by a string, so coallesce twice.
          s[o.i - 1] += o.x + s[o.i + 1];
          s.splice(o.i, 2);
          for (j = i + 1; j < n; ++j) q[j].i -= 2;
        }
      } else {
          if (s[o.i + 1] == null) { // This match is followed by another number.
          s[o.i] = o.x;
        } else { // This match is followed by a string, so coallesce twice.
          s[o.i] = o.x + s[o.i + 1];
          s.splice(o.i + 1, 1);
          for (j = i + 1; j < n; ++j) q[j].i--;
        }
      }
      q.splice(i, 1);
      n--;
      i--;
    } else {
      o.x = d3.interpolateNumber(parseFloat(m[0]), parseFloat(o.x));
    }
  }

  // Remove any numbers in b not found in a.
  while (i < n) {
    o = q.pop();
    if (s[o.i + 1] == null) { // This match is followed by another number.
      s[o.i] = o.x;
    } else { // This match is followed by a string, so coallesce twice.
      s[o.i] = o.x + s[o.i + 1];
      s.splice(o.i + 1, 1);
    }
    n--;
  }

  // Special optimization for only a single match.
  if (s.length === 1) {
    return s[0] == null ? q[0].x : function() { return b; };
  }

  // Otherwise, interpolate each of the numbers and rejoin the string.
  return function(t) {
    for (i = 0; i < n; ++i) s[(o = q[i]).i] = o.x(t);
    return s.join("");
  };
};

d3.interpolateTransform = function(a, b) {
  return d3.interpolateString(d3.transform(a) + "", d3.transform(b) + "");
};

d3.interpolateRgb = function(a, b) {
  a = d3.rgb(a);
  b = d3.rgb(b);
  var ar = a.r,
      ag = a.g,
      ab = a.b,
      br = b.r - ar,
      bg = b.g - ag,
      bb = b.b - ab;
  return function(t) {
    return "#"
        + d3_rgb_hex(Math.round(ar + br * t))
        + d3_rgb_hex(Math.round(ag + bg * t))
        + d3_rgb_hex(Math.round(ab + bb * t));
  };
};

// interpolates HSL space, but outputs RGB string (for compatibility)
d3.interpolateHsl = function(a, b) {
  a = d3.hsl(a);
  b = d3.hsl(b);
  var h0 = a.h,
      s0 = a.s,
      l0 = a.l,
      h1 = b.h - h0,
      s1 = b.s - s0,
      l1 = b.l - l0;
  return function(t) {
    return d3_hsl_rgb(h0 + h1 * t, s0 + s1 * t, l0 + l1 * t).toString();
  };
};

d3.interpolateArray = function(a, b) {
  var x = [],
      c = [],
      na = a.length,
      nb = b.length,
      n0 = Math.min(a.length, b.length),
      i;
  for (i = 0; i < n0; ++i) x.push(d3.interpolate(a[i], b[i]));
  for (; i < na; ++i) c[i] = a[i];
  for (; i < nb; ++i) c[i] = b[i];
  return function(t) {
    for (i = 0; i < n0; ++i) c[i] = x[i](t);
    return c;
  };
};

d3.interpolateObject = function(a, b) {
  var i = {},
      c = {},
      k;
  for (k in a) {
    if (k in b) {
      i[k] = d3_interpolateByName(k)(a[k], b[k]);
    } else {
      c[k] = a[k];
    }
  }
  for (k in b) {
    if (!(k in a)) {
      c[k] = b[k];
    }
  }
  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
}

var d3_interpolate_number = /[-+]?(?:\d*\.?\d+)(?:[eE][-+]?\d+)?/g;

function d3_interpolateByName(n) {
  return n == "transform"
      ? d3.interpolateTransform
      : d3.interpolate;
}

d3.interpolators = [
  d3.interpolateObject,
  function(a, b) { return (b instanceof Array) && d3.interpolateArray(a, b); },
  function(a, b) { return (typeof b === "string") && d3.interpolateString(a + "", b); },
  function(a, b) { return (typeof b === "string" ? b in d3_rgb_names || /^(#|rgb\(|hsl\()/.test(b) : b instanceof d3_Rgb || b instanceof d3_Hsl) && d3.interpolateRgb(a + "", b); },
  function(a, b) { return (typeof b === "number") && d3.interpolateNumber(+a, b); }
];
function d3_uninterpolateNumber(a, b) {
  b = b - (a = +a) ? 1 / (b - a) : 0;
  return function(x) { return (x - a) * b; };
}

function d3_uninterpolateClamp(a, b) {
  b = b - (a = +a) ? 1 / (b - a) : 0;
  return function(x) { return Math.max(0, Math.min(1, (x - a) * b)); };
}
d3.rgb = function(r, g, b) {
  return arguments.length === 1
      ? (r instanceof d3_Rgb ? d3_rgb(r.r, r.g, r.b)
      : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb))
      : d3_rgb(~~r, ~~g, ~~b);
};

function d3_rgb(r, g, b) {
  return new d3_Rgb(r, g, b);
}

function d3_Rgb(r, g, b) {
  this.r = r;
  this.g = g;
  this.b = b;
}

d3_Rgb.prototype.brighter = function(k) {
  k = Math.pow(0.7, arguments.length ? k : 1);
  var r = this.r,
      g = this.g,
      b = this.b,
      i = 30;
  if (!r && !g && !b) return d3_rgb(i, i, i);
  if (r && r < i) r = i;
  if (g && g < i) g = i;
  if (b && b < i) b = i;
  return d3_rgb(
      Math.min(255, Math.floor(r / k)),
      Math.min(255, Math.floor(g / k)),
      Math.min(255, Math.floor(b / k)));
};

d3_Rgb.prototype.darker = function(k) {
  k = Math.pow(0.7, arguments.length ? k : 1);
  return d3_rgb(
      Math.floor(k * this.r),
      Math.floor(k * this.g),
      Math.floor(k * this.b));
};

d3_Rgb.prototype.hsl = function() {
  return d3_rgb_hsl(this.r, this.g, this.b);
};

d3_Rgb.prototype.toString = function() {
  return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
};

function d3_rgb_hex(v) {
  return v < 0x10
      ? "0" + Math.max(0, v).toString(16)
      : Math.min(255, v).toString(16);
}

function d3_rgb_parse(format, rgb, hsl) {
  var r = 0, // red channel; int in [0, 255]
      g = 0, // green channel; int in [0, 255]
      b = 0, // blue channel; int in [0, 255]
      m1, // CSS color specification match
      m2, // CSS color specification type (e.g., rgb)
      name;

  /* Handle hsl, rgb. */
  m1 = /([a-z]+)\((.*)\)/i.exec(format);
  if (m1) {
    m2 = m1[2].split(",");
    switch (m1[1]) {
      case "hsl": {
        return hsl(
          parseFloat(m2[0]), // degrees
          parseFloat(m2[1]) / 100, // percentage
          parseFloat(m2[2]) / 100 // percentage
        );
      }
      case "rgb": {
        return rgb(
          d3_rgb_parseNumber(m2[0]),
          d3_rgb_parseNumber(m2[1]),
          d3_rgb_parseNumber(m2[2])
        );
      }
    }
  }

  /* Named colors. */
  if (name = d3_rgb_names[format]) return rgb(name.r, name.g, name.b);

  /* Hexadecimal colors: #rgb and #rrggbb. */
  if (format != null && format.charAt(0) === "#") {
    if (format.length === 4) {
      r = format.charAt(1); r += r;
      g = format.charAt(2); g += g;
      b = format.charAt(3); b += b;
    } else if (format.length === 7) {
      r = format.substring(1, 3);
      g = format.substring(3, 5);
      b = format.substring(5, 7);
    }
    r = parseInt(r, 16);
    g = parseInt(g, 16);
    b = parseInt(b, 16);
  }

  return rgb(r, g, b);
}

function d3_rgb_hsl(r, g, b) {
  var min = Math.min(r /= 255, g /= 255, b /= 255),
      max = Math.max(r, g, b),
      d = max - min,
      h,
      s,
      l = (max + min) / 2;
  if (d) {
    s = l < .5 ? d / (max + min) : d / (2 - max - min);
    if (r == max) h = (g - b) / d + (g < b ? 6 : 0);
    else if (g == max) h = (b - r) / d + 2;
    else h = (r - g) / d + 4;
    h *= 60;
  } else {
    s = h = 0;
  }
  return d3_hsl(h, s, l);
}

function d3_rgb_parseNumber(c) { // either integer or percentage
  var f = parseFloat(c);
  return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
}

var d3_rgb_names = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  gold: "#ffd700",
  goldenrod: "#daa520",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavender: "#e6e6fa",
  lavenderblush: "#fff0f5",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};

for (var d3_rgb_name in d3_rgb_names) {
  d3_rgb_names[d3_rgb_name] = d3_rgb_parse(
      d3_rgb_names[d3_rgb_name],
      d3_rgb,
      d3_hsl_rgb);
}
d3.hsl = function(h, s, l) {
  return arguments.length === 1
      ? (h instanceof d3_Hsl ? d3_hsl(h.h, h.s, h.l)
      : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl))
      : d3_hsl(+h, +s, +l);
};

function d3_hsl(h, s, l) {
  return new d3_Hsl(h, s, l);
}

function d3_Hsl(h, s, l) {
  this.h = h;
  this.s = s;
  this.l = l;
}

d3_Hsl.prototype.brighter = function(k) {
  k = Math.pow(0.7, arguments.length ? k : 1);
  return d3_hsl(this.h, this.s, this.l / k);
};

d3_Hsl.prototype.darker = function(k) {
  k = Math.pow(0.7, arguments.length ? k : 1);
  return d3_hsl(this.h, this.s, k * this.l);
};

d3_Hsl.prototype.rgb = function() {
  return d3_hsl_rgb(this.h, this.s, this.l);
};

d3_Hsl.prototype.toString = function() {
  return this.rgb().toString();
};

function d3_hsl_rgb(h, s, l) {
  var m1,
      m2;

  /* Some simple corrections for h, s and l. */
  h = h % 360; if (h < 0) h += 360;
  s = s < 0 ? 0 : s > 1 ? 1 : s;
  l = l < 0 ? 0 : l > 1 ? 1 : l;

  /* From FvD 13.37, CSS Color Module Level 3 */
  m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
  m1 = 2 * l - m2;

  function v(h) {
    if (h > 360) h -= 360;
    else if (h < 0) h += 360;
    if (h < 60) return m1 + (m2 - m1) * h / 60;
    if (h < 180) return m2;
    if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
    return m1;
  }

  function vv(h) {
    return Math.round(v(h) * 255);
  }

  return d3_rgb(vv(h + 120), vv(h), vv(h - 120));
}
function d3_selection(groups) {
  d3_arraySubclass(groups, d3_selectionPrototype);
  return groups;
}

var d3_select = function(s, n) { return n.querySelector(s); },
    d3_selectAll = function(s, n) { return n.querySelectorAll(s); };

// Prefer Sizzle, if available.
if (typeof Sizzle === "function") {
  d3_select = function(s, n) { return Sizzle(s, n)[0]; };
  d3_selectAll = function(s, n) { return Sizzle.uniqueSort(Sizzle(s, n)); };
}

var d3_selectionPrototype = [];

d3.selection = function() {
  return d3_selectionRoot;
};

d3.selection.prototype = d3_selectionPrototype;
d3_selectionPrototype.select = function(selector) {
  var subgroups = [],
      subgroup,
      subnode,
      group,
      node;

  if (typeof selector !== "function") selector = d3_selection_selector(selector);

  for (var j = -1, m = this.length; ++j < m;) {
    subgroups.push(subgroup = []);
    subgroup.parentNode = (group = this[j]).parentNode;
    for (var i = -1, n = group.length; ++i < n;) {
      if (node = group[i]) {
        subgroup.push(subnode = selector.call(node, node.__data__, i));
        if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
      } else {
        subgroup.push(null);
      }
    }
  }

  return d3_selection(subgroups);
};

function d3_selection_selector(selector) {
  return function() {
    return d3_select(selector, this);
  };
}
d3_selectionPrototype.selectAll = function(selector) {
  var subgroups = [],
      subgroup,
      node;

  if (typeof selector !== "function") selector = d3_selection_selectorAll(selector);

  for (var j = -1, m = this.length; ++j < m;) {
    for (var group = this[j], i = -1, n = group.length; ++i < n;) {
      if (node = group[i]) {
        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i)));
        subgroup.parentNode = node;
      }
    }
  }

  return d3_selection(subgroups);
};

function d3_selection_selectorAll(selector) {
  return function() {
    return d3_selectAll(selector, this);
  };
}
d3_selectionPrototype.attr = function(name, value) {
  name = d3.ns.qualify(name);

  // If no value is specified, return the first value.
  if (arguments.length < 2) {
    var node = this.node();
    return name.local
        ? node.getAttributeNS(name.space, name.local)
        : node.getAttribute(name);
  }

  function attrNull() {
    this.removeAttribute(name);
  }

  function attrNullNS() {
    this.removeAttributeNS(name.space, name.local);
  }

  function attrConstant() {
    this.setAttribute(name, value);
  }

  function attrConstantNS() {
    this.setAttributeNS(name.space, name.local, value);
  }

  function attrFunction() {
    var x = value.apply(this, arguments);
    if (x == null) this.removeAttribute(name);
    else this.setAttribute(name, x);
  }

  function attrFunctionNS() {
    var x = value.apply(this, arguments);
    if (x == null) this.removeAttributeNS(name.space, name.local);
    else this.setAttributeNS(name.space, name.local, x);
  }

  return this.each(value == null
      ? (name.local ? attrNullNS : attrNull) : (typeof value === "function"
      ? (name.local ? attrFunctionNS : attrFunction)
      : (name.local ? attrConstantNS : attrConstant)));
};
d3_selectionPrototype.classed = function(name, value) {
  var names = name.split(d3_selection_classedWhitespace),
      n = names.length,
      i = -1;
  if (arguments.length > 1) {
    while (++i < n) d3_selection_classed.call(this, names[i], value);
    return this;
  } else {
    while (++i < n) if (!d3_selection_classed.call(this, names[i])) return false;
    return true;
  }
};

var d3_selection_classedWhitespace = /\s+/g;

function d3_selection_classed(name, value) {
  var re = new RegExp("(^|\\s+)" + d3.requote(name) + "(\\s+|$)", "g");

  // If no value is specified, return the first value.
  if (arguments.length < 2) {
    var node = this.node();
    if (c = node.classList) return c.contains(name);
    var c = node.className;
    re.lastIndex = 0;
    return re.test(c.baseVal != null ? c.baseVal : c);
  }

  function classedAdd() {
    if (c = this.classList) return c.add(name);
    var c = this.className,
        cb = c.baseVal != null,
        cv = cb ? c.baseVal : c;
    re.lastIndex = 0;
    if (!re.test(cv)) {
      cv = d3_collapse(cv + " " + name);
      if (cb) c.baseVal = cv;
      else this.className = cv;
    }
  }

  function classedRemove() {
    if (c = this.classList) return c.remove(name);
    var c = this.className,
        cb = c.baseVal != null,
        cv = cb ? c.baseVal : c;
    cv = d3_collapse(cv.replace(re, " "));
    if (cb) c.baseVal = cv;
    else this.className = cv;
  }

  function classedFunction() {
    (value.apply(this, arguments)
        ? classedAdd
        : classedRemove).call(this);
  }

  return this.each(typeof value === "function"
      ? classedFunction : value
      ? classedAdd
      : classedRemove);
}
d3_selectionPrototype.style = function(name, value, priority) {
  if (arguments.length < 3) priority = "";

  // If no value is specified, return the first value.
  if (arguments.length < 2) return window
      .getComputedStyle(this.node(), null)
      .getPropertyValue(name);

  function styleNull() {
    this.style.removeProperty(name);
  }

  function styleConstant() {
    this.style.setProperty(name, value, priority);
  }

  function styleFunction() {
    var x = value.apply(this, arguments);
    if (x == null) this.style.removeProperty(name);
    else this.style.setProperty(name, x, priority);
  }

  return this.each(value == null
      ? styleNull : (typeof value === "function"
      ? styleFunction : styleConstant));
};
d3_selectionPrototype.property = function(name, value) {

  // If no value is specified, return the first value.
  if (arguments.length < 2) return this.node()[name];

  function propertyNull() {
    delete this[name];
  }

  function propertyConstant() {
    this[name] = value;
  }

  function propertyFunction() {
    var x = value.apply(this, arguments);
    if (x == null) delete this[name];
    else this[name] = x;
  }

  return this.each(value == null
      ? propertyNull : (typeof value === "function"
      ? propertyFunction : propertyConstant));
};
d3_selectionPrototype.text = function(value) {
  return arguments.length < 1 ? this.node().textContent
      : (this.each(typeof value === "function"
      ? function() { this.textContent = value.apply(this, arguments); }
      : function() { this.textContent = value; }));
};
d3_selectionPrototype.html = function(value) {
  return arguments.length < 1 ? this.node().innerHTML
      : (this.each(typeof value === "function"
      ? function() { this.innerHTML = value.apply(this, arguments); }
      : function() { this.innerHTML = value; }));
};
// TODO append(node)?
// TODO append(function)?
d3_selectionPrototype.append = function(name) {
  name = d3.ns.qualify(name);

  function append() {
    return this.appendChild(document.createElement(name));
  }

  function appendNS() {
    return this.appendChild(document.createElementNS(name.space, name.local));
  }

  return this.select(name.local ? appendNS : append);
};
// TODO insert(node, function)?
// TODO insert(function, string)?
// TODO insert(function, function)?
d3_selectionPrototype.insert = function(name, before) {
  name = d3.ns.qualify(name);

  function insert() {
    return this.insertBefore(
        document.createElement(name),
        d3_select(before, this));
  }

  function insertNS() {
    return this.insertBefore(
        document.createElementNS(name.space, name.local),
        d3_select(before, this));
  }

  return this.select(name.local ? insertNS : insert);
};
// TODO remove(selector)?
// TODO remove(node)?
// TODO remove(function)?
d3_selectionPrototype.remove = function() {
  return this.each(function() {
    var parent = this.parentNode;
    if (parent) parent.removeChild(this);
  });
};
// TODO data(null) for clearing data?
d3_selectionPrototype.data = function(data, join) {
  var enter = [],
      update = [],
      exit = [];

  function bind(group, groupData) {
    var i,
        n = group.length,
        m = groupData.length,
        n0 = Math.min(n, m),
        n1 = Math.max(n, m),
        updateNodes = [],
        enterNodes = [],
        exitNodes = [],
        node,
        nodeData;

    if (join) {
      var nodeByKey = {},
          keys = [],
          key,
          j = groupData.length;

      for (i = -1; ++i < n;) {
        key = join.call(node = group[i], node.__data__, i);
        if (key in nodeByKey) {
          exitNodes[j++] = node; // duplicate key
        } else {
          nodeByKey[key] = node;
        }
        keys.push(key);
      }

      for (i = -1; ++i < m;) {
        node = nodeByKey[key = join.call(groupData, nodeData = groupData[i], i)];
        if (node) {
          node.__data__ = nodeData;
          updateNodes[i] = node;
          enterNodes[i] = exitNodes[i] = null;
        } else {
          enterNodes[i] = d3_selection_dataNode(nodeData);
          updateNodes[i] = exitNodes[i] = null;
        }
        delete nodeByKey[key];
      }

      for (i = -1; ++i < n;) {
        if (keys[i] in nodeByKey) {
          exitNodes[i] = group[i];
        }
      }
    } else {
      for (i = -1; ++i < n0;) {
        node = group[i];
        nodeData = groupData[i];
        if (node) {
          node.__data__ = nodeData;
          updateNodes[i] = node;
          enterNodes[i] = exitNodes[i] = null;
        } else {
          enterNodes[i] = d3_selection_dataNode(nodeData);
          updateNodes[i] = exitNodes[i] = null;
        }
      }
      for (; i < m; ++i) {
        enterNodes[i] = d3_selection_dataNode(groupData[i]);
        updateNodes[i] = exitNodes[i] = null;
      }
      for (; i < n1; ++i) {
        exitNodes[i] = group[i];
        enterNodes[i] = updateNodes[i] = null;
      }
    }

    enterNodes.update
        = updateNodes;

    enterNodes.parentNode
        = updateNodes.parentNode
        = exitNodes.parentNode
        = group.parentNode;

    enter.push(enterNodes);
    update.push(updateNodes);
    exit.push(exitNodes);
  }

  var i = -1,
      n = this.length,
      group;
  if (typeof data === "function") {
    while (++i < n) {
      bind(group = this[i], data.call(group, group.parentNode.__data__, i));
    }
  } else {
    while (++i < n) {
      bind(group = this[i], data);
    }
  }

  var selection = d3_selection(update);
  selection.enter = function() { return d3_selection_enter(enter); };
  selection.exit = function() { return d3_selection(exit); };
  return selection;
};

function d3_selection_dataNode(data) {
  return {__data__: data};
}
// TODO preserve null elements to maintain index?
d3_selectionPrototype.filter = function(filter) {
  var subgroups = [],
      subgroup,
      group,
      node;

  for (var j = 0, m = this.length; j < m; j++) {
    subgroups.push(subgroup = []);
    subgroup.parentNode = (group = this[j]).parentNode;
    for (var i = 0, n = group.length; i < n; i++) {
      if ((node = group[i]) && filter.call(node, node.__data__, i)) {
        subgroup.push(node);
      }
    }
  }

  return d3_selection(subgroups);
};
d3_selectionPrototype.map = function(map) {
  return this.each(function() {
    this.__data__ = map.apply(this, arguments);
  });
};
d3_selectionPrototype.sort = function(comparator) {
  comparator = d3_selection_sortComparator.apply(this, arguments);
  for (var j = 0, m = this.length; j < m; j++) {
    for (var group = this[j].sort(comparator), i = 1, n = group.length, prev = group[0]; i < n; i++) {
      var node = group[i];
      if (node) {
        if (prev) prev.parentNode.insertBefore(node, prev.nextSibling);
        prev = node;
      }
    }
  }
  return this;
};

function d3_selection_sortComparator(comparator) {
  if (!arguments.length) comparator = d3.ascending;
  return function(a, b) {
    return comparator(a && a.__data__, b && b.__data__);
  };
}
// type can be namespaced, e.g., "click.foo"
// listener can be null for removal
d3_selectionPrototype.on = function(type, listener, capture) {
  if (arguments.length < 3) capture = false;

  // parse the type specifier
  var name = "__on" + type, i = type.indexOf(".");
  if (i > 0) type = type.substring(0, i);

  // if called with only one argument, return the current listener
  if (arguments.length < 2) return (i = this.node()[name]) && i._;

  // remove the old event listener, and add the new event listener
  return this.each(function(d, i) {
    var node = this;

    if (node[name]) node.removeEventListener(type, node[name], capture);
    if (listener) node.addEventListener(type, node[name] = l, capture);

    // wrapped event listener that preserves i
    function l(e) {
      var o = d3.event; // Events can be reentrant (e.g., focus).
      d3.event = e;
      try {
        listener.call(node, node.__data__, i);
      } finally {
        d3.event = o;
      }
    }

    // stash the unwrapped listener for retrieval
    l._ = listener;
  });
};
d3_selectionPrototype.each = function(callback) {
  for (var j = -1, m = this.length; ++j < m;) {
    for (var group = this[j], i = -1, n = group.length; ++i < n;) {
      var node = group[i];
      if (node) callback.call(node, node.__data__, i, j);
    }
  }
  return this;
};
//
// Note: assigning to the arguments array simultaneously changes the value of
// the corresponding argument!
//
// TODO The `this` argument probably shouldn't be the first argument to the
// callback, anyway, since it's redundant. However, that will require a major
// version bump due to backwards compatibility, so I'm not changing it right
// away.
//
d3_selectionPrototype.call = function(callback) {
  callback.apply(this, (arguments[0] = this, arguments));
  return this;
};
d3_selectionPrototype.empty = function() {
  return !this.node();
};
d3_selectionPrototype.node = function(callback) {
  for (var j = 0, m = this.length; j < m; j++) {
    for (var group = this[j], i = 0, n = group.length; i < n; i++) {
      var node = group[i];
      if (node) return node;
    }
  }
  return null;
};
d3_selectionPrototype.transition = function() {
  var subgroups = [],
      subgroup,
      node;

  for (var j = -1, m = this.length; ++j < m;) {
    subgroups.push(subgroup = []);
    for (var group = this[j], i = -1, n = group.length; ++i < n;) {
      subgroup.push((node = group[i]) ? {node: node, delay: 0, duration: 250} : null);
    }
  }

  return d3_transition(subgroups, d3_transitionInheritId || ++d3_transitionId, Date.now());
};
var d3_selectionRoot = d3_selection([[document]]);

d3_selectionRoot[0].parentNode = document.documentElement;

// TODO fast singleton implementation!
// TODO select(function)
d3.select = function(selector) {
  return typeof selector === "string"
      ? d3_selectionRoot.select(selector)
      : d3_selection([[selector]]); // assume node
};

// TODO selectAll(function)
d3.selectAll = function(selector) {
  return typeof selector === "string"
      ? d3_selectionRoot.selectAll(selector)
      : d3_selection([d3_array(selector)]); // assume node[]
};
function d3_selection_enter(selection) {
  d3_arraySubclass(selection, d3_selection_enterPrototype);
  return selection;
}

var d3_selection_enterPrototype = [];

d3_selection_enterPrototype.append = d3_selectionPrototype.append;
d3_selection_enterPrototype.insert = d3_selectionPrototype.insert;
d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
d3_selection_enterPrototype.node = d3_selectionPrototype.node;
d3_selection_enterPrototype.select = function(selector) {
  var subgroups = [],
      subgroup,
      subnode,
      upgroup,
      group,
      node;

  for (var j = -1, m = this.length; ++j < m;) {
    upgroup = (group = this[j]).update;
    subgroups.push(subgroup = []);
    subgroup.parentNode = group.parentNode;
    for (var i = -1, n = group.length; ++i < n;) {
      if (node = group[i]) {
        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i));
        subnode.__data__ = node.__data__;
      } else {
        subgroup.push(null);
      }
    }
  }

  return d3_selection(subgroups);
};
function d3_transition(groups, id, time) {
  d3_arraySubclass(groups, d3_transitionPrototype);

  var tweens = {},
      event = d3.dispatch("start", "end"),
      ease = d3_transitionEase;

  groups.id = id;

  groups.time = time;

  groups.tween = function(name, tween) {
    if (arguments.length < 2) return tweens[name];
    if (tween == null) delete tweens[name];
    else tweens[name] = tween;
    return groups;
  };

  groups.ease = function(value) {
    if (!arguments.length) return ease;
    ease = typeof value === "function" ? value : d3.ease.apply(d3, arguments);
    return groups;
  };

  groups.each = function(type, listener) {
    if (arguments.length < 2) return d3_transition_each.call(groups, type);
    event.on(type, listener);
    return groups;
  };

  d3.timer(function(elapsed) {
    groups.each(function(d, i, j) {
      var tweened = [],
          node = this,
          delay = groups[j][i].delay,
          duration = groups[j][i].duration,
          lock = node.__transition__ || (node.__transition__ = {active: 0, count: 0});

      ++lock.count;

      delay <= elapsed ? start(elapsed) : d3.timer(start, delay, time);

      function start(elapsed) {
        if (lock.active > id) return stop();
        lock.active = id;

        for (var tween in tweens) {
          if (tween = tweens[tween].call(node, d, i)) {
            tweened.push(tween);
          }
        }

        event.start.call(node, d, i);
        if (!tick(elapsed)) d3.timer(tick, 0, time);
        return 1;
      }

      function tick(elapsed) {
        if (lock.active !== id) return stop();

        var t = (elapsed - delay) / duration,
            e = ease(t),
            n = tweened.length;

        while (n > 0) {
          tweened[--n].call(node, e);
        }

        if (t >= 1) {
          stop();
          d3_transitionInheritId = id;
          event.end.call(node, d, i);
          d3_transitionInheritId = 0;
          return 1;
        }
      }

      function stop() {
        if (!--lock.count) delete node.__transition__;
        return 1;
      }
    });
    return 1;
  }, 0, time);

  return groups;
}

var d3_transitionRemove = {};

function d3_transitionNull(d, i, a) {
  return a != "" && d3_transitionRemove;
}

function d3_transitionTween(name, b) {
  var interpolate = d3_interpolateByName(name);

  function transitionFunction(d, i, a) {
    var v = b.call(this, d, i);
    return v == null
        ? a != "" && d3_transitionRemove
        : a != v && interpolate(a, v);
  }

  function transitionString(d, i, a) {
    return a != b && interpolate(a, b);
  }

  return typeof b === "function" ? transitionFunction
      : b == null ? d3_transitionNull
      : (b += "", transitionString);
}

var d3_transitionPrototype = [],
    d3_transitionId = 0,
    d3_transitionInheritId = 0,
    d3_transitionEase = d3.ease("cubic-in-out");

d3_transitionPrototype.call = d3_selectionPrototype.call;

d3.transition = function() {
  return d3_selectionRoot.transition();
};

d3.transition.prototype = d3_transitionPrototype;
d3_transitionPrototype.select = function(selector) {
  var subgroups = [],
      subgroup,
      subnode,
      node;

  if (typeof selector !== "function") selector = d3_selection_selector(selector);

  for (var j = -1, m = this.length; ++j < m;) {
    subgroups.push(subgroup = []);
    for (var group = this[j], i = -1, n = group.length; ++i < n;) {
      if ((node = group[i]) && (subnode = selector.call(node.node, node.node.__data__, i))) {
        if ("__data__" in node.node) subnode.__data__ = node.node.__data__;
        subgroup.push({node: subnode, delay: node.delay, duration: node.duration});
      } else {
        subgroup.push(null);
      }
    }
  }

  return d3_transition(subgroups, this.id, this.time).ease(this.ease());
};
d3_transitionPrototype.selectAll = function(selector) {
  var subgroups = [],
      subgroup,
      subnodes,
      node;

  if (typeof selector !== "function") selector = d3_selection_selectorAll(selector);

  for (var j = -1, m = this.length; ++j < m;) {
    for (var group = this[j], i = -1, n = group.length; ++i < n;) {
      if (node = group[i]) {
        subnodes = selector.call(node.node, node.node.__data__, i);
        subgroups.push(subgroup = []);
        for (var k = -1, o = subnodes.length; ++k < o;) {
          subgroup.push({node: subnodes[k], delay: node.delay, duration: node.duration});
        }
      }
    }
  }

  return d3_transition(subgroups, this.id, this.time).ease(this.ease());
};
d3_transitionPrototype.attr = function(name, value) {
  return this.attrTween(name, d3_transitionTween(name, value));
};

d3_transitionPrototype.attrTween = function(nameNS, tween) {
  var name = d3.ns.qualify(nameNS);

  function attrTween(d, i) {
    var f = tween.call(this, d, i, this.getAttribute(name));
    return f === d3_transitionRemove
        ? (this.removeAttribute(name), null)
        : f && function(t) { this.setAttribute(name, f(t)); };
  }

  function attrTweenNS(d, i) {
    var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
    return f === d3_transitionRemove
        ? (this.removeAttributeNS(name.space, name.local), null)
        : f && function(t) { this.setAttributeNS(name.space, name.local, f(t)); };
  }

  return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
};
d3_transitionPrototype.style = function(name, value, priority) {
  if (arguments.length < 3) priority = "";
  return this.styleTween(name, d3_transitionTween(name, value), priority);
};

d3_transitionPrototype.styleTween = function(name, tween, priority) {
  if (arguments.length < 3) priority = "";
  return this.tween("style." + name, function(d, i) {
    var f = tween.call(this, d, i, window.getComputedStyle(this, null).getPropertyValue(name));
    return f === d3_transitionRemove
        ? (this.style.removeProperty(name), null)
        : f && function(t) { this.style.setProperty(name, f(t), priority); };
  });
};
d3_transitionPrototype.text = function(value) {
  return this.tween("text", function(d, i) {
    this.textContent = typeof value === "function"
        ? value.call(this, d, i)
        : value;
  });
};
d3_transitionPrototype.remove = function() {
  return this.each("end", function() {
    var p;
    if (!this.__transition__ && (p = this.parentNode)) p.removeChild(this);
  });
};
d3_transitionPrototype.delay = function(value) {
  var groups = this;
  return groups.each(typeof value === "function"
      ? function(d, i, j) { groups[j][i].delay = +value.apply(this, arguments); }
      : (value = +value, function(d, i, j) { groups[j][i].delay = value; }));
};
d3_transitionPrototype.duration = function(value) {
  var groups = this;
  return groups.each(typeof value === "function"
      ? function(d, i, j) { groups[j][i].duration = +value.apply(this, arguments); }
      : (value = +value, function(d, i, j) { groups[j][i].duration = value; }));
};
function d3_transition_each(callback) {
  for (var j = 0, m = this.length; j < m; j++) {
    for (var group = this[j], i = 0, n = group.length; i < n; i++) {
      var node = group[i];
      if (node) callback.call(node = node.node, node.__data__, i, j);
    }
  }
  return this;
}
d3_transitionPrototype.transition = function() {
  return this.select(d3_this);
};
var d3_timer_queue = null,
    d3_timer_interval, // is an interval (or frame) active?
    d3_timer_timeout; // is a timeout active?

// The timer will continue to fire until callback returns true.
d3.timer = function(callback, delay, then) {
  var found = false,
      t0,
      t1 = d3_timer_queue;

  if (arguments.length < 3) {
    if (arguments.length < 2) delay = 0;
    else if (!isFinite(delay)) return;
    then = Date.now();
  }

  // See if the callback's already in the queue.
  while (t1) {
    if (t1.callback === callback) {
      t1.then = then;
      t1.delay = delay;
      found = true;
      break;
    }
    t0 = t1;
    t1 = t1.next;
  }

  // Otherwise, add the callback to the queue.
  if (!found) d3_timer_queue = {
    callback: callback,
    then: then,
    delay: delay,
    next: d3_timer_queue
  };

  // Start animatin'!
  if (!d3_timer_interval) {
    d3_timer_timeout = clearTimeout(d3_timer_timeout);
    d3_timer_interval = 1;
    d3_timer_frame(d3_timer_step);
  }
}

function d3_timer_step() {
  var elapsed,
      now = Date.now(),
      t1 = d3_timer_queue;

  while (t1) {
    elapsed = now - t1.then;
    if (elapsed >= t1.delay) t1.flush = t1.callback(elapsed);
    t1 = t1.next;
  }

  var delay = d3_timer_flush() - now;
  if (delay > 24) {
    if (isFinite(delay)) {
      clearTimeout(d3_timer_timeout);
      d3_timer_timeout = setTimeout(d3_timer_step, delay);
    }
    d3_timer_interval = 0;
  } else {
    d3_timer_interval = 1;
    d3_timer_frame(d3_timer_step);
  }
}

d3.timer.flush = function() {
  var elapsed,
      now = Date.now(),
      t1 = d3_timer_queue;

  while (t1) {
    elapsed = now - t1.then;
    if (!t1.delay) t1.flush = t1.callback(elapsed);
    t1 = t1.next;
  }

  d3_timer_flush();
};

// Flush after callbacks, to avoid concurrent queue modification.
function d3_timer_flush() {
  var t0 = null,
      t1 = d3_timer_queue,
      then = Infinity;
  while (t1) {
    if (t1.flush) {
      t1 = t0 ? t0.next = t1.next : d3_timer_queue = t1.next;
    } else {
      then = Math.min(then, t1.then + t1.delay);
      t1 = (t0 = t1).next;
    }
  }
  return then;
}

var d3_timer_frame = window.requestAnimationFrame
    || window.webkitRequestAnimationFrame
    || window.mozRequestAnimationFrame
    || window.oRequestAnimationFrame
    || window.msRequestAnimationFrame
    || function(callback) { setTimeout(callback, 17); };
d3.transform = function(string) {
  d3_transformG.setAttribute("transform", string);
  return new d3_transform(d3_transformG.transform.baseVal.consolidate().matrix);
};

// Compute x-scale and normalize the first row.
// Compute shear and make second row orthogonal to first.
// Compute y-scale and normalize the second row.
// Finally, compute the rotation.
function d3_transform(m) {
  var r0 = [m.a, m.b],
      r1 = [m.c, m.d],
      kx = d3_transformNormalize(r0),
      kz = d3_transformDot(r0, r1),
      ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz));
  this.translate = [m.e, m.f];
  this.rotate = Math.atan2(m.b, m.a) * d3_transformDegrees;
  this.scale = [kx, ky || 0];
  this.skew = ky ? kz / ky * d3_transformDegrees : 0;
};

d3_transform.prototype.toString = function() {
  return "translate(" + this.translate
      + ")rotate(" + this.rotate
      + ")skewX(" + this.skew
      + ")scale(" + this.scale
      + ")";
};

function d3_transformDot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}

function d3_transformNormalize(a) {
  var k = Math.sqrt(d3_transformDot(a, a));
  a[0] /= k;
  a[1] /= k;
  return k;
}

function d3_transformCombine(a, b, k) {
  a[0] += k * b[0];
  a[1] += k * b[1];
  return a;
}

var d3_transformG = document.createElementNS(d3.ns.prefix.svg, "g"),
    d3_transformDegrees = 180 / Math.PI;
function d3_noop() {}
d3.scale = {};

function d3_scaleExtent(domain) {
  var start = domain[0], stop = domain[domain.length - 1];
  return start < stop ? [start, stop] : [stop, start];
}
function d3_scale_nice(domain, nice) {
  var i0 = 0,
      i1 = domain.length - 1,
      x0 = domain[i0],
      x1 = domain[i1],
      dx;

  if (x1 < x0) {
    dx = i0; i0 = i1; i1 = dx;
    dx = x0; x0 = x1; x1 = dx;
  }

  if (dx = x1 - x0) {
    nice = nice(dx);
    domain[i0] = nice.floor(x0);
    domain[i1] = nice.ceil(x1);
  }

  return domain;
}

function d3_scale_niceDefault() {
  return Math;
}
d3.scale.linear = function() {
  return d3_scale_linear([0, 1], [0, 1], d3.interpolate, false);
};

function d3_scale_linear(domain, range, interpolate, clamp) {
  var output,
      input;

  function rescale() {
    var linear = domain.length == 2 ? d3_scale_bilinear : d3_scale_polylinear,
        uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
    output = linear(domain, range, uninterpolate, interpolate);
    input = linear(range, domain, uninterpolate, d3.interpolate);
    return scale;
  }

  function scale(x) {
    return output(x);
  }

  // Note: requires range is coercible to number!
  scale.invert = function(y) {
    return input(y);
  };

  scale.domain = function(x) {
    if (!arguments.length) return domain;
    domain = x.map(Number);
    return rescale();
  };

  scale.range = function(x) {
    if (!arguments.length) return range;
    range = x;
    return rescale();
  };

  scale.rangeRound = function(x) {
    return scale.range(x).interpolate(d3.interpolateRound);
  };

  scale.clamp = function(x) {
    if (!arguments.length) return clamp;
    clamp = x;
    return rescale();
  };

  scale.interpolate = function(x) {
    if (!arguments.length) return interpolate;
    interpolate = x;
    return rescale();
  };

  scale.ticks = function(m) {
    return d3_scale_linearTicks(domain, m);
  };

  scale.tickFormat = function(m) {
    return d3_scale_linearTickFormat(domain, m);
  };

  scale.nice = function() {
    d3_scale_nice(domain, d3_scale_linearNice);
    return rescale();
  };

  scale.copy = function() {
    return d3_scale_linear(domain, range, interpolate, clamp);
  };

  return rescale();
};

function d3_scale_linearRebind(scale, linear) {
  scale.range = d3.rebind(scale, linear.range);
  scale.rangeRound = d3.rebind(scale, linear.rangeRound);
  scale.interpolate = d3.rebind(scale, linear.interpolate);
  scale.clamp = d3.rebind(scale, linear.clamp);
  return scale;
}

function d3_scale_linearNice(dx) {
  dx = Math.pow(10, Math.round(Math.log(dx) / Math.LN10) - 1);
  return {
    floor: function(x) { return Math.floor(x / dx) * dx; },
    ceil: function(x) { return Math.ceil(x / dx) * dx; }
  };
}

// TODO Dates? Ugh.
function d3_scale_linearTickRange(domain, m) {
  var extent = d3_scaleExtent(domain),
      span = extent[1] - extent[0],
      step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)),
      err = m / span * step;

  // Filter ticks to get closer to the desired count.
  if (err <= .15) step *= 10;
  else if (err <= .35) step *= 5;
  else if (err <= .75) step *= 2;

  // Round start and stop values to step interval.
  extent[0] = Math.ceil(extent[0] / step) * step;
  extent[1] = Math.floor(extent[1] / step) * step + step * .5; // inclusive
  extent[2] = step;
  return extent;
}

function d3_scale_linearTicks(domain, m) {
  return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
}

function d3_scale_linearTickFormat(domain, m) {
  return d3.format(",." + Math.max(0, -Math.floor(Math.log(d3_scale_linearTickRange(domain, m)[2]) / Math.LN10 + .01)) + "f");
}
function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
  var u = uninterpolate(domain[0], domain[1]),
      i = interpolate(range[0], range[1]);
  return function(x) {
    return i(u(x));
  };
}
function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
  var u = [],
      i = [],
      j = 0,
      n = domain.length;

  while (++j < n) {
    u.push(uninterpolate(domain[j - 1], domain[j]));
    i.push(interpolate(range[j - 1], range[j]));
  }

  return function(x) {
    var j = d3.bisect(domain, x, 1, domain.length - 1) - 1;
    return i[j](u[j](x));
  };
}
d3.scale.log = function() {
  return d3_scale_log(d3.scale.linear(), d3_scale_logp);
};

function d3_scale_log(linear, log) {
  var pow = log.pow;

  function scale(x) {
    return linear(log(x));
  }

  scale.invert = function(x) {
    return pow(linear.invert(x));
  };

  scale.domain = function(x) {
    if (!arguments.length) return linear.domain().map(pow);
    log = x[0] < 0 ? d3_scale_logn : d3_scale_logp;
    pow = log.pow;
    linear.domain(x.map(log));
    return scale;
  };

  scale.nice = function() {
    linear.domain(d3_scale_nice(linear.domain(), d3_scale_niceDefault));
    return scale;
  };

  scale.ticks = function() {
    var extent = d3_scaleExtent(linear.domain()),
        ticks = [];
    if (extent.every(isFinite)) {
      var i = Math.floor(extent[0]),
          j = Math.ceil(extent[1]),
          u = pow(extent[0]),
          v = pow(extent[1]);
      if (log === d3_scale_logn) {
        ticks.push(pow(i));
        for (; i++ < j;) for (var k = 9; k > 0; k--) ticks.push(pow(i) * k);
      } else {
        for (; i < j; i++) for (var k = 1; k < 10; k++) ticks.push(pow(i) * k);
        ticks.push(pow(i));
      }
      for (i = 0; ticks[i] < u; i++) {} // strip small values
      for (j = ticks.length; ticks[j - 1] > v; j--) {} // strip big values
      ticks = ticks.slice(i, j);
    }
    return ticks;
  };

  scale.tickFormat = function(n, format) {
    if (arguments.length < 2) format = d3_scale_logFormat;
    if (arguments.length < 1) return format;
    var k = n / scale.ticks().length,
        f = log === d3_scale_logn ? (e = -1e-15, Math.floor) : (e = 1e-15, Math.ceil),
        e;
    return function(d) {
      return d / pow(f(log(d) + e)) < k ? format(d) : "";
    };
  };

  scale.copy = function() {
    return d3_scale_log(linear.copy(), log);
  };

  return d3_scale_linearRebind(scale, linear);
};

var d3_scale_logFormat = d3.format(".0e");

function d3_scale_logp(x) {
  return Math.log(x) / Math.LN10;
}

function d3_scale_logn(x) {
  return -Math.log(-x) / Math.LN10;
}

d3_scale_logp.pow = function(x) {
  return Math.pow(10, x);
};

d3_scale_logn.pow = function(x) {
  return -Math.pow(10, -x);
};
d3.scale.pow = function() {
  return d3_scale_pow(d3.scale.linear(), 1);
};

function d3_scale_pow(linear, exponent) {
  var powp = d3_scale_powPow(exponent),
      powb = d3_scale_powPow(1 / exponent);

  function scale(x) {
    return linear(powp(x));
  }

  scale.invert = function(x) {
    return powb(linear.invert(x));
  };

  scale.domain = function(x) {
    if (!arguments.length) return linear.domain().map(powb);
    linear.domain(x.map(powp));
    return scale;
  };

  scale.ticks = function(m) {
    return d3_scale_linearTicks(scale.domain(), m);
  };

  scale.tickFormat = function(m) {
    return d3_scale_linearTickFormat(scale.domain(), m);
  };

  scale.nice = function() {
    return scale.domain(d3_scale_nice(scale.domain(), d3_scale_linearNice));
  };

  scale.exponent = function(x) {
    if (!arguments.length) return exponent;
    var domain = scale.domain();
    powp = d3_scale_powPow(exponent = x);
    powb = d3_scale_powPow(1 / exponent);
    return scale.domain(domain);
  };

  scale.copy = function() {
    return d3_scale_pow(linear.copy(), exponent);
  };

  return d3_scale_linearRebind(scale, linear);
};

function d3_scale_powPow(e) {
  return function(x) {
    return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
  };
}
d3.scale.sqrt = function() {
  return d3.scale.pow().exponent(.5);
};
d3.scale.ordinal = function() {
  return d3_scale_ordinal([], {t: "range", x: []});
};

function d3_scale_ordinal(domain, ranger) {
  var index,
      range,
      rangeBand;

  function scale(x) {
    return range[((index[x] || (index[x] = domain.push(x))) - 1) % range.length];
  }

  function steps(start, step) {
    return d3.range(domain.length).map(function(i) { return start + step * i; });
  }

  scale.domain = function(x) {
    if (!arguments.length) return domain;
    domain = [];
    index = {};
    var i = -1, n = x.length, xi;
    while (++i < n) if (!index[xi = x[i]]) index[xi] = domain.push(xi);
    return scale[ranger.t](ranger.x, ranger.p);
  };

  scale.range = function(x) {
    if (!arguments.length) return range;
    range = x;
    rangeBand = 0;
    ranger = {t: "range", x: x};
    return scale;
  };

  scale.rangePoints = function(x, padding) {
    if (arguments.length < 2) padding = 0;
    var start = x[0],
        stop = x[1],
        step = (stop - start) / (domain.length - 1 + padding);
    range = steps(domain.length < 2 ? (start + stop) / 2 : start + step * padding / 2, step);
    rangeBand = 0;
    ranger = {t: "rangePoints", x: x, p: padding};
    return scale;
  };

  scale.rangeBands = function(x, padding) {
    if (arguments.length < 2) padding = 0;
    var start = x[0],
        stop = x[1],
        step = (stop - start) / (domain.length + padding);
    range = steps(start + step * padding, step);
    rangeBand = step * (1 - padding);
    ranger = {t: "rangeBands", x: x, p: padding};
    return scale;
  };

  scale.rangeRoundBands = function(x, padding) {
    if (arguments.length < 2) padding = 0;
    var start = x[0],
        stop = x[1],
        step = Math.floor((stop - start) / (domain.length + padding));
    range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
    rangeBand = Math.round(step * (1 - padding));
    ranger = {t: "rangeRoundBands", x: x, p: padding};
    return scale;
  };

  scale.rangeBand = function() {
    return rangeBand;
  };

  scale.copy = function() {
    return d3_scale_ordinal(domain, ranger);
  };

  return scale.domain(domain);
};
/*
 * This product includes color specifications and designs developed by Cynthia
 * Brewer (http://colorbrewer.org/). See lib/colorbrewer for more information.
 */

d3.scale.category10 = function() {
  return d3.scale.ordinal().range(d3_category10);
};

d3.scale.category20 = function() {
  return d3.scale.ordinal().range(d3_category20);
};

d3.scale.category20b = function() {
  return d3.scale.ordinal().range(d3_category20b);
};

d3.scale.category20c = function() {
  return d3.scale.ordinal().range(d3_category20c);
};

var d3_category10 = [
  "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd",
  "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"
];

var d3_category20 = [
  "#1f77b4", "#aec7e8",
  "#ff7f0e", "#ffbb78",
  "#2ca02c", "#98df8a",
  "#d62728", "#ff9896",
  "#9467bd", "#c5b0d5",
  "#8c564b", "#c49c94",
  "#e377c2", "#f7b6d2",
  "#7f7f7f", "#c7c7c7",
  "#bcbd22", "#dbdb8d",
  "#17becf", "#9edae5"
];

var d3_category20b = [
  "#393b79", "#5254a3", "#6b6ecf", "#9c9ede",
  "#637939", "#8ca252", "#b5cf6b", "#cedb9c",
  "#8c6d31", "#bd9e39", "#e7ba52", "#e7cb94",
  "#843c39", "#ad494a", "#d6616b", "#e7969c",
  "#7b4173", "#a55194", "#ce6dbd", "#de9ed6"
];

var d3_category20c = [
  "#3182bd", "#6baed6", "#9ecae1", "#c6dbef",
  "#e6550d", "#fd8d3c", "#fdae6b", "#fdd0a2",
  "#31a354", "#74c476", "#a1d99b", "#c7e9c0",
  "#756bb1", "#9e9ac8", "#bcbddc", "#dadaeb",
  "#636363", "#969696", "#bdbdbd", "#d9d9d9"
];
d3.scale.quantile = function() {
  return d3_scale_quantile([], []);
};

function d3_scale_quantile(domain, range) {
  var thresholds;

  function rescale() {
    var k = 0,
        n = domain.length,
        q = range.length;
    thresholds = [];
    while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
    return scale;
  }

  function scale(x) {
    if (isNaN(x = +x)) return NaN;
    return range[d3.bisect(thresholds, x)];
  }

  scale.domain = function(x) {
    if (!arguments.length) return domain;
    domain = x.filter(function(d) { return !isNaN(d); }).sort(d3.ascending);
    return rescale();
  };

  scale.range = function(x) {
    if (!arguments.length) return range;
    range = x;
    return rescale();
  };

  scale.quantiles = function() {
    return thresholds;
  };

  scale.copy = function() {
    return d3_scale_quantile(domain, range); // copy on write!
  };

  return rescale();
};
d3.scale.quantize = function() {
  return d3_scale_quantize(0, 1, [0, 1]);
};

function d3_scale_quantize(x0, x1, range) {
  var kx, i;

  function scale(x) {
    return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
  }

  function rescale() {
    kx = range.length / (x1 - x0);
    i = range.length - 1;
    return scale;
  }

  scale.domain = function(x) {
    if (!arguments.length) return [x0, x1];
    x0 = +x[0];
    x1 = +x[x.length - 1];
    return rescale();
  };

  scale.range = function(x) {
    if (!arguments.length) return range;
    range = x;
    return rescale();
  };

  scale.copy = function() {
    return d3_scale_quantize(x0, x1, range); // copy on write
  };

  return rescale();
};
d3.svg = {};
d3.svg.arc = function() {
  var innerRadius = d3_svg_arcInnerRadius,
      outerRadius = d3_svg_arcOuterRadius,
      startAngle = d3_svg_arcStartAngle,
      endAngle = d3_svg_arcEndAngle;

  function arc() {
    var r0 = innerRadius.apply(this, arguments),
        r1 = outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) + d3_svg_arcOffset,
        a1 = endAngle.apply(this, arguments) + d3_svg_arcOffset,
        da = (a1 < a0 && (da = a0, a0 = a1, a1 = da), a1 - a0),
        df = da < Math.PI ? "0" : "1",
        c0 = Math.cos(a0),
        s0 = Math.sin(a0),
        c1 = Math.cos(a1),
        s1 = Math.sin(a1);
    return da >= d3_svg_arcMax
      ? (r0
      ? "M0," + r1
      + "A" + r1 + "," + r1 + " 0 1,1 0," + (-r1)
      + "A" + r1 + "," + r1 + " 0 1,1 0," + r1
      + "M0," + r0
      + "A" + r0 + "," + r0 + " 0 1,0 0," + (-r0)
      + "A" + r0 + "," + r0 + " 0 1,0 0," + r0
      + "Z"
      : "M0," + r1
      + "A" + r1 + "," + r1 + " 0 1,1 0," + (-r1)
      + "A" + r1 + "," + r1 + " 0 1,1 0," + r1
      + "Z")
      : (r0
      ? "M" + r1 * c0 + "," + r1 * s0
      + "A" + r1 + "," + r1 + " 0 " + df + ",1 " + r1 * c1 + "," + r1 * s1
      + "L" + r0 * c1 + "," + r0 * s1
      + "A" + r0 + "," + r0 + " 0 " + df + ",0 " + r0 * c0 + "," + r0 * s0
      + "Z"
      : "M" + r1 * c0 + "," + r1 * s0
      + "A" + r1 + "," + r1 + " 0 " + df + ",1 " + r1 * c1 + "," + r1 * s1
      + "L0,0"
      + "Z");
  }

  arc.innerRadius = function(v) {
    if (!arguments.length) return innerRadius;
    innerRadius = d3.functor(v);
    return arc;
  };

  arc.outerRadius = function(v) {
    if (!arguments.length) return outerRadius;
    outerRadius = d3.functor(v);
    return arc;
  };

  arc.startAngle = function(v) {
    if (!arguments.length) return startAngle;
    startAngle = d3.functor(v);
    return arc;
  };

  arc.endAngle = function(v) {
    if (!arguments.length) return endAngle;
    endAngle = d3.functor(v);
    return arc;
  };

  arc.centroid = function() {
    var r = (innerRadius.apply(this, arguments)
        + outerRadius.apply(this, arguments)) / 2,
        a = (startAngle.apply(this, arguments)
        + endAngle.apply(this, arguments)) / 2 + d3_svg_arcOffset;
    return [Math.cos(a) * r, Math.sin(a) * r];
  };

  return arc;
};

var d3_svg_arcOffset = -Math.PI / 2,
    d3_svg_arcMax = 2 * Math.PI - 1e-6;

function d3_svg_arcInnerRadius(d) {
  return d.innerRadius;
}

function d3_svg_arcOuterRadius(d) {
  return d.outerRadius;
}

function d3_svg_arcStartAngle(d) {
  return d.startAngle;
}

function d3_svg_arcEndAngle(d) {
  return d.endAngle;
}
function d3_svg_line(projection) {
  var x = d3_svg_lineX,
      y = d3_svg_lineY,
      interpolate = "linear",
      interpolator = d3_svg_lineInterpolators[interpolate],
      tension = .7;

  function line(d) {
    return d.length < 1 ? null : "M" + interpolator(projection(d3_svg_linePoints(this, d, x, y)), tension);
  }

  line.x = function(v) {
    if (!arguments.length) return x;
    x = v;
    return line;
  };

  line.y = function(v) {
    if (!arguments.length) return y;
    y = v;
    return line;
  };

  line.interpolate = function(v) {
    if (!arguments.length) return interpolate;
    interpolator = d3_svg_lineInterpolators[interpolate = v];
    return line;
  };

  line.tension = function(v) {
    if (!arguments.length) return tension;
    tension = v;
    return line;
  };

  return line;
}

d3.svg.line = function() {
  return d3_svg_line(Object);
};

// Converts the specified array of data into an array of points
// (x-y tuples), by evaluating the specified `x` and `y` functions on each
// data point. The `this` context of the evaluated functions is the specified
// "self" object; each function is passed the current datum and index.
function d3_svg_linePoints(self, d, x, y) {
  var points = [],
      i = -1,
      n = d.length,
      fx = typeof x === "function",
      fy = typeof y === "function",
      value;
  if (fx && fy) {
    while (++i < n) points.push([
      x.call(self, value = d[i], i),
      y.call(self, value, i)
    ]);
  } else if (fx) {
    while (++i < n) points.push([x.call(self, d[i], i), y]);
  } else if (fy) {
    while (++i < n) points.push([x, y.call(self, d[i], i)]);
  } else {
    while (++i < n) points.push([x, y]);
  }
  return points;
}

// The default `x` property, which references d[0].
function d3_svg_lineX(d) {
  return d[0];
}

// The default `y` property, which references d[1].
function d3_svg_lineY(d) {
  return d[1];
}

// The various interpolators supported by the `line` class.
var d3_svg_lineInterpolators = {
  "linear": d3_svg_lineLinear,
  "step-before": d3_svg_lineStepBefore,
  "step-after": d3_svg_lineStepAfter,
  "basis": d3_svg_lineBasis,
  "basis-open": d3_svg_lineBasisOpen,
  "basis-closed": d3_svg_lineBasisClosed,
  "bundle": d3_svg_lineBundle,
  "cardinal": d3_svg_lineCardinal,
  "cardinal-open": d3_svg_lineCardinalOpen,
  "cardinal-closed": d3_svg_lineCardinalClosed,
  "monotone": d3_svg_lineMonotone
};

// Linear interpolation; generates "L" commands.
function d3_svg_lineLinear(points) {
  var i = 0,
      n = points.length,
      p = points[0],
      path = [p[0], ",", p[1]];
  while (++i < n) path.push("L", (p = points[i])[0], ",", p[1]);
  return path.join("");
}

// Step interpolation; generates "H" and "V" commands.
function d3_svg_lineStepBefore(points) {
  var i = 0,
      n = points.length,
      p = points[0],
      path = [p[0], ",", p[1]];
  while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
  return path.join("");
}

// Step interpolation; generates "H" and "V" commands.
function d3_svg_lineStepAfter(points) {
  var i = 0,
      n = points.length,
      p = points[0],
      path = [p[0], ",", p[1]];
  while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
  return path.join("");
}

// Open cardinal spline interpolation; generates "C" commands.
function d3_svg_lineCardinalOpen(points, tension) {
  return points.length < 4
      ? d3_svg_lineLinear(points)
      : points[1] + d3_svg_lineHermite(points.slice(1, points.length - 1),
        d3_svg_lineCardinalTangents(points, tension));
}

// Closed cardinal spline interpolation; generates "C" commands.
function d3_svg_lineCardinalClosed(points, tension) {
  return points.length < 3
      ? d3_svg_lineLinear(points)
      : points[0] + d3_svg_lineHermite((points.push(points[0]), points),
        d3_svg_lineCardinalTangents([points[points.length - 2]]
        .concat(points, [points[1]]), tension));
}

// Cardinal spline interpolation; generates "C" commands.
function d3_svg_lineCardinal(points, tension, closed) {
  return points.length < 3
      ? d3_svg_lineLinear(points)
      : points[0] + d3_svg_lineHermite(points,
        d3_svg_lineCardinalTangents(points, tension));
}

// Hermite spline construction; generates "C" commands.
function d3_svg_lineHermite(points, tangents) {
  if (tangents.length < 1
      || (points.length != tangents.length
      && points.length != tangents.length + 2)) {
    return d3_svg_lineLinear(points);
  }

  var quad = points.length != tangents.length,
      path = "",
      p0 = points[0],
      p = points[1],
      t0 = tangents[0],
      t = t0,
      pi = 1;

  if (quad) {
    path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3)
        + "," + p[0] + "," + p[1];
    p0 = points[1];
    pi = 2;
  }

  if (tangents.length > 1) {
    t = tangents[1];
    p = points[pi];
    pi++;
    path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1])
        + "," + (p[0] - t[0]) + "," + (p[1] - t[1])
        + "," + p[0] + "," + p[1];
    for (var i = 2; i < tangents.length; i++, pi++) {
      p = points[pi];
      t = tangents[i];
      path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1])
          + "," + p[0] + "," + p[1];
    }
  }

  if (quad) {
    var lp = points[pi];
    path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3)
        + "," + lp[0] + "," + lp[1];
  }

  return path;
}

// Generates tangents for a cardinal spline.
function d3_svg_lineCardinalTangents(points, tension) {
  var tangents = [],
      a = (1 - tension) / 2,
      p0,
      p1 = points[0],
      p2 = points[1],
      i = 1,
      n = points.length;
  while (++i < n) {
    p0 = p1;
    p1 = p2;
    p2 = points[i];
    tangents.push([a * (p2[0] - p0[0]), a * (p2[1] - p0[1])]);
  }
  return tangents;
}

// B-spline interpolation; generates "C" commands.
function d3_svg_lineBasis(points) {
  if (points.length < 3) return d3_svg_lineLinear(points);
  var i = 1,
      n = points.length,
      pi = points[0],
      x0 = pi[0],
      y0 = pi[1],
      px = [x0, x0, x0, (pi = points[1])[0]],
      py = [y0, y0, y0, pi[1]],
      path = [x0, ",", y0];
  d3_svg_lineBasisBezier(path, px, py);
  while (++i < n) {
    pi = points[i];
    px.shift(); px.push(pi[0]);
    py.shift(); py.push(pi[1]);
    d3_svg_lineBasisBezier(path, px, py);
  }
  i = -1;
  while (++i < 2) {
    px.shift(); px.push(pi[0]);
    py.shift(); py.push(pi[1]);
    d3_svg_lineBasisBezier(path, px, py);
  }
  return path.join("");
}

// Open B-spline interpolation; generates "C" commands.
function d3_svg_lineBasisOpen(points) {
  if (points.length < 4) return d3_svg_lineLinear(points);
  var path = [],
      i = -1,
      n = points.length,
      pi,
      px = [0],
      py = [0];
  while (++i < 3) {
    pi = points[i];
    px.push(pi[0]);
    py.push(pi[1]);
  }
  path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px)
    + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
  --i; while (++i < n) {
    pi = points[i];
    px.shift(); px.push(pi[0]);
    py.shift(); py.push(pi[1]);
    d3_svg_lineBasisBezier(path, px, py);
  }
  return path.join("");
}

// Closed B-spline interpolation; generates "C" commands.
function d3_svg_lineBasisClosed(points) {
  var path,
      i = -1,
      n = points.length,
      m = n + 4,
      pi,
      px = [],
      py = [];
  while (++i < 4) {
    pi = points[i % n];
    px.push(pi[0]);
    py.push(pi[1]);
  }
  path = [
    d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",",
    d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)
  ];
  --i; while (++i < m) {
    pi = points[i % n];
    px.shift(); px.push(pi[0]);
    py.shift(); py.push(pi[1]);
    d3_svg_lineBasisBezier(path, px, py);
  }
  return path.join("");
}

function d3_svg_lineBundle(points, tension) {
  var n = points.length - 1,
      x0 = points[0][0],
      y0 = points[0][1],
      dx = points[n][0] - x0,
      dy = points[n][1] - y0,
      i = -1,
      p,
      t;
  while (++i <= n) {
    p = points[i];
    t = i / n;
    p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
    p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
  }
  return d3_svg_lineBasis(points);
}

// Returns the dot product of the given four-element vectors.
function d3_svg_lineDot4(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}

// Matrix to transform basis (b-spline) control points to bezier
// control points. Derived from FvD 11.2.8.
var d3_svg_lineBasisBezier1 = [0, 2/3, 1/3, 0],
    d3_svg_lineBasisBezier2 = [0, 1/3, 2/3, 0],
    d3_svg_lineBasisBezier3 = [0, 1/6, 2/3, 1/6];

// Pushes a "C" Bézier curve onto the specified path array, given the
// two specified four-element arrays which define the control points.
function d3_svg_lineBasisBezier(path, x, y) {
  path.push(
      "C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x),
      ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y),
      ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x),
      ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y),
      ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x),
      ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
}

// Computes the slope from points p0 to p1.
function d3_svg_lineSlope(p0, p1) {
  return (p1[1] - p0[1]) / (p1[0] - p0[0]);
}

// Compute three-point differences for the given points.
// http://en.wikipedia.org/wiki/Cubic_Hermite_spline#Finite_difference
function d3_svg_lineFiniteDifferences(points) {
  var i = 0,
      j = points.length - 1,
      m = [],
      p0 = points[0],
      p1 = points[1],
      d = m[0] = d3_svg_lineSlope(p0, p1);
  while (++i < j) {
    m[i] = d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]));
  }
  m[i] = d;
  return m;
}

// Interpolates the given points using Fritsch-Carlson Monotone cubic Hermite
// interpolation. Returns an array of tangent vectors. For details, see
// http://en.wikipedia.org/wiki/Monotone_cubic_interpolation
function d3_svg_lineMonotoneTangents(points) {
  var tangents = [],
      d,
      a,
      b,
      s,
      m = d3_svg_lineFiniteDifferences(points),
      i = -1,
      j = points.length - 1;

  // The first two steps are done by computing finite-differences:
  // 1. Compute the slopes of the secant lines between successive points.
  // 2. Initialize the tangents at every point as the average of the secants.

  // Then, for each segment…
  while (++i < j) {
    d = d3_svg_lineSlope(points[i], points[i + 1]);

    // 3. If two successive yk = y{k + 1} are equal (i.e., d is zero), then set
    // mk = m{k + 1} = 0 as the spline connecting these points must be flat to
    // preserve monotonicity. Ignore step 4 and 5 for those k.

    if (Math.abs(d) < 1e-6) {
      m[i] = m[i + 1] = 0;
    } else {
      // 4. Let ak = mk / dk and bk = m{k + 1} / dk.
      a = m[i] / d;
      b = m[i + 1] / d;

      // 5. Prevent overshoot and ensure monotonicity by restricting the
      // magnitude of vector <ak, bk> to a circle of radius 3.
      s = a * a + b * b;
      if (s > 9) {
        s = d * 3 / Math.sqrt(s);
        m[i] = s * a;
        m[i + 1] = s * b;
      }
    }
  }

  // Compute the normalized tangent vector from the slopes. Note that if x is
  // not monotonic, it's possible that the slope will be infinite, so we protect
  // against NaN by setting the coordinate to zero.
  i = -1; while (++i <= j) {
    s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0])
      / (6 * (1 + m[i] * m[i]));
    tangents.push([s || 0, m[i] * s || 0]);
  }

  return tangents;
}

function d3_svg_lineMonotone(points) {
  return points.length < 3
      ? d3_svg_lineLinear(points)
      : points[0] +
        d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
}
d3.svg.line.radial = function() {
  var line = d3_svg_line(d3_svg_lineRadial);
  line.radius = line.x, delete line.x;
  line.angle = line.y, delete line.y;
  return line;
};

function d3_svg_lineRadial(points) {
  var point,
      i = -1,
      n = points.length,
      r,
      a;
  while (++i < n) {
    point = points[i];
    r = point[0];
    a = point[1] + d3_svg_arcOffset;
    point[0] = r * Math.cos(a);
    point[1] = r * Math.sin(a);
  }
  return points;
}
function d3_svg_area(projection) {
  var x0 = d3_svg_lineX,
      x1 = d3_svg_lineX,
      y0 = 0,
      y1 = d3_svg_lineY,
      interpolate,
      i0,
      i1,
      tension = .7;

  function area(d) {
    if (d.length < 1) return null;
    var points0 = d3_svg_linePoints(this, d, x0, y0),
        points1 = d3_svg_linePoints(this, d, x0 === x1 ? d3_svg_areaX(points0) : x1, y0 === y1 ? d3_svg_areaY(points0) : y1);
    return "M" + i0(projection(points1), tension)
         + "L" + i1(projection(points0.reverse()), tension)
         + "Z";
  }

  area.x = function(x) {
    if (!arguments.length) return x1;
    x0 = x1 = x;
    return area;
  };

  area.x0 = function(x) {
    if (!arguments.length) return x0;
    x0 = x;
    return area;
  };

  area.x1 = function(x) {
    if (!arguments.length) return x1;
    x1 = x;
    return area;
  };

  area.y = function(y) {
    if (!arguments.length) return y1;
    y0 = y1 = y;
    return area;
  };

  area.y0 = function(y) {
    if (!arguments.length) return y0;
    y0 = y;
    return area;
  };

  area.y1 = function(y) {
    if (!arguments.length) return y1;
    y1 = y;
    return area;
  };

  area.interpolate = function(x) {
    if (!arguments.length) return interpolate;
    i0 = d3_svg_lineInterpolators[interpolate = x];
    i1 = i0.reverse || i0;
    return area;
  };

  area.tension = function(x) {
    if (!arguments.length) return tension;
    tension = x;
    return area;
  };

  return area.interpolate("linear");
}

d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;

d3.svg.area = function() {
  return d3_svg_area(Object);
};

function d3_svg_areaX(points) {
  return function(d, i) {
    return points[i][0];
  };
}

function d3_svg_areaY(points) {
  return function(d, i) {
    return points[i][1];
  };
}
d3.svg.area.radial = function() {
  var area = d3_svg_area(d3_svg_lineRadial);
  area.radius = area.x, delete area.x;
  area.innerRadius = area.x0, delete area.x0;
  area.outerRadius = area.x1, delete area.x1;
  area.angle = area.y, delete area.y;
  area.startAngle = area.y0, delete area.y0;
  area.endAngle = area.y1, delete area.y1;
  return area;
};
d3.svg.chord = function() {
  var source = d3_svg_chordSource,
      target = d3_svg_chordTarget,
      radius = d3_svg_chordRadius,
      startAngle = d3_svg_arcStartAngle,
      endAngle = d3_svg_arcEndAngle;

  // TODO Allow control point to be customized.

  function chord(d, i) {
    var s = subgroup(this, source, d, i),
        t = subgroup(this, target, d, i);
    return "M" + s.p0
      + arc(s.r, s.p1) + (equals(s, t)
      ? curve(s.r, s.p1, s.r, s.p0)
      : curve(s.r, s.p1, t.r, t.p0)
      + arc(t.r, t.p1)
      + curve(t.r, t.p1, s.r, s.p0))
      + "Z";
  }

  function subgroup(self, f, d, i) {
    var subgroup = f.call(self, d, i),
        r = radius.call(self, subgroup, i),
        a0 = startAngle.call(self, subgroup, i) + d3_svg_arcOffset,
        a1 = endAngle.call(self, subgroup, i) + d3_svg_arcOffset;
    return {
      r: r,
      a0: a0,
      a1: a1,
      p0: [r * Math.cos(a0), r * Math.sin(a0)],
      p1: [r * Math.cos(a1), r * Math.sin(a1)]
    };
  }

  function equals(a, b) {
    return a.a0 == b.a0 && a.a1 == b.a1;
  }

  function arc(r, p) {
    return "A" + r + "," + r + " 0 0,1 " + p;
  }

  function curve(r0, p0, r1, p1) {
    return "Q 0,0 " + p1;
  }

  chord.radius = function(v) {
    if (!arguments.length) return radius;
    radius = d3.functor(v);
    return chord;
  };

  chord.source = function(v) {
    if (!arguments.length) return source;
    source = d3.functor(v);
    return chord;
  };

  chord.target = function(v) {
    if (!arguments.length) return target;
    target = d3.functor(v);
    return chord;
  };

  chord.startAngle = function(v) {
    if (!arguments.length) return startAngle;
    startAngle = d3.functor(v);
    return chord;
  };

  chord.endAngle = function(v) {
    if (!arguments.length) return endAngle;
    endAngle = d3.functor(v);
    return chord;
  };

  return chord;
};

function d3_svg_chordSource(d) {
  return d.source;
}

function d3_svg_chordTarget(d) {
  return d.target;
}

function d3_svg_chordRadius(d) {
  return d.radius;
}

function d3_svg_chordStartAngle(d) {
  return d.startAngle;
}

function d3_svg_chordEndAngle(d) {
  return d.endAngle;
}
d3.svg.diagonal = function() {
  var source = d3_svg_chordSource,
      target = d3_svg_chordTarget,
      projection = d3_svg_diagonalProjection;

  function diagonal(d, i) {
    var p0 = source.call(this, d, i),
        p3 = target.call(this, d, i),
        m = (p0.y + p3.y) / 2,
        p = [p0, {x: p0.x, y: m}, {x: p3.x, y: m}, p3];
    p = p.map(projection);
    return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
  }

  diagonal.source = function(x) {
    if (!arguments.length) return source;
    source = d3.functor(x);
    return diagonal;
  };

  diagonal.target = function(x) {
    if (!arguments.length) return target;
    target = d3.functor(x);
    return diagonal;
  };

  diagonal.projection = function(x) {
    if (!arguments.length) return projection;
    projection = x;
    return diagonal;
  };

  return diagonal;
};

function d3_svg_diagonalProjection(d) {
  return [d.x, d.y];
}
d3.svg.diagonal.radial = function() {
  var diagonal = d3.svg.diagonal(),
      projection = d3_svg_diagonalProjection,
      projection_ = diagonal.projection;

  diagonal.projection = function(x) {
    return arguments.length
        ? projection_(d3_svg_diagonalRadialProjection(projection = x))
        : projection;
  };

  return diagonal;
};

function d3_svg_diagonalRadialProjection(projection) {
  return function() {
    var d = projection.apply(this, arguments),
        r = d[0],
        a = d[1] + d3_svg_arcOffset;
    return [r * Math.cos(a), r * Math.sin(a)];
  };
}
d3.svg.mouse = function(container) {
  return d3_svg_mousePoint(container, d3.event);
};

// https://bugs.webkit.org/show_bug.cgi?id=44083
var d3_mouse_bug44083 = /WebKit/.test(navigator.userAgent) ? -1 : 0;

function d3_svg_mousePoint(container, e) {
  var point = (container.ownerSVGElement || container).createSVGPoint();
  if ((d3_mouse_bug44083 < 0) && (window.scrollX || window.scrollY)) {
    var svg = d3.select(document.body)
      .append("svg:svg")
        .style("position", "absolute")
        .style("top", 0)
        .style("left", 0);
    var ctm = svg[0][0].getScreenCTM();
    d3_mouse_bug44083 = !(ctm.f || ctm.e);
    svg.remove();
  }
  if (d3_mouse_bug44083) {
    point.x = e.pageX;
    point.y = e.pageY;
  } else {
    point.x = e.clientX;
    point.y = e.clientY;
  }
  point = point.matrixTransform(container.getScreenCTM().inverse());
  return [point.x, point.y];
};
d3.svg.touches = function(container, touches) {
  if (arguments.length < 2) touches = d3.event.touches;

  return touches ? d3_array(touches).map(function(touch) {
    var point = d3_svg_mousePoint(container, touch);
    point.identifier = touch.identifier;
    return point;
  }) : [];
};
d3.svg.symbol = function() {
  var type = d3_svg_symbolType,
      size = d3_svg_symbolSize;

  function symbol(d, i) {
    return (d3_svg_symbols[type.call(this, d, i)]
        || d3_svg_symbols.circle)
        (size.call(this, d, i));
  }

  symbol.type = function(x) {
    if (!arguments.length) return type;
    type = d3.functor(x);
    return symbol;
  };

  // size of symbol in square pixels
  symbol.size = function(x) {
    if (!arguments.length) return size;
    size = d3.functor(x);
    return symbol;
  };

  return symbol;
};

function d3_svg_symbolSize() {
  return 64;
}

function d3_svg_symbolType() {
  return "circle";
}

// TODO cross-diagonal?
var d3_svg_symbols = {
  "circle": function(size) {
    var r = Math.sqrt(size / Math.PI);
    return "M0," + r
        + "A" + r + "," + r + " 0 1,1 0," + (-r)
        + "A" + r + "," + r + " 0 1,1 0," + r
        + "Z";
  },
  "cross": function(size) {
    var r = Math.sqrt(size / 5) / 2;
    return "M" + -3 * r + "," + -r
        + "H" + -r
        + "V" + -3 * r
        + "H" + r
        + "V" + -r
        + "H" + 3 * r
        + "V" + r
        + "H" + r
        + "V" + 3 * r
        + "H" + -r
        + "V" + r
        + "H" + -3 * r
        + "Z";
  },
  "diamond": function(size) {
    var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)),
        rx = ry * d3_svg_symbolTan30;
    return "M0," + -ry
        + "L" + rx + ",0"
        + " 0," + ry
        + " " + -rx + ",0"
        + "Z";
  },
  "square": function(size) {
    var r = Math.sqrt(size) / 2;
    return "M" + -r + "," + -r
        + "L" + r + "," + -r
        + " " + r + "," + r
        + " " + -r + "," + r
        + "Z";
  },
  "triangle-down": function(size) {
    var rx = Math.sqrt(size / d3_svg_symbolSqrt3),
        ry = rx * d3_svg_symbolSqrt3 / 2;
    return "M0," + ry
        + "L" + rx +"," + -ry
        + " " + -rx + "," + -ry
        + "Z";
  },
  "triangle-up": function(size) {
    var rx = Math.sqrt(size / d3_svg_symbolSqrt3),
        ry = rx * d3_svg_symbolSqrt3 / 2;
    return "M0," + -ry
        + "L" + rx +"," + ry
        + " " + -rx + "," + ry
        + "Z";
  }
};

d3.svg.symbolTypes = d3.keys(d3_svg_symbols);

var d3_svg_symbolSqrt3 = Math.sqrt(3),
    d3_svg_symbolTan30 = Math.tan(30 * Math.PI / 180);
d3.svg.axis = function() {
  var scale = d3.scale.linear(),
      orient = "bottom",
      tickMajorSize = 6,
      tickMinorSize = 6,
      tickEndSize = 6,
      tickPadding = 3,
      tickArguments_ = [10],
      tickFormat_,
      tickSubdivide = 0;

  function axis(selection) {
    selection.each(function(d, i, j) {
      var g = d3.select(this);

      // If selection is a transition, create subtransitions.
      var transition = selection.delay ? function(o) {
        var id = d3_transitionInheritId;
        try {
          d3_transitionInheritId = selection.id;
          return o.transition()
              .delay(selection[j][i].delay)
              .duration(selection[j][i].duration)
              .ease(selection.ease());
        } finally {
          d3_transitionInheritId = id;
        }
      } : Object;

      // Ticks.
      var ticks = scale.ticks.apply(scale, tickArguments_),
          tickFormat = tickFormat_ == null ? scale.tickFormat.apply(scale, tickArguments_) : tickFormat_;

      // Minor ticks.
      var subticks = d3_svg_axisSubdivide(scale, ticks, tickSubdivide),
          subtick = g.selectAll(".minor").data(subticks, String),
          subtickEnter = subtick.enter().insert("svg:line", "g").attr("class", "tick minor").style("opacity", 1e-6),
          subtickExit = transition(subtick.exit()).style("opacity", 1e-6).remove(),
          subtickUpdate = transition(subtick).style("opacity", 1);

      // Major ticks.
      var tick = g.selectAll("g").data(ticks, String),
          tickEnter = tick.enter().insert("svg:g", "path").style("opacity", 1e-6),
          tickExit = transition(tick.exit()).style("opacity", 1e-6).remove(),
          tickUpdate = transition(tick).style("opacity", 1),
          tickTransform;

      // Domain.
      var range = d3_scaleExtent(scale.range()),
          path = g.selectAll(".domain").data([0]),
          pathEnter = path.enter().append("svg:path").attr("class", "domain"),
          pathUpdate = transition(path);

      // Stash the new scale and grab the old scale.
      var scale0 = this.__chart__ || scale;
      this.__chart__ = scale.copy();

      tickEnter.append("svg:line").attr("class", "tick");
      tickEnter.append("svg:text");
      tickUpdate.select("text").text(tickFormat);

      switch (orient) {
        case "bottom": {
          tickTransform = d3_svg_axisX;
          subtickUpdate.attr("x2", 0).attr("y2", tickMinorSize);
          tickUpdate.select("line").attr("x2", 0).attr("y2", tickMajorSize);
          tickUpdate.select("text").attr("x", 0).attr("y", Math.max(tickMajorSize, 0) + tickPadding).attr("dy", ".71em").attr("text-anchor", "middle");
          pathUpdate.attr("d", "M" + range[0] + "," + tickEndSize + "V0H" + range[1] + "V" + tickEndSize);
          break;
        }
        case "top": {
          tickTransform = d3_svg_axisX;
          subtickUpdate.attr("x2", 0).attr("y2", -tickMinorSize);
          tickUpdate.select("line").attr("x2", 0).attr("y2", -tickMajorSize);
          tickUpdate.select("text").attr("x", 0).attr("y", -(Math.max(tickMajorSize, 0) + tickPadding)).attr("dy", "0em").attr("text-anchor", "middle");
          pathUpdate.attr("d", "M" + range[0] + "," + -tickEndSize + "V0H" + range[1] + "V" + -tickEndSize);
          break;
        }
        case "left": {
          tickTransform = d3_svg_axisY;
          subtickUpdate.attr("x2", -tickMinorSize).attr("y2", 0);
          tickUpdate.select("line").attr("x2", -tickMajorSize).attr("y2", 0);
          tickUpdate.select("text").attr("x", -(Math.max(tickMajorSize, 0) + tickPadding)).attr("y", 0).attr("dy", ".32em").attr("text-anchor", "end");
          pathUpdate.attr("d", "M" + -tickEndSize + "," + range[0] + "H0V" + range[1] + "H" + -tickEndSize);
          break;
        }
        case "right": {
          tickTransform = d3_svg_axisY;
          subtickUpdate.attr("x2", tickMinorSize).attr("y2", 0);
          tickUpdate.select("line").attr("x2", tickMajorSize).attr("y2", 0);
          tickUpdate.select("text").attr("x", Math.max(tickMajorSize, 0) + tickPadding).attr("y", 0).attr("dy", ".32em").attr("text-anchor", "start");
          pathUpdate.attr("d", "M" + tickEndSize + "," + range[0] + "H0V" + range[1] + "H" + tickEndSize);
          break;
        }
      }

      tickEnter.call(tickTransform, scale0);
      tickUpdate.call(tickTransform, scale);
      tickExit.call(tickTransform, scale);

      subtickEnter.call(tickTransform, scale0);
      subtickUpdate.call(tickTransform, scale);
      subtickExit.call(tickTransform, scale);
    });
  }

  axis.scale = function(x) {
    if (!arguments.length) return scale;
    scale = x;
    return axis;
  };

  axis.orient = function(x) {
    if (!arguments.length) return orient;
    orient = x;
    return axis;
  };

  axis.ticks = function() {
    if (!arguments.length) return tickArguments_;
    tickArguments_ = arguments;
    return axis;
  };

  axis.tickFormat = function(x) {
    if (!arguments.length) return tickFormat_;
    tickFormat_ = x;
    return axis;
  };

  axis.tickSize = function(x, y, z) {
    if (!arguments.length) return tickMajorSize;
    var n = arguments.length - 1;
    tickMajorSize = +x;
    tickMinorSize = n > 1 ? +y : tickMajorSize;
    tickEndSize = n > 0 ? +arguments[n] : tickMajorSize;
    return axis;
  };

  axis.tickPadding = function(x) {
    if (!arguments.length) return tickPadding;
    tickPadding = +x;
    return axis;
  };

  axis.tickSubdivide = function(x) {
    if (!arguments.length) return tickSubdivide;
    tickSubdivide = +x;
    return axis;
  };

  return axis;
};

function d3_svg_axisX(selection, x) {
  selection.attr("transform", function(d) { return "translate(" + x(d) + ",0)"; });
}

function d3_svg_axisY(selection, y) {
  selection.attr("transform", function(d) { return "translate(0," + y(d) + ")"; });
}

function d3_svg_axisSubdivide(scale, ticks, m) {
  subticks = [];
  if (m && ticks.length > 1) {
    var extent = d3_scaleExtent(scale.domain()),
        subticks,
        i = -1,
        n = ticks.length,
        d = (ticks[1] - ticks[0]) / ++m,
        j,
        v;
    while (++i < n) {
      for (j = m; --j > 0;) {
        if ((v = +ticks[i] - j * d) >= extent[0]) {
          subticks.push(v);
        }
      }
    }
    for (--i, j = 0; ++j < m && (v = +ticks[i] + j * d) < extent[1];) {
      subticks.push(v);
    }
  }
  return subticks;
}
d3.svg.brush = function() {
  var event = d3.dispatch("brushstart", "brush", "brushend"),
      x, // x-scale, optional
      y, // y-scale, optional
      extent = [[0, 0], [0, 0]]; // [x0, y0], [x1, y1]

  function brush(g) {
    var resizes = x && y ? ["n", "e", "s", "w", "nw", "ne", "se", "sw"]
        : x ? ["e", "w"]
        : y ? ["n", "s"]
        : [];

    g.each(function() {
      var g = d3.select(this).on("mousedown.brush", down),
          bg = g.selectAll(".background").data([,]),
          fg = g.selectAll(".extent").data([,]),
          tz = g.selectAll(".resize").data(resizes, String),
          e;

      // An invisible, mouseable area for starting a new brush.
      bg.enter().append("svg:rect")
          .attr("class", "background")
          .style("visibility", "hidden")
          .style("pointer-events", "all")
          .style("cursor", "crosshair");

      // The visible brush extent; style this as you like!
      fg.enter().append("svg:rect")
          .attr("class", "extent")
          .style("cursor", "move");

      // More invisible rects for resizing the extent.
      tz.enter().append("svg:rect")
          .attr("class", function(d) { return "resize " + d; })
          .attr("width", 6)
          .attr("height", 6)
          .style("visibility", "hidden")
          .style("pointer-events", brush.empty() ? "none" : "all")
          .style("cursor", function(d) { return d3_svg_brushCursor[d]; });

      // Remove any superfluous resizers.
      tz.exit().remove();

      // Initialize the background to fill the defined range.
      // If the range isn't defined, you can post-process.
      if (x) {
        e = d3_scaleExtent(x.range());
        bg.attr("x", e[0]).attr("width", e[1] - e[0]);
        d3_svg_brushRedrawX(g, extent);
      }
      if (y) {
        e = d3_scaleExtent(y.range());
        bg.attr("y", e[0]).attr("height", e[1] - e[0]);
        d3_svg_brushRedrawY(g, extent);
      }
    });
  }

  function down() {
    var target = d3.select(d3.event.target);

    // Store some global state for the duration of the brush gesture.
    d3_svg_brush = brush;
    d3_svg_brushTarget = this;
    d3_svg_brushExtent = extent;
    d3_svg_brushOffset = d3.svg.mouse(d3_svg_brushTarget);

    // If the extent was clicked on, drag rather than brush;
    // store the offset between the mouse and extent origin instead.
    if (d3_svg_brushDrag = target.classed("extent")) {
      d3_svg_brushOffset[0] = extent[0][0] - d3_svg_brushOffset[0];
      d3_svg_brushOffset[1] = extent[0][1] - d3_svg_brushOffset[1];
    }

    // If a resizer was clicked on, record which side is to be resized.
    // Also, set the offset to the opposite side.
    else if (target.classed("resize")) {
      d3_svg_brushResize = d3.event.target.__data__;
      d3_svg_brushOffset[0] = extent[+/w$/.test(d3_svg_brushResize)][0];
      d3_svg_brushOffset[1] = extent[+/^n/.test(d3_svg_brushResize)][1];
    }

    // If the ALT key is down when starting a brush, the center is at the mouse.
    else if (d3.event.altKey) {
      d3_svg_brushCenter = d3_svg_brushOffset.slice();
    }

    // Restrict which dimensions are resized.
    d3_svg_brushX = !/^(n|s)$/.test(d3_svg_brushResize) && x;
    d3_svg_brushY = !/^(e|w)$/.test(d3_svg_brushResize) && y;

    // Notify listeners.
    d3_svg_brushDispatch = dispatcher(this, arguments);
    d3_svg_brushDispatch("brushstart");
    d3_svg_brushMove();
    d3_eventCancel();
  }

  function dispatcher(that, argumentz) {
    return function(type) {
      var e = d3.event;
      try {
        d3.event = {type: type, target: brush};
        event[type].apply(that, argumentz);
      } finally {
        d3.event = e;
      }
    };
  }

  brush.x = function(z) {
    if (!arguments.length) return x;
    x = z;
    return brush;
  };

  brush.y = function(z) {
    if (!arguments.length) return y;
    y = z;
    return brush;
  };

  brush.extent = function(z) {
    var x0, x1, y0, y1, t;

    // Invert the pixel extent to data-space.
    if (!arguments.length) {
      if (x) {
        x0 = x.invert(extent[0][0]), x1 = x.invert(extent[1][0]);
        if (x1 < x0) t = x0, x0 = x1, x1 = t;
      }
      if (y) {
        y0 = y.invert(extent[0][1]), y1 = y.invert(extent[1][1]);
        if (y1 < y0) t = y0, y0 = y1, y1 = t;
      }
      return x && y ? [[x0, y0], [x1, y1]] : x ? [x0, x1] : y && [y0, y1];
    }

    // Scale the data-space extent to pixels.
    if (x) {
      x0 = z[0], x1 = z[1];
      if (y) x0 = x0[0], x1 = x1[0];
      x0 = x(x0), x1 = x(x1);
      if (x1 < x0) t = x0, x0 = x1, x1 = t;
      extent[0][0] = x0, extent[1][0] = x1;
    }
    if (y) {
      y0 = z[0], y1 = z[1];
      if (x) y0 = y0[1], y1 = y1[1];
      y0 = y(y0), y1 = y(y1);
      if (y1 < y0) t = y0, y0 = y1, y1 = t;
      extent[0][1] = y0, extent[1][1] = y1;
    }

    return brush;
  };

  brush.clear = function() {
    extent[0][0] =
    extent[0][1] =
    extent[1][0] =
    extent[1][1] = 0;
    return brush;
  };

  brush.empty = function() {
    return (x && extent[0][0] === extent[1][0])
        || (y && extent[0][1] === extent[1][1]);
  };

  brush.on = function(type, listener) {
    event.on(type, listener);
    return brush;
  };

  d3.select(window)
      .on("mousemove.brush", d3_svg_brushMove)
      .on("mouseup.brush", d3_svg_brushUp)
      .on("keydown.brush", d3_svg_brushKeydown)
      .on("keyup.brush", d3_svg_brushKeyup);

  return brush;
};

var d3_svg_brush,
    d3_svg_brushDispatch,
    d3_svg_brushTarget,
    d3_svg_brushX,
    d3_svg_brushY,
    d3_svg_brushExtent,
    d3_svg_brushDrag,
    d3_svg_brushResize,
    d3_svg_brushCenter,
    d3_svg_brushOffset;

function d3_svg_brushRedrawX(g, extent) {
  g.select(".extent").attr("x", extent[0][0]);
  g.selectAll(".n,.s,.w,.nw,.sw").attr("x", extent[0][0] - 2);
  g.selectAll(".e,.ne,.se").attr("x", extent[1][0] - 3);
  g.selectAll(".extent,.n,.s").attr("width", extent[1][0] - extent[0][0]);
}

function d3_svg_brushRedrawY(g, extent) {
  g.select(".extent").attr("y", extent[0][1]);
  g.selectAll(".n,.e,.w,.nw,.ne").attr("y", extent[0][1] - 3);
  g.selectAll(".s,.se,.sw").attr("y", extent[1][1] - 4);
  g.selectAll(".extent,.e,.w").attr("height", extent[1][1] - extent[0][1]);
}

function d3_svg_brushKeydown() {
  if (d3.event.keyCode == 32 && d3_svg_brushTarget && !d3_svg_brushDrag) {
    d3_svg_brushCenter = null;
    d3_svg_brushOffset[0] -= d3_svg_brushExtent[1][0];
    d3_svg_brushOffset[1] -= d3_svg_brushExtent[1][1];
    d3_svg_brushDrag = 2;
    d3_eventCancel();
  }
}

function d3_svg_brushKeyup() {
  if (d3.event.keyCode == 32 && d3_svg_brushDrag == 2) {
    d3_svg_brushOffset[0] += d3_svg_brushExtent[1][0];
    d3_svg_brushOffset[1] += d3_svg_brushExtent[1][1];
    d3_svg_brushDrag = 0;
    d3_eventCancel();
  }
}

function d3_svg_brushMove() {
  if (d3_svg_brushOffset) {
    var mouse = d3.svg.mouse(d3_svg_brushTarget),
        g = d3.select(d3_svg_brushTarget);

    if (!d3_svg_brushDrag) {

      // If needed, determine the center from the current extent.
      if (d3.event.altKey) {
        if (!d3_svg_brushCenter) {
          d3_svg_brushCenter = [
            (d3_svg_brushExtent[0][0] + d3_svg_brushExtent[1][0]) / 2,
            (d3_svg_brushExtent[0][1] + d3_svg_brushExtent[1][1]) / 2
          ];
        }

        // Update the offset, for when the ALT key is released.
        d3_svg_brushOffset[0] = d3_svg_brushExtent[+(mouse[0] < d3_svg_brushCenter[0])][0];
        d3_svg_brushOffset[1] = d3_svg_brushExtent[+(mouse[1] < d3_svg_brushCenter[1])][1];
      }

      // When the ALT key is released, we clear the center.
      else d3_svg_brushCenter = null;
    }

    // Update the brush extent for each dimension.
    if (d3_svg_brushX) {
      d3_svg_brushMove1(mouse, d3_svg_brushX, 0);
      d3_svg_brushRedrawX(g, d3_svg_brushExtent);
    }
    if (d3_svg_brushY) {
      d3_svg_brushMove1(mouse, d3_svg_brushY, 1);
      d3_svg_brushRedrawY(g, d3_svg_brushExtent);
    }

    // Notify listeners.
    d3_svg_brushDispatch("brush");
  }
}

function d3_svg_brushMove1(mouse, scale, i) {
  var range = d3_scaleExtent(scale.range()),
      offset = d3_svg_brushOffset[i],
      size = d3_svg_brushExtent[1][i] - d3_svg_brushExtent[0][i],
      min,
      max;

  // When dragging, reduce the range by the extent size and offset.
  if (d3_svg_brushDrag) {
    range[0] -= offset;
    range[1] -= size + offset;
  }

  // Clamp the mouse so that the extent fits within the range extent.
  min = Math.max(range[0], Math.min(range[1], mouse[i]));

  // Compute the new extent bounds.
  if (d3_svg_brushDrag) {
    max = (min += offset) + size;
  } else {

    // If the ALT key is pressed, then preserve the center of the extent.
    if (d3_svg_brushCenter) offset = Math.max(range[0], Math.min(range[1], 2 * d3_svg_brushCenter[i] - min));

    // Compute the min and max of the offset and mouse.
    if (offset < min) {
      max = min;
      min = offset;
    } else {
      max = offset;
    }
  }

  // Update the stored bounds.
  d3_svg_brushExtent[0][i] = min;
  d3_svg_brushExtent[1][i] = max;
}

function d3_svg_brushUp() {
  if (d3_svg_brushOffset) {
    d3_svg_brushMove();
    d3.select(d3_svg_brushTarget).selectAll(".resize").style("pointer-events", d3_svg_brush.empty() ? "none" : "all");
    d3_svg_brushDispatch("brushend");
    d3_svg_brush =
    d3_svg_brushDispatch =
    d3_svg_brushTarget =
    d3_svg_brushX =
    d3_svg_brushY =
    d3_svg_brushExtent =
    d3_svg_brushDrag =
    d3_svg_brushResize =
    d3_svg_brushCenter =
    d3_svg_brushOffset = null;
    d3_eventCancel();
  }
}

var d3_svg_brushCursor = {
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
};
d3.behavior = {};
// TODO Track touch points by identifier.

d3.behavior.drag = function() {
  var event = d3.dispatch("drag", "dragstart", "dragend"),
      origin = null;

  function drag() {
    this
        .on("mousedown.drag", mousedown)
        .on("touchstart.drag", mousedown);

    d3.select(window)
        .on("mousemove.drag", d3_behavior_dragMove)
        .on("touchmove.drag", d3_behavior_dragMove)
        .on("mouseup.drag", d3_behavior_dragUp, true)
        .on("touchend.drag", d3_behavior_dragUp, true)
        .on("click.drag", d3_behavior_dragClick, true);
  }

  // snapshot the local context for subsequent dispatch
  function start() {
    d3_behavior_dragEvent = event;
    d3_behavior_dragEventTarget = d3.event.target;
    d3_behavior_dragTarget = this;
    d3_behavior_dragArguments = arguments;
    d3_behavior_dragOrigin = d3_behavior_dragPoint();
    if (origin) {
      d3_behavior_dragOffset = origin.apply(d3_behavior_dragTarget, d3_behavior_dragArguments);
      d3_behavior_dragOffset = [d3_behavior_dragOffset.x - d3_behavior_dragOrigin[0], d3_behavior_dragOffset.y - d3_behavior_dragOrigin[1]];
    } else {
      d3_behavior_dragOffset = [0, 0];
    }
    d3_behavior_dragMoved = 0;
  }

  function mousedown() {
    start.apply(this, arguments);
    d3_behavior_dragDispatch("dragstart");
  }

  drag.on = function(type, listener) {
    event.on(type, listener);
    return drag;
  };

  drag.origin = function(x) {
    if (!arguments.length) return origin;
    origin = x;
    return drag;
  };

  return drag;
};

var d3_behavior_dragEvent,
    d3_behavior_dragEventTarget,
    d3_behavior_dragTarget,
    d3_behavior_dragArguments,
    d3_behavior_dragOffset,
    d3_behavior_dragOrigin,
    d3_behavior_dragMoved;

function d3_behavior_dragDispatch(type) {
  var p = d3_behavior_dragPoint(),
      o = d3.event,
      e = d3.event = {type: type};

  if (p) {
    e.x = p[0] + d3_behavior_dragOffset[0];
    e.y = p[1] + d3_behavior_dragOffset[1];
    e.dx = p[0] - d3_behavior_dragOrigin[0];
    e.dy = p[1] - d3_behavior_dragOrigin[1];
    d3_behavior_dragMoved |= e.dx | e.dy;
    d3_behavior_dragOrigin = p;
  }

  try {
    d3_behavior_dragEvent[type].apply(d3_behavior_dragTarget, d3_behavior_dragArguments);
  } finally {
    d3.event = o;
  }

  o.stopPropagation();
  o.preventDefault();
}

function d3_behavior_dragPoint() {
  var p = d3_behavior_dragTarget.parentNode,
      t = d3.event.changedTouches;
  return p && (t
      ? d3.svg.touches(p, t)[0]
      : d3.svg.mouse(p));
}

function d3_behavior_dragMove() {
  if (!d3_behavior_dragTarget) return;
  var parent = d3_behavior_dragTarget.parentNode;

  // O NOES! The drag element was removed from the DOM.
  if (!parent) return d3_behavior_dragUp();

  d3_behavior_dragDispatch("drag");
  d3_eventCancel();
}

function d3_behavior_dragUp() {
  if (!d3_behavior_dragTarget) return;
  d3_behavior_dragDispatch("dragend");

  // If the node was moved, prevent the mouseup from propagating.
  // Also prevent the subsequent click from propagating (e.g., for anchors).
  if (d3_behavior_dragMoved) {
    d3_eventCancel();
    d3_behavior_dragMoved = d3.event.target === d3_behavior_dragEventTarget;
  }

  d3_behavior_dragEvent =
  d3_behavior_dragEventTarget =
  d3_behavior_dragTarget =
  d3_behavior_dragArguments =
  d3_behavior_dragOffset =
  d3_behavior_dragOrigin = null;
}

function d3_behavior_dragClick() {
  if (d3_behavior_dragMoved) {
    d3_eventCancel();
    d3_behavior_dragMoved = 0;
  }
}
// TODO unbind zoom behavior?
d3.behavior.zoom = function() {
  var xyz = [0, 0, 0],
      event = d3.dispatch("zoom"),
      extent = d3_behavior_zoomInfiniteExtent;

  function zoom() {
    this
        .on("mousedown.zoom", mousedown)
        .on("mousewheel.zoom", mousewheel)
        .on("DOMMouseScroll.zoom", mousewheel)
        .on("dblclick.zoom", dblclick)
        .on("touchstart.zoom", touchstart);

    d3.select(window)
        .on("mousemove.zoom", d3_behavior_zoomMousemove)
        .on("mouseup.zoom", d3_behavior_zoomMouseup)
        .on("touchmove.zoom", d3_behavior_zoomTouchmove)
        .on("touchend.zoom", d3_behavior_zoomTouchup)
        .on("click.zoom", d3_behavior_zoomClick, true);
  }

  // snapshot the local context for subsequent dispatch
  function start() {
    d3_behavior_zoomXyz = xyz;
    d3_behavior_zoomExtent = extent;
    d3_behavior_zoomDispatch = event.zoom;
    d3_behavior_zoomEventTarget = d3.event.target;
    d3_behavior_zoomTarget = this;
    d3_behavior_zoomArguments = arguments;
  }

  function mousedown() {
    start.apply(this, arguments);
    d3_behavior_zoomPanning = d3_behavior_zoomLocation(d3.svg.mouse(d3_behavior_zoomTarget));
    d3_behavior_zoomMoved = 0;
    d3.event.preventDefault();
    window.focus();
  }

  // store starting mouse location
  function mousewheel() {
    start.apply(this, arguments);
    if (!d3_behavior_zoomZooming) d3_behavior_zoomZooming = d3_behavior_zoomLocation(d3.svg.mouse(d3_behavior_zoomTarget));
    d3_behavior_zoomTo(d3_behavior_zoomDelta() + xyz[2], d3.svg.mouse(d3_behavior_zoomTarget), d3_behavior_zoomZooming);
  }

  function dblclick() {
    start.apply(this, arguments);
    var mouse = d3.svg.mouse(d3_behavior_zoomTarget);
    d3_behavior_zoomTo(d3.event.shiftKey ? Math.ceil(xyz[2] - 1) : Math.floor(xyz[2] + 1), mouse, d3_behavior_zoomLocation(mouse));
  }

  // doubletap detection
  function touchstart() {
    start.apply(this, arguments);
    var touches = d3_behavior_zoomTouchup(),
        touch,
        now = Date.now();
    if ((touches.length === 1) && (now - d3_behavior_zoomLast < 300)) {
      d3_behavior_zoomTo(1 + Math.floor(xyz[2]), touch = touches[0], d3_behavior_zoomLocations[touch.identifier]);
    }
    d3_behavior_zoomLast = now;
  }

  zoom.extent = function(x) {
    if (!arguments.length) return extent;
    extent = x == null ? d3_behavior_zoomInfiniteExtent : x;
    return zoom;
  };

  zoom.on = function(type, listener) {
    event.on(type, listener);
    return zoom;
  };

  return zoom;
};

var d3_behavior_zoomDiv,
    d3_behavior_zoomPanning,
    d3_behavior_zoomZooming,
    d3_behavior_zoomLocations = {}, // identifier -> location
    d3_behavior_zoomLast = 0,
    d3_behavior_zoomXyz,
    d3_behavior_zoomExtent,
    d3_behavior_zoomDispatch,
    d3_behavior_zoomEventTarget,
    d3_behavior_zoomTarget,
    d3_behavior_zoomArguments,
    d3_behavior_zoomMoved;

function d3_behavior_zoomLocation(point) {
  return [
    point[0] - d3_behavior_zoomXyz[0],
    point[1] - d3_behavior_zoomXyz[1],
    d3_behavior_zoomXyz[2]
  ];
}

// detect the pixels that would be scrolled by this wheel event
function d3_behavior_zoomDelta() {

  // mousewheel events are totally broken!
  // https://bugs.webkit.org/show_bug.cgi?id=40441
  // not only that, but Chrome and Safari differ in re. to acceleration!
  if (!d3_behavior_zoomDiv) {
    d3_behavior_zoomDiv = d3.select("body").append("div")
        .style("visibility", "hidden")
        .style("top", 0)
        .style("height", 0)
        .style("width", 0)
        .style("overflow-y", "scroll")
      .append("div")
        .style("height", "2000px")
      .node().parentNode;
  }

  var e = d3.event, delta;
  try {
    d3_behavior_zoomDiv.scrollTop = 1000;
    d3_behavior_zoomDiv.dispatchEvent(e);
    delta = 1000 - d3_behavior_zoomDiv.scrollTop;
  } catch (error) {
    delta = e.wheelDelta || (-e.detail * 5);
  }

  return delta * .005;
}

// Note: Since we don't rotate, it's possible for the touches to become
// slightly detached from their original positions. Thus, we recompute the
// touch points on touchend as well as touchstart!
function d3_behavior_zoomTouchup() {
  var touches = d3.svg.touches(d3_behavior_zoomTarget),
      i = -1,
      n = touches.length,
      touch;
  while (++i < n) d3_behavior_zoomLocations[(touch = touches[i]).identifier] = d3_behavior_zoomLocation(touch);
  return touches;
}

function d3_behavior_zoomTouchmove() {
  var touches = d3.svg.touches(d3_behavior_zoomTarget);
  switch (touches.length) {

    // single-touch pan
    case 1: {
      var touch = touches[0];
      d3_behavior_zoomTo(d3_behavior_zoomXyz[2], touch, d3_behavior_zoomLocations[touch.identifier]);
      break;
    }

    // double-touch pan + zoom
    case 2: {
      var p0 = touches[0],
          p1 = touches[1],
          p2 = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2],
          l0 = d3_behavior_zoomLocations[p0.identifier],
          l1 = d3_behavior_zoomLocations[p1.identifier],
          l2 = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2, l0[2]];
      d3_behavior_zoomTo(Math.log(d3.event.scale) / Math.LN2 + l0[2], p2, l2);
      break;
    }
  }
}

function d3_behavior_zoomMousemove() {
  d3_behavior_zoomZooming = null;
  if (d3_behavior_zoomPanning) {
    d3_behavior_zoomMoved = 1;
    d3_behavior_zoomTo(d3_behavior_zoomXyz[2], d3.svg.mouse(d3_behavior_zoomTarget), d3_behavior_zoomPanning);
  }
}

function d3_behavior_zoomMouseup() {
  if (d3_behavior_zoomPanning) {
    if (d3_behavior_zoomMoved) {
      d3_eventCancel();
      d3_behavior_zoomMoved = d3_behavior_zoomEventTarget === d3.event.target;
    }

    d3_behavior_zoomXyz =
    d3_behavior_zoomExtent =
    d3_behavior_zoomDispatch =
    d3_behavior_zoomEventTarget =
    d3_behavior_zoomTarget =
    d3_behavior_zoomArguments =
    d3_behavior_zoomPanning = null;
  }
}

function d3_behavior_zoomClick() {
  if (d3_behavior_zoomMoved) {
    d3_eventCancel();
    d3_behavior_zoomMoved = 0;
  }
}

function d3_behavior_zoomTo(z, x0, x1) {
  z = d3_behavior_zoomExtentClamp(z, 2);
  var j = Math.pow(2, d3_behavior_zoomXyz[2]),
      k = Math.pow(2, z),
      K = Math.pow(2, (d3_behavior_zoomXyz[2] = z) - x1[2]),
      x_ = d3_behavior_zoomXyz[0],
      y_ = d3_behavior_zoomXyz[1],
      x = d3_behavior_zoomXyz[0] = d3_behavior_zoomExtentClamp((x0[0] - x1[0] * K), 0, k),
      y = d3_behavior_zoomXyz[1] = d3_behavior_zoomExtentClamp((x0[1] - x1[1] * K), 1, k),
      o = d3.event; // Events can be reentrant (e.g., focus).

  d3.event = {
    scale: k,
    translate: [x, y],
    transform: function(sx, sy) {
      if (sx) transform(sx, x_, x);
      if (sy) transform(sy, y_, y);
    }
  };

  function transform(scale, a, b) {
    scale.domain(scale.range().map(function(v) { return scale.invert(((v - b) * j) / k + a); }));
  }

  try {
    d3_behavior_zoomDispatch.apply(d3_behavior_zoomTarget, d3_behavior_zoomArguments);
  } finally {
    d3.event = o;
  }

  o.preventDefault();
}

var d3_behavior_zoomInfiniteExtent = [
  [-Infinity, Infinity],
  [-Infinity, Infinity],
  [-Infinity, Infinity]
];

function d3_behavior_zoomExtentClamp(x, i, k) {
  var range = d3_behavior_zoomExtent[i],
      r0 = range[0],
      r1 = range[1];
  return arguments.length === 3
      ? Math.max(r1 * (r1 === Infinity ? -Infinity : 1 / k - 1),
        Math.min(r0 === -Infinity ? Infinity : r0, x / k)) * k
      : Math.max(r0, Math.min(r1, x));
}
})();

/* 
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

function loadGeoserverLayers(map) {
        $.ajax({
        url: Routing.generate('default_geoserver_layers'),
        method: 'GET',
        success: function(response) {
            var result;
            if (typeof response !== 'object')
                result = JSON.parse(response);
            else
                result = response;

            //  alert(result.success===true);
            if (result.success === true && result.layers) {

                //    alert(JSON.stringify(result.layers));
                // alert(result.layers.length);

                var keys = Object.keys(result.layers).map(function(k) {

                    return k;
                });

                // alert(keys.length + "," + keys[0]);

                for (var k = 0; k < keys.length; k++)
                {
                    var layer = result.layers[keys[k]];
                    map.dataLayers[map.dataLayers.length] = {'layerType':layer.layerType ,'defaultShowOnMap': layer.defaultShowOnMap, 'layer': null, 'minZoom': layer.minZoom, 'maxZoom': layer.maxZoom, 'index_id': k, 'layerId': layer.id, title: layer.layerTitle, 'name': layer.layerName, 'hostname': layer.hostName, type: 'shapefile_topojson'};
                }
                map.layersControl.refreshOverlays();
            }
        }
    });

}

/*
 * heatmap.js v2.0.0 | JavaScript Heatmap Library
 *
 * Copyright 2008-2014 Patrick Wied <heatmapjs@patrick-wied.at> - All rights reserved.
 * Dual licensed under MIT and Beerware license 
 *
 * :: 2014-08-08 00:10
 */
;
(function(global) {
// Heatmap Config stores default values and will be merged with instance config
    var HeatmapConfig = {
        defaultRadius: 40,
        defaultRenderer: 'canvas2d',
        defaultGradient: {0.25: "rgb(0,0,255)", 0.55: "rgb(0,255,0)", 0.85: "yellow", 1.0: "rgb(255,0,0)"},
        defaultMaxOpacity: 1,
        defaultMinOpacity: 0,
        defaultBlur: .85,
        defaultXField: 'x',
        defaultYField: 'y',
        defaultValueField: 'value',
        plugins: {}
    };
    var Store = (function StoreClosure() {

        var Store = function Store(config) {
            this._coordinator = {};
            this._data = [];
            this._radi = [];
            this._min = 0;
            this._max = 1;
            this._xField = config['xField'] || config.defaultXField;
            this._yField = config['yField'] || config.defaultYField;
            this._valueField = config['valueField'] || config.defaultValueField;

            if (config["radius"]) {
                this._cfgRadius = config["radius"];
            }
        };

        var defaultRadius = HeatmapConfig.defaultRadius;

        Store.prototype = {
            // when forceRender = false -> called from setData, omits renderall event
            _organiseData: function(dataPoint, forceRender) {
                var x = dataPoint[this._xField];
                var y = dataPoint[this._yField];
                var radi = this._radi;
                var store = this._data;
                var max = this._max;
                var min = this._min;
                var value = dataPoint[this._valueField] || 1;
                var radius = dataPoint.radius || this._cfgRadius || defaultRadius;

                if (!store[x]) {
                    store[x] = [];
                    radi[x] = [];
                }

                if (!store[x][y]) {
                    store[x][y] = value;
                    radi[x][y] = radius;
                } else {
                    store[x][y] += value;
                }

                if (store[x][y] > max) {
                    if (!forceRender) {
                        this._max = store[x][y];
                    } else {
                        this.setDataMax(store[x][y]);
                    }
                    return false;
                } else {
                    return {
                        x: x,
                        y: y,
                        value: value,
                        radius: radius,
                        min: min,
                        max: max
                    };
                }
            },
            _unOrganizeData: function() {
                var unorganizedData = [];
                var data = this._data;
                var radi = this._radi;

                for (var x in data) {
                    for (var y in data[x]) {

                        unorganizedData.push({
                            x: x,
                            y: y,
                            radius: radi[x][y],
                            value: data[x][y]
                        });

                    }
                }
                return {
                    min: this._min,
                    max: this._max,
                    data: unorganizedData
                };
            },
            _onExtremaChange: function() {
                this._coordinator.emit('extremachange', {
                    min: this._min,
                    max: this._max
                });
            },
            addData: function() {
                if (arguments[0].length > 0) {
                    var dataArr = arguments[0];
                    var dataLen = dataArr.length;
                    while (dataLen--) {
                        this.addData.call(this, dataArr[dataLen]);
                    }
                } else {
                    // add to store  
                    var organisedEntry = this._organiseData(arguments[0], true);
                    if (organisedEntry) {
                        this._coordinator.emit('renderpartial', {
                            min: this._min,
                            max: this._max,
                            data: [organisedEntry]
                        });
                    }
                }
                return this;
            },
            setData: function(data) {
                var dataPoints = data.data;
                var pointsLen = dataPoints.length;


                // reset data arrays
                this._data = [];
                this._radi = [];

                for (var i = 0; i < pointsLen; i++) {
                    this._organiseData(dataPoints[i], false);
                }
                this._max = data.max;
                this._min = data.min || 0;

                this._onExtremaChange();
                this._coordinator.emit('renderall', this._getInternalData());
                return this;
            },
            removeData: function() {
                // TODO: implement
            },
            setDataMax: function(max) {
                this._max = max;
                this._onExtremaChange();
                this._coordinator.emit('renderall', this._getInternalData());
                return this;
            },
            setDataMin: function(min) {
                this._min = min;
                this._onExtremaChange();
                this._coordinator.emit('renderall', this._getInternalData());
                return this;
            },
            setCoordinator: function(coordinator) {
                this._coordinator = coordinator;
            },
            _getInternalData: function() {
                return {
                    max: this._max,
                    min: this._min,
                    data: this._data,
                    radi: this._radi
                };
            },
            getData: function() {
                return this._unOrganizeData();
            }/*,
             
             TODO: rethink.
             
             getValueAt: function(point) {
             var value;
             var radius = 100;
             var x = point.x;
             var y = point.y;
             var data = this._data;
             
             if (data[x] && data[x][y]) {
             return data[x][y];
             } else {
             var values = [];
             // radial search for datapoints based on default radius
             for(var distance = 1; distance < radius; distance++) {
             var neighbors = distance * 2 +1;
             var startX = x - distance;
             var startY = y - distance;
             
             for(var i = 0; i < neighbors; i++) {
             for (var o = 0; o < neighbors; o++) {
             if ((i == 0 || i == neighbors-1) || (o == 0 || o == neighbors-1)) {
             if (data[startY+i] && data[startY+i][startX+o]) {
             values.push(data[startY+i][startX+o]);
             }
             } else {
             continue;
             } 
             }
             }
             }
             if (values.length > 0) {
             return Math.max.apply(Math, values);
             }
             }
             return false;
             }*/
        };


        return Store;
    })();

    var Canvas2dRenderer = (function Canvas2dRendererClosure() {

        var _getColorPalette = function(config) {
            var gradientConfig = config.gradient || config.defaultGradient;
            var paletteCanvas = document.createElement('canvas');
            var paletteCtx = paletteCanvas.getContext('2d');

            paletteCanvas.width = 256;
            paletteCanvas.height = 1;

            var gradient = paletteCtx.createLinearGradient(0, 0, 256, 1);
            for (var key in gradientConfig) {
                gradient.addColorStop(key, gradientConfig[key]);
            }

            paletteCtx.fillStyle = gradient;
            paletteCtx.fillRect(0, 0, 256, 1);

            return paletteCtx.getImageData(0, 0, 256, 1).data;
        };

        var _getPointTemplate = function(radius, blurFactor) {
            var tplCanvas = document.createElement('canvas');
            var tplCtx = tplCanvas.getContext('2d');
            var x = radius;
            var y = radius;
            tplCanvas.width = tplCanvas.height = radius * 2;

            if (blurFactor == 1) {
                tplCtx.beginPath();
                tplCtx.arc(x, y, radius, 0, 2 * Math.PI, false);
                tplCtx.fillStyle = 'rgba(0,0,0,1)';
                tplCtx.fill();
            } else {
                var gradient = tplCtx.createRadialGradient(x, y, radius * blurFactor, x, y, radius);
                gradient.addColorStop(0, 'rgba(0,0,0,1)');
                gradient.addColorStop(1, 'rgba(0,0,0,0)');
                tplCtx.fillStyle = gradient;
                tplCtx.fillRect(0, 0, 2 * radius, 2 * radius);
            }



            return tplCanvas;
        };

        var _prepareData = function(data) {
            var renderData = [];
            var min = data.min;
            var max = data.max;
            var radi = data.radi;
            var data = data.data;

            var xValues = Object.keys(data);
            var xValuesLen = xValues.length;

            while (xValuesLen--) {
                var xValue = xValues[xValuesLen];
                var yValues = Object.keys(data[xValue]);
                var yValuesLen = yValues.length;
                while (yValuesLen--) {
                    var yValue = yValues[yValuesLen];
                    var value = data[xValue][yValue];
                    var radius = radi[xValue][yValue];
                    renderData.push({
                        x: xValue,
                        y: yValue,
                        value: value,
                        radius: radius
                    });
                }
            }

            return {
                min: min,
                max: max,
                data: renderData
            };
        };


        function Canvas2dRenderer(config) {
            var container = config.container;
            var shadowCanvas = this.shadowCanvas = document.createElement('canvas');
            var canvas = this.canvas = config.canvas || document.createElement('canvas');
            var renderBoundaries = this._renderBoundaries = [10000, 10000, 0, 0];

            var computed = getComputedStyle(config.container) || {};

            canvas.className = 'heatmap-canvas';

            this._width = canvas.width = shadowCanvas.width = +(computed.width.replace(/px/, ''));
            this._height = canvas.height = shadowCanvas.height = +(computed.height.replace(/px/, ''));

            this.shadowCtx = shadowCanvas.getContext('2d');
            this.ctx = canvas.getContext('2d');

            // @TODO:
            // conditional wrapper

            canvas.style.cssText = shadowCanvas.style.cssText = 'position:absolute;left:0;top:0;';

            container.style.position = 'relative';
            container.appendChild(canvas);

            this._palette = _getColorPalette(config);
            this._templates = {};

            this._setStyles(config);
        }
        ;

        Canvas2dRenderer.prototype = {
            renderPartial: function(data) {
                this._drawAlpha(data);
                this._colorize();
            },
            renderAll: function(data) {
                // reset render boundaries
                this._clear();
                this._drawAlpha(_prepareData(data));
                this._colorize();
            },
            _updateGradient: function(config) {
                this._palette = _getColorPalette(config);
            },
            updateConfig: function(config) {
                if (config['gradient']) {
                    this._updateGradient(config);
                }
                this._setStyles(config);
            },
            setDimensions: function(width, height) {
                this._width = width;
                this._height = height;
                this.canvas.width = this.shadowCanvas.width = width;
                this.canvas.height = this.shadowCanvas.height = height;
            },
            _clear: function() {
                this.shadowCtx.clearRect(0, 0, this._width, this._height);
                this.ctx.clearRect(0, 0, this._width, this._height);
            },
            _setStyles: function(config) {
                this._blur = (config.blur == 0) ? 0 : (config.blur || config.defaultBlur);

                if (config.backgroundColor) {
                    this.canvas.style.backgroundColor = config.backgroundColor;
                }

                this._opacity = (config.opacity || 0) * 255;
                this._maxOpacity = (config.maxOpacity || config.defaultMaxOpacity) * 255;
                this._minOpacity = (config.minOpacity || config.defaultMinOpacity) * 255;
                this._useGradientOpacity = !!config.useGradientOpacity;
            },
            _drawAlpha: function(data) {
                var min = this._min = data.min;
                var max = this._max = data.max;
                var data = data.data || [];
                var dataLen = data.length;
                // on a point basis?
                var blur = 1 - this._blur;

                while (dataLen--) {

                    var point = data[dataLen];

                    var x = point.x;
                    var y = point.y;
                    var radius = point.radius;
                    // if value is bigger than max
                    // use max as value
                    var value = Math.min(point.value, max);
                    var rectX = x - radius;
                    var rectY = y - radius;
                    var shadowCtx = this.shadowCtx;




                    var tpl;
                    if (!this._templates[radius]) {
                        this._templates[radius] = tpl = _getPointTemplate(radius, blur);
                    } else {
                        tpl = this._templates[radius];
                    }

                    shadowCtx.globalAlpha = value / (Math.abs(max - min));

                    shadowCtx.drawImage(tpl, rectX, rectY);

                    // update renderBoundaries
                    if (rectX < this._renderBoundaries[0]) {
                        this._renderBoundaries[0] = rectX;
                    }
                    if (rectY < this._renderBoundaries[1]) {
                        this._renderBoundaries[1] = rectY;
                    }
                    if (rectX + 2 * radius > this._renderBoundaries[2]) {
                        this._renderBoundaries[2] = rectX + 2 * radius;
                    }
                    if (rectY + 2 * radius > this._renderBoundaries[3]) {
                        this._renderBoundaries[3] = rectY + 2 * radius;
                    }

                }
            },
            _colorize: function() {
                var x = this._renderBoundaries[0];
                var y = this._renderBoundaries[1];
                var width = this._renderBoundaries[2] - x;
                var height = this._renderBoundaries[3] - y;
                var maxWidth = this._width;
                var maxHeight = this._height;
                var opacity = this._opacity;
                var maxOpacity = this._maxOpacity;
                var minOpacity = this._minOpacity;
                var useGradientOpacity = this._useGradientOpacity;
                 
                if (x < 0) {
                    x = 0;
                }
                if (y < 0) {
                    y = 0;
                }
                if (x + width > maxWidth) {
                    width = maxWidth - x;
                }
                if (y + height > maxHeight) {
                    height = maxHeight - y;
                }

                var img = this.shadowCtx.getImageData(x, y, width, height);
                var imgData = img.data;
                var len = imgData.length;
                var palette = this._palette;


                for (var i = 3; i < len; i += 4) {
                    var alpha = imgData[i];
                    var offset = alpha * 4;


                    if (!offset) {
                        continue;
                    }

                    var finalAlpha;
                    if (opacity > 0) {
                        finalAlpha = opacity;
                    } else {
                        if (alpha < maxOpacity) {
                            if (alpha < minOpacity) {
                                finalAlpha = minOpacity;
                            } else {
                                finalAlpha = alpha;
                            }
                        } else {
                            finalAlpha = maxOpacity;
                        }
                    }

                    imgData[i - 3] = palette[offset];
                    imgData[i - 2] = palette[offset + 1];
                    imgData[i - 1] = palette[offset + 2];
                    imgData[i] = useGradientOpacity ? palette[offset + 3] : finalAlpha;

                }

                img.data = imgData;
                this.ctx.putImageData(img, x, y);

                this._renderBoundaries = [1000, 1000, 0, 0];

            },
            getValueAt: function(point) {
                var value;
                var shadowCtx = this.shadowCtx;
                var img = shadowCtx.getImageData(point.x, point.y, 1, 1);
                var data = img.data[3];
                var max = this._max;
                var min = this._min;

                value = (Math.abs(max - min) * (data / 255)) >> 0;

                return value;
            },
            getDataURL: function() {
                return this.canvas.toDataURL();
            }
        };


        return Canvas2dRenderer;
    })();

    var Renderer = (function RendererClosure() {

        var rendererFn = false;

        if (HeatmapConfig['defaultRenderer'] === 'canvas2d') {
            rendererFn = Canvas2dRenderer;
        }

        return rendererFn;
    })();


    var Util = {
        merge: function() {
            var merged = {};
            var argsLen = arguments.length;
            for (var i = 0; i < argsLen; i++) {
                var obj = arguments[i]
                for (var key in obj) {
                    merged[key] = obj[key];
                }
            }
            return merged;
        }
    };
// Heatmap Constructor
    var Heatmap = (function HeatmapClosure() {

        var Coordinator = (function CoordinatorClosure() {

            function Coordinator() {
                this.cStore = {};
            }
            ;

            Coordinator.prototype = {
                on: function(evtName, callback, scope) {
                    var cStore = this.cStore;

                    if (!cStore[evtName]) {
                        cStore[evtName] = [];
                    }
                    cStore[evtName].push((function(data) {
                        return callback.call(scope, data);
                    }));
                },
                emit: function(evtName, data) {
                    var cStore = this.cStore;
                    if (cStore[evtName]) {
                        var len = cStore[evtName].length;
                        for (var i = 0; i < len; i++) {
                            var callback = cStore[evtName][i];
                            callback(data);
                        }
                    }
                }
            };

            return Coordinator;
        })();


        var _connect = function(scope) {
            var renderer = scope._renderer;
            var coordinator = scope._coordinator;
            var store = scope._store;

            coordinator.on('renderpartial', renderer.renderPartial, renderer);
            coordinator.on('renderall', renderer.renderAll, renderer);
            coordinator.on('extremachange', function(data) {
                scope._config.onExtremaChange &&
                        scope._config.onExtremaChange({
                            min: data.min,
                            max: data.max,
                            gradient: scope._config['gradient'] || scope._config['defaultGradient']
                        });
            });
            store.setCoordinator(coordinator);
        };


        function Heatmap() {
            var config = this._config = Util.merge(HeatmapConfig, arguments[0] || {});
            this._coordinator = new Coordinator();
            if (config['plugin']) {
                var pluginToLoad = config['plugin'];
                if (!HeatmapConfig.plugins[pluginToLoad]) {
                    throw new Error('Plugin \'' + pluginToLoad + '\' not found. Maybe it was not registered.');
                } else {
                    var plugin = HeatmapConfig.plugins[pluginToLoad];
                    // set plugin renderer and store
                    this._renderer = plugin.renderer;
                    this._store = plugin.store;
                }
            } else {
                this._renderer = new Renderer(config);
                this._store = new Store(config);
            }
            _connect(this);
        }
        ;

        // @TODO:
        // add API documentation
        Heatmap.prototype = {
            addData: function() {
                this._store.addData.apply(this._store, arguments);
                return this;
            },
            removeData: function() {
                this._store.removeData && this._store.removeData.apply(this._store, arguments);
                return this;
            },
            setData: function() {
                this._store.setData.apply(this._store, arguments);
                return this;
            },
            setDataMax: function() {
                this._store.setDataMax.apply(this._store, arguments);
                return this;
            },
            setDataMin: function() {
                this._store.setDataMin.apply(this._store, arguments);
                return this;
            },
            configure: function(config) {
                this._config = Util.merge(this._config, config);
                this._renderer.updateConfig(this._config);
                this._coordinator.emit('renderall', this._store._getInternalData());
                return this;
            },
            repaint: function() {
                this._coordinator.emit('renderall', this._store._getInternalData());
                return this;
            },
            getData: function() {
                return this._store.getData();
            },
            getDataURL: function() {
                return this._renderer.getDataURL();
            },
            updateRadius: function(newradius) {

                 var data = this._store._radi;
                 var length = data.length;
                 alert(length);
             },
            getValueAt: function(point) {

                if (this._store.getValueAt) {
                    return this._store.getValueAt(point);
                } else if (this._renderer.getValueAt) {
                    return this._renderer.getValueAt(point);
                } else {
                    return null;
                }
            }
        };

        return Heatmap;

    })();


// core
    var heatmapFactory = {
        create: function(config) {
            return new Heatmap(config);
        },
        register: function(pluginKey, plugin) {
            HeatmapConfig.plugins[pluginKey] = plugin;
        }
    };

    global['h337'] = heatmapFactory;

})(this || window);
/*
 html2canvas 0.4.1 <http://html2canvas.hertzen.com>
 Copyright (c) 2013 Niklas von Hertzen
 
 Released under MIT License
 */

(function(window, document, undefined) {

    "use strict";

    var _html2canvas = {},
            previousElement,
            computedCSS,
            html2canvas;

    _html2canvas.Util = {};

    _html2canvas.Util.log = function(a) {
        if (_html2canvas.logging && window.console && window.console.log) {
            window.console.log(a);
        }
    };

    _html2canvas.Util.trimText = (function(isNative) {
        return function(input) {
            return isNative ? isNative.apply(input) : ((input || '') + '').replace(/^\s+|\s+$/g, '');
        };
    })(String.prototype.trim);

    _html2canvas.Util.asFloat = function(v) {
        return parseFloat(v);
    };

    (function() {
        // TODO: support all possible length values
        var TEXT_SHADOW_PROPERTY = /((rgba|rgb)\([^\)]+\)(\s-?\d+px){0,})/g;
        var TEXT_SHADOW_VALUES = /(-?\d+px)|(#.+)|(rgb\(.+\))|(rgba\(.+\))/g;
        _html2canvas.Util.parseTextShadows = function(value) {
            if (!value || value === 'none') {
                return [];
            }

            // find multiple shadow declarations
            var shadows = value.match(TEXT_SHADOW_PROPERTY),
                    results = [];
            for (var i = 0; shadows && (i < shadows.length); i++) {
                var s = shadows[i].match(TEXT_SHADOW_VALUES);
                results.push({
                    color: s[0],
                    offsetX: s[1] ? s[1].replace('px', '') : 0,
                    offsetY: s[2] ? s[2].replace('px', '') : 0,
                    blur: s[3] ? s[3].replace('px', '') : 0
                });
            }
            return results;
        };
    })();

    _html2canvas.Util.parseBackgroundImage = function(value) {
        var whitespace = ' \r\n\t',
                method, definition, prefix, prefix_i, block, results = [],
                c, mode = 0, numParen = 0, quote, args;

        var appendResult = function() {
            if (method) {
                if (definition.substr(0, 1) === '"') {
                    definition = definition.substr(1, definition.length - 2);
                }
                if (definition) {
                    args.push(definition);
                }
                if (method.substr(0, 1) === '-' &&
                        (prefix_i = method.indexOf('-', 1) + 1) > 0) {
                    prefix = method.substr(0, prefix_i);
                    method = method.substr(prefix_i);
                }
                results.push({
                    prefix: prefix,
                    method: method.toLowerCase(),
                    value: block,
                    args: args
                });
            }
            args = []; //for some odd reason, setting .length = 0 didn't work in safari
            method =
                    prefix =
                    definition =
                    block = '';
        };

        appendResult();
        for (var i = 0, ii = value.length; i < ii; i++) {
            c = value[i];
            if (mode === 0 && whitespace.indexOf(c) > -1) {
                continue;
            }
            switch (c) {
                case '"':
                    if (!quote) {
                        quote = c;
                    }
                    else if (quote === c) {
                        quote = null;
                    }
                    break;

                case '(':
                    if (quote) {
                        break;
                    }
                    else if (mode === 0) {
                        mode = 1;
                        block += c;
                        continue;
                    } else {
                        numParen++;
                    }
                    break;

                case ')':
                    if (quote) {
                        break;
                    }
                    else if (mode === 1) {
                        if (numParen === 0) {
                            mode = 0;
                            block += c;
                            appendResult();
                            continue;
                        } else {
                            numParen--;
                        }
                    }
                    break;

                case ',':
                    if (quote) {
                        break;
                    }
                    else if (mode === 0) {
                        appendResult();
                        continue;
                    }
                    else if (mode === 1) {
                        if (numParen === 0 && !method.match(/^url$/i)) {
                            args.push(definition);
                            definition = '';
                            block += c;
                            continue;
                        }
                    }
                    break;
            }

            block += c;
            if (mode === 0) {
                method += c;
            }
            else {
                definition += c;
            }
        }
        appendResult();

        return results;
    };

    _html2canvas.Util.Bounds = function(element) {
        var clientRect, bounds = {};

        if (element.getBoundingClientRect) {
            clientRect = element.getBoundingClientRect();

            // TODO add scroll position to bounds, so no scrolling of window necessary
            bounds.top = clientRect.top;
            bounds.bottom = clientRect.bottom || (clientRect.top + clientRect.height);
            bounds.left = clientRect.left;

            bounds.width = element.offsetWidth;
            bounds.height = element.offsetHeight;
        }

        return bounds;
    };

// TODO ideally, we'd want everything to go through this function instead of Util.Bounds,
// but would require further work to calculate the correct positions for elements with offsetParents
    _html2canvas.Util.OffsetBounds = function(element) {
        var parent = element.offsetParent ? _html2canvas.Util.OffsetBounds(element.offsetParent) : {top: 0, left: 0};

        return {
            top: element.offsetTop + parent.top,
            bottom: element.offsetTop + element.offsetHeight + parent.top,
            left: element.offsetLeft + parent.left,
            width: element.offsetWidth,
            height: element.offsetHeight
        };
    };

    function toPX(element, attribute, value) {
        var rsLeft = element.runtimeStyle && element.runtimeStyle[attribute],
                left,
                style = element.style;

        // Check if we are not dealing with pixels, (Opera has issues with this)
        // Ported from jQuery css.js
        // From the awesome hack by Dean Edwards
        // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

        // If we're not dealing with a regular pixel number
        // but a number that has a weird ending, we need to convert it to pixels

        if (!/^-?[0-9]+\.?[0-9]*(?:px)?$/i.test(value) && /^-?\d/.test(value)) {
            // Remember the original values
            left = style.left;

            // Put in the new values to get a computed value out
            if (rsLeft) {
                element.runtimeStyle.left = element.currentStyle.left;
            }
            style.left = attribute === "fontSize" ? "1em" : (value || 0);
            value = style.pixelLeft + "px";

            // Revert the changed values
            style.left = left;
            if (rsLeft) {
                element.runtimeStyle.left = rsLeft;
            }
        }

        if (!/^(thin|medium|thick)$/i.test(value)) {
            return Math.round(parseFloat(value)) + "px";
        }

        return value;
    }

    function asInt(val) {
        return parseInt(val, 10);
    }

    function isPercentage(value) {
        return value.toString().indexOf("%") !== -1;
    }

    function parseBackgroundSizePosition(value, element, attribute, index) {
        value = (value || '').split(',');
        value = value[index || 0] || value[0] || 'auto';
        value = _html2canvas.Util.trimText(value).split(' ');
        if (attribute === 'backgroundSize' && (value[0] && value[0].match(/^(cover|contain|auto)$/))) {
            return value;
        } else {
            value[0] = (value[0].indexOf("%") === -1) ? toPX(element, attribute + "X", value[0]) : value[0];
            if (value[1] === undefined) {
                if (attribute === 'backgroundSize') {
                    value[1] = 'auto';
                    return value;
                } else {
                    // IE 9 doesn't return double digit always
                    value[1] = value[0];
                }
            }
            value[1] = (value[1].indexOf("%") === -1) ? toPX(element, attribute + "Y", value[1]) : value[1];
        }
        return value;
    }

    _html2canvas.Util.getCSS = function(element, attribute, index) {
        if (previousElement !== element) {
            computedCSS = document.defaultView.getComputedStyle(element, null);
        }

        var value = computedCSS[attribute];

        if (/^background(Size|Position)$/.test(attribute)) {
            return parseBackgroundSizePosition(value, element, attribute, index);
        } else if (/border(Top|Bottom)(Left|Right)Radius/.test(attribute)) {
            var arr = value.split(" ");
            if (arr.length <= 1) {
                arr[1] = arr[0];
            }
            return arr.map(asInt);
        }

        return value;
    };

    _html2canvas.Util.resizeBounds = function(current_width, current_height, target_width, target_height, stretch_mode) {
        var target_ratio = target_width / target_height,
                current_ratio = current_width / current_height,
                output_width, output_height;

        if (!stretch_mode || stretch_mode === 'auto') {
            output_width = target_width;
            output_height = target_height;
        } else if (target_ratio < current_ratio ^ stretch_mode === 'contain') {
            output_height = target_height;
            output_width = target_height * current_ratio;
        } else {
            output_width = target_width;
            output_height = target_width / current_ratio;
        }

        return {
            width: output_width,
            height: output_height
        };
    };

    _html2canvas.Util.BackgroundPosition = function(element, bounds, image, imageIndex, backgroundSize) {
        var backgroundPosition = _html2canvas.Util.getCSS(element, 'backgroundPosition', imageIndex),
                leftPosition,
                topPosition;
        if (backgroundPosition.length === 1) {
            backgroundPosition = [backgroundPosition[0], backgroundPosition[0]];
        }

        if (isPercentage(backgroundPosition[0])) {
            leftPosition = (bounds.width - (backgroundSize || image).width) * (parseFloat(backgroundPosition[0]) / 100);
        } else {
            leftPosition = parseInt(backgroundPosition[0], 10);
        }

        if (backgroundPosition[1] === 'auto') {
            topPosition = leftPosition / image.width * image.height;
        } else if (isPercentage(backgroundPosition[1])) {
            topPosition = (bounds.height - (backgroundSize || image).height) * parseFloat(backgroundPosition[1]) / 100;
        } else {
            topPosition = parseInt(backgroundPosition[1], 10);
        }

        if (backgroundPosition[0] === 'auto') {
            leftPosition = topPosition / image.height * image.width;
        }

        return {left: leftPosition, top: topPosition};
    };

    _html2canvas.Util.BackgroundSize = function(element, bounds, image, imageIndex) {
        var backgroundSize = _html2canvas.Util.getCSS(element, 'backgroundSize', imageIndex), width, height;

        if (backgroundSize.length === 1) {
            backgroundSize = [backgroundSize[0], backgroundSize[0]];
        }

        if (isPercentage(backgroundSize[0])) {
            width = bounds.width * parseFloat(backgroundSize[0]) / 100;
        } else if (/contain|cover/.test(backgroundSize[0])) {
            return _html2canvas.Util.resizeBounds(image.width, image.height, bounds.width, bounds.height, backgroundSize[0]);
        } else {
            width = parseInt(backgroundSize[0], 10);
        }

        if (backgroundSize[0] === 'auto' && backgroundSize[1] === 'auto') {
            height = image.height;
        } else if (backgroundSize[1] === 'auto') {
            height = width / image.width * image.height;
        } else if (isPercentage(backgroundSize[1])) {
            height = bounds.height * parseFloat(backgroundSize[1]) / 100;
        } else {
            height = parseInt(backgroundSize[1], 10);
        }

        if (backgroundSize[0] === 'auto') {
            width = height / image.height * image.width;
        }

        return {width: width, height: height};
    };

    _html2canvas.Util.BackgroundRepeat = function(element, imageIndex) {
        var backgroundRepeat = _html2canvas.Util.getCSS(element, "backgroundRepeat").split(",").map(_html2canvas.Util.trimText);
        return backgroundRepeat[imageIndex] || backgroundRepeat[0];
    };

    _html2canvas.Util.Extend = function(options, defaults) {
        for (var key in options) {
            if (options.hasOwnProperty(key)) {
                defaults[key] = options[key];
            }
        }
        return defaults;
    };


    /*
     * Derived from jQuery.contents()
     * Copyright 2010, John Resig
     * Dual licensed under the MIT or GPL Version 2 licenses.
     * http://jquery.org/license
     */
    _html2canvas.Util.Children = function(elem) {
        var children;
        try {
            children = (elem.nodeName && elem.nodeName.toUpperCase() === "IFRAME") ? elem.contentDocument || elem.contentWindow.document : (function(array) {
                var ret = [];
                if (array !== null) {
                    (function(first, second) {
                        var i = first.length,
                                j = 0;

                        if (typeof second.length === "number") {
                            for (var l = second.length; j < l; j++) {
                                first[i++] = second[j];
                            }
                        } else {
                            while (second[j] !== undefined) {
                                first[i++] = second[j++];
                            }
                        }

                        first.length = i;

                        return first;
                    })(ret, array);
                }
                return ret;
            })(elem.childNodes);

        } catch (ex) {
            _html2canvas.Util.log("html2canvas.Util.Children failed with exception: " + ex.message);
            children = [];
        }
        return children;
    };

    _html2canvas.Util.isTransparent = function(backgroundColor) {
        return (!backgroundColor || backgroundColor === "transparent" || backgroundColor === "rgba(0, 0, 0, 0)");
    };

    _html2canvas.Util.Font = (function() {

        var fontData = {};

        return function(font, fontSize, doc) {
            if (fontData[font + "-" + fontSize] !== undefined) {
                return fontData[font + "-" + fontSize];
            }

            var container = doc.createElement('div'),
                    img = doc.createElement('img'),
                    span = doc.createElement('span'),
                    sampleText = 'Hidden Text',
                    baseline,
                    middle,
                    metricsObj;

            container.style.visibility = "hidden";
            container.style.fontFamily = font;
            container.style.fontSize = fontSize;
            container.style.margin = 0;
            container.style.padding = 0;

            doc.body.appendChild(container);

            // http://probablyprogramming.com/2009/03/15/the-tiniest-gif-ever (handtinywhite.gif)
            img.src = "data:image/gif;base64,R0lGODlhAQABAIABAP///wAAACwAAAAAAQABAAACAkQBADs=";
            img.width = 1;
            img.height = 1;

            img.style.margin = 0;
            img.style.padding = 0;
            img.style.verticalAlign = "baseline";

            span.style.fontFamily = font;
            span.style.fontSize = fontSize;
            span.style.margin = 0;
            span.style.padding = 0;

            span.appendChild(doc.createTextNode(sampleText));
            container.appendChild(span);
            container.appendChild(img);
            baseline = (img.offsetTop - span.offsetTop) + 1;

            container.removeChild(span);
            container.appendChild(doc.createTextNode(sampleText));

            container.style.lineHeight = "normal";
            img.style.verticalAlign = "super";

            middle = (img.offsetTop - container.offsetTop) + 1;
            metricsObj = {
                baseline: baseline,
                lineWidth: 1,
                middle: middle
            };

            fontData[font + "-" + fontSize] = metricsObj;

            doc.body.removeChild(container);

            return metricsObj;
        };
    })();

    (function() {
        var Util = _html2canvas.Util,
                Generate = {};

        _html2canvas.Generate = Generate;

        var reGradients = [
            /^(-webkit-linear-gradient)\(([a-z\s]+)([\w\d\.\s,%\(\)]+)\)$/,
            /^(-o-linear-gradient)\(([a-z\s]+)([\w\d\.\s,%\(\)]+)\)$/,
            /^(-webkit-gradient)\((linear|radial),\s((?:\d{1,3}%?)\s(?:\d{1,3}%?),\s(?:\d{1,3}%?)\s(?:\d{1,3}%?))([\w\d\.\s,%\(\)\-]+)\)$/,
            /^(-moz-linear-gradient)\(((?:\d{1,3}%?)\s(?:\d{1,3}%?))([\w\d\.\s,%\(\)]+)\)$/,
            /^(-webkit-radial-gradient)\(((?:\d{1,3}%?)\s(?:\d{1,3}%?)),\s(\w+)\s([a-z\-]+)([\w\d\.\s,%\(\)]+)\)$/,
            /^(-moz-radial-gradient)\(((?:\d{1,3}%?)\s(?:\d{1,3}%?)),\s(\w+)\s?([a-z\-]*)([\w\d\.\s,%\(\)]+)\)$/,
            /^(-o-radial-gradient)\(((?:\d{1,3}%?)\s(?:\d{1,3}%?)),\s(\w+)\s([a-z\-]+)([\w\d\.\s,%\(\)]+)\)$/
        ];

        /*
         * TODO: Add IE10 vendor prefix (-ms) support
         * TODO: Add W3C gradient (linear-gradient) support
         * TODO: Add old Webkit -webkit-gradient(radial, ...) support
         * TODO: Maybe some RegExp optimizations are possible ;o)
         */
        Generate.parseGradient = function(css, bounds) {
            var gradient, i, len = reGradients.length, m1, stop, m2, m2Len, step, m3, tl, tr, br, bl;

            for (i = 0; i < len; i += 1) {
                m1 = css.match(reGradients[i]);
                if (m1) {
                    break;
                }
            }

            if (m1) {
                switch (m1[1]) {
                    case '-webkit-linear-gradient':
                    case '-o-linear-gradient':

                        gradient = {
                            type: 'linear',
                            x0: null,
                            y0: null,
                            x1: null,
                            y1: null,
                            colorStops: []
                        };

                        // get coordinates
                        m2 = m1[2].match(/\w+/g);
                        if (m2) {
                            m2Len = m2.length;
                            for (i = 0; i < m2Len; i += 1) {
                                switch (m2[i]) {
                                    case 'top':
                                        gradient.y0 = 0;
                                        gradient.y1 = bounds.height;
                                        break;

                                    case 'right':
                                        gradient.x0 = bounds.width;
                                        gradient.x1 = 0;
                                        break;

                                    case 'bottom':
                                        gradient.y0 = bounds.height;
                                        gradient.y1 = 0;
                                        break;

                                    case 'left':
                                        gradient.x0 = 0;
                                        gradient.x1 = bounds.width;
                                        break;
                                }
                            }
                        }
                        if (gradient.x0 === null && gradient.x1 === null) { // center
                            gradient.x0 = gradient.x1 = bounds.width / 2;
                        }
                        if (gradient.y0 === null && gradient.y1 === null) { // center
                            gradient.y0 = gradient.y1 = bounds.height / 2;
                        }

                        // get colors and stops
                        m2 = m1[3].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\)(?:\s\d{1,3}(?:%|px))?)+/g);
                        if (m2) {
                            m2Len = m2.length;
                            step = 1 / Math.max(m2Len - 1, 1);
                            for (i = 0; i < m2Len; i += 1) {
                                m3 = m2[i].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\))\s*(\d{1,3})?(%|px)?/);
                                if (m3[2]) {
                                    stop = parseFloat(m3[2]);
                                    if (m3[3] === '%') {
                                        stop /= 100;
                                    } else { // px - stupid opera
                                        stop /= bounds.width;
                                    }
                                } else {
                                    stop = i * step;
                                }
                                gradient.colorStops.push({
                                    color: m3[1],
                                    stop: stop
                                });
                            }
                        }
                        break;

                    case '-webkit-gradient':

                        gradient = {
                            type: m1[2] === 'radial' ? 'circle' : m1[2], // TODO: Add radial gradient support for older mozilla definitions
                            x0: 0,
                            y0: 0,
                            x1: 0,
                            y1: 0,
                            colorStops: []
                        };

                        // get coordinates
                        m2 = m1[3].match(/(\d{1,3})%?\s(\d{1,3})%?,\s(\d{1,3})%?\s(\d{1,3})%?/);
                        if (m2) {
                            gradient.x0 = (m2[1] * bounds.width) / 100;
                            gradient.y0 = (m2[2] * bounds.height) / 100;
                            gradient.x1 = (m2[3] * bounds.width) / 100;
                            gradient.y1 = (m2[4] * bounds.height) / 100;
                        }

                        // get colors and stops
                        m2 = m1[4].match(/((?:from|to|color-stop)\((?:[0-9\.]+,\s)?(?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\)\))+/g);
                        if (m2) {
                            m2Len = m2.length;
                            for (i = 0; i < m2Len; i += 1) {
                                m3 = m2[i].match(/(from|to|color-stop)\(([0-9\.]+)?(?:,\s)?((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\))\)/);
                                stop = parseFloat(m3[2]);
                                if (m3[1] === 'from') {
                                    stop = 0.0;
                                }
                                if (m3[1] === 'to') {
                                    stop = 1.0;
                                }
                                gradient.colorStops.push({
                                    color: m3[3],
                                    stop: stop
                                });
                            }
                        }
                        break;

                    case '-moz-linear-gradient':

                        gradient = {
                            type: 'linear',
                            x0: 0,
                            y0: 0,
                            x1: 0,
                            y1: 0,
                            colorStops: []
                        };

                        // get coordinates
                        m2 = m1[2].match(/(\d{1,3})%?\s(\d{1,3})%?/);

                        // m2[1] == 0%   -> left
                        // m2[1] == 50%  -> center
                        // m2[1] == 100% -> right

                        // m2[2] == 0%   -> top
                        // m2[2] == 50%  -> center
                        // m2[2] == 100% -> bottom

                        if (m2) {
                            gradient.x0 = (m2[1] * bounds.width) / 100;
                            gradient.y0 = (m2[2] * bounds.height) / 100;
                            gradient.x1 = bounds.width - gradient.x0;
                            gradient.y1 = bounds.height - gradient.y0;
                        }

                        // get colors and stops
                        m2 = m1[3].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\)(?:\s\d{1,3}%)?)+/g);
                        if (m2) {
                            m2Len = m2.length;
                            step = 1 / Math.max(m2Len - 1, 1);
                            for (i = 0; i < m2Len; i += 1) {
                                m3 = m2[i].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\))\s*(\d{1,3})?(%)?/);
                                if (m3[2]) {
                                    stop = parseFloat(m3[2]);
                                    if (m3[3]) { // percentage
                                        stop /= 100;
                                    }
                                } else {
                                    stop = i * step;
                                }
                                gradient.colorStops.push({
                                    color: m3[1],
                                    stop: stop
                                });
                            }
                        }
                        break;

                    case '-webkit-radial-gradient':
                    case '-moz-radial-gradient':
                    case '-o-radial-gradient':

                        gradient = {
                            type: 'circle',
                            x0: 0,
                            y0: 0,
                            x1: bounds.width,
                            y1: bounds.height,
                            cx: 0,
                            cy: 0,
                            rx: 0,
                            ry: 0,
                            colorStops: []
                        };

                        // center
                        m2 = m1[2].match(/(\d{1,3})%?\s(\d{1,3})%?/);
                        if (m2) {
                            gradient.cx = (m2[1] * bounds.width) / 100;
                            gradient.cy = (m2[2] * bounds.height) / 100;
                        }

                        // size
                        m2 = m1[3].match(/\w+/);
                        m3 = m1[4].match(/[a-z\-]*/);
                        if (m2 && m3) {
                            switch (m3[0]) {
                                case 'farthest-corner':
                                case 'cover': // is equivalent to farthest-corner
                                case '': // mozilla removes "cover" from definition :(
                                    tl = Math.sqrt(Math.pow(gradient.cx, 2) + Math.pow(gradient.cy, 2));
                                    tr = Math.sqrt(Math.pow(gradient.cx, 2) + Math.pow(gradient.y1 - gradient.cy, 2));
                                    br = Math.sqrt(Math.pow(gradient.x1 - gradient.cx, 2) + Math.pow(gradient.y1 - gradient.cy, 2));
                                    bl = Math.sqrt(Math.pow(gradient.x1 - gradient.cx, 2) + Math.pow(gradient.cy, 2));
                                    gradient.rx = gradient.ry = Math.max(tl, tr, br, bl);
                                    break;
                                case 'closest-corner':
                                    tl = Math.sqrt(Math.pow(gradient.cx, 2) + Math.pow(gradient.cy, 2));
                                    tr = Math.sqrt(Math.pow(gradient.cx, 2) + Math.pow(gradient.y1 - gradient.cy, 2));
                                    br = Math.sqrt(Math.pow(gradient.x1 - gradient.cx, 2) + Math.pow(gradient.y1 - gradient.cy, 2));
                                    bl = Math.sqrt(Math.pow(gradient.x1 - gradient.cx, 2) + Math.pow(gradient.cy, 2));
                                    gradient.rx = gradient.ry = Math.min(tl, tr, br, bl);
                                    break;
                                case 'farthest-side':
                                    if (m2[0] === 'circle') {
                                        gradient.rx = gradient.ry = Math.max(
                                                gradient.cx,
                                                gradient.cy,
                                                gradient.x1 - gradient.cx,
                                                gradient.y1 - gradient.cy
                                                );
                                    } else { // ellipse

                                        gradient.type = m2[0];

                                        gradient.rx = Math.max(
                                                gradient.cx,
                                                gradient.x1 - gradient.cx
                                                );
                                        gradient.ry = Math.max(
                                                gradient.cy,
                                                gradient.y1 - gradient.cy
                                                );
                                    }
                                    break;
                                case 'closest-side':
                                case 'contain': // is equivalent to closest-side
                                    if (m2[0] === 'circle') {
                                        gradient.rx = gradient.ry = Math.min(
                                                gradient.cx,
                                                gradient.cy,
                                                gradient.x1 - gradient.cx,
                                                gradient.y1 - gradient.cy
                                                );
                                    } else { // ellipse

                                        gradient.type = m2[0];

                                        gradient.rx = Math.min(
                                                gradient.cx,
                                                gradient.x1 - gradient.cx
                                                );
                                        gradient.ry = Math.min(
                                                gradient.cy,
                                                gradient.y1 - gradient.cy
                                                );
                                    }
                                    break;

                                    // TODO: add support for "30px 40px" sizes (webkit only)
                            }
                        }

                        // color stops
                        m2 = m1[5].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\)(?:\s\d{1,3}(?:%|px))?)+/g);
                        if (m2) {
                            m2Len = m2.length;
                            step = 1 / Math.max(m2Len - 1, 1);
                            for (i = 0; i < m2Len; i += 1) {
                                m3 = m2[i].match(/((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\))\s*(\d{1,3})?(%|px)?/);
                                if (m3[2]) {
                                    stop = parseFloat(m3[2]);
                                    if (m3[3] === '%') {
                                        stop /= 100;
                                    } else { // px - stupid opera
                                        stop /= bounds.width;
                                    }
                                } else {
                                    stop = i * step;
                                }
                                gradient.colorStops.push({
                                    color: m3[1],
                                    stop: stop
                                });
                            }
                        }
                        break;
                }
            }

            return gradient;
        };

        function addScrollStops(grad) {
            return function(colorStop) {
                try {
                    grad.addColorStop(colorStop.stop, colorStop.color);
                }
                catch (e) {
                    Util.log(['failed to add color stop: ', e, '; tried to add: ', colorStop]);
                }
            };
        }

        Generate.Gradient = function(src, bounds) {
            if (bounds.width === 0 || bounds.height === 0) {
                return;
            }

            var canvas = document.createElement('canvas'),
                    ctx = canvas.getContext('2d'),
                    gradient, grad;

            canvas.width = bounds.width;
            canvas.height = bounds.height;

            // TODO: add support for multi defined background gradients
            gradient = _html2canvas.Generate.parseGradient(src, bounds);

            if (gradient) {
                switch (gradient.type) {
                    case 'linear':
                        grad = ctx.createLinearGradient(gradient.x0, gradient.y0, gradient.x1, gradient.y1);
                        gradient.colorStops.forEach(addScrollStops(grad));
                        ctx.fillStyle = grad;
                        ctx.fillRect(0, 0, bounds.width, bounds.height);
                        break;

                    case 'circle':
                        grad = ctx.createRadialGradient(gradient.cx, gradient.cy, 0, gradient.cx, gradient.cy, gradient.rx);
                        gradient.colorStops.forEach(addScrollStops(grad));
                        ctx.fillStyle = grad;
                        ctx.fillRect(0, 0, bounds.width, bounds.height);
                        break;

                    case 'ellipse':
                        var canvasRadial = document.createElement('canvas'),
                                ctxRadial = canvasRadial.getContext('2d'),
                                ri = Math.max(gradient.rx, gradient.ry),
                                di = ri * 2;

                        canvasRadial.width = canvasRadial.height = di;

                        grad = ctxRadial.createRadialGradient(gradient.rx, gradient.ry, 0, gradient.rx, gradient.ry, ri);
                        gradient.colorStops.forEach(addScrollStops(grad));

                        ctxRadial.fillStyle = grad;
                        ctxRadial.fillRect(0, 0, di, di);

                        ctx.fillStyle = gradient.colorStops[gradient.colorStops.length - 1].color;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.drawImage(canvasRadial, gradient.cx - gradient.rx, gradient.cy - gradient.ry, 2 * gradient.rx, 2 * gradient.ry);
                        break;
                }
            }

            return canvas;
        };

        Generate.ListAlpha = function(number) {
            var tmp = "",
                    modulus;

            do {
                modulus = number % 26;
                tmp = String.fromCharCode((modulus) + 64) + tmp;
                number = number / 26;
            } while ((number * 26) > 26);

            return tmp;
        };

        Generate.ListRoman = function(number) {
            var romanArray = ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"],
                    decimal = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
                    roman = "",
                    v,
                    len = romanArray.length;

            if (number <= 0 || number >= 4000) {
                return number;
            }

            for (v = 0; v < len; v += 1) {
                while (number >= decimal[v]) {
                    number -= decimal[v];
                    roman += romanArray[v];
                }
            }

            return roman;
        };
    })();
    function h2cRenderContext(width, height) {
        var storage = [];
        return {
            storage: storage,
            width: width,
            height: height,
            clip: function() {
                storage.push({
                    type: "function",
                    name: "clip",
                    'arguments': arguments
                });
            },
            translate: function() {
                storage.push({
                    type: "function",
                    name: "translate",
                    'arguments': arguments
                });
            },
            fill: function() {
                storage.push({
                    type: "function",
                    name: "fill",
                    'arguments': arguments
                });
            },
            save: function() {
                storage.push({
                    type: "function",
                    name: "save",
                    'arguments': arguments
                });
            },
            restore: function() {
                storage.push({
                    type: "function",
                    name: "restore",
                    'arguments': arguments
                });
            },
            fillRect: function() {
                storage.push({
                    type: "function",
                    name: "fillRect",
                    'arguments': arguments
                });
            },
            createPattern: function() {
                storage.push({
                    type: "function",
                    name: "createPattern",
                    'arguments': arguments
                });
            },
            drawShape: function() {

                var shape = [];

                storage.push({
                    type: "function",
                    name: "drawShape",
                    'arguments': shape
                });

                return {
                    moveTo: function() {
                        shape.push({
                            name: "moveTo",
                            'arguments': arguments
                        });
                    },
                    lineTo: function() {
                        shape.push({
                            name: "lineTo",
                            'arguments': arguments
                        });
                    },
                    arcTo: function() {
                        shape.push({
                            name: "arcTo",
                            'arguments': arguments
                        });
                    },
                    bezierCurveTo: function() {
                        shape.push({
                            name: "bezierCurveTo",
                            'arguments': arguments
                        });
                    },
                    quadraticCurveTo: function() {
                        shape.push({
                            name: "quadraticCurveTo",
                            'arguments': arguments
                        });
                    }
                };

            },
            drawImage: function() {
                storage.push({
                    type: "function",
                    name: "drawImage",
                    'arguments': arguments
                });
            },
            fillText: function() {
                storage.push({
                    type: "function",
                    name: "fillText",
                    'arguments': arguments
                });
            },
            setVariable: function(variable, value) {
                storage.push({
                    type: "variable",
                    name: variable,
                    'arguments': value
                });
                return value;
            }
        };
    }
    _html2canvas.Parse = function(images, options, cb) {
        window.scroll(0, 0);

        var element = ((options.elements === undefined) ? document.body : options.elements[0]), // select body by default
                numDraws = 0,
                doc = element.ownerDocument,
                Util = _html2canvas.Util,
                support = Util.Support(options, doc),
                ignoreElementsRegExp = new RegExp("(" + options.ignoreElements + ")"),
                body = doc.body,
                getCSS = Util.getCSS,
                pseudoHide = "___html2canvas___pseudoelement",
                hidePseudoElementsStyles = doc.createElement('style');

        hidePseudoElementsStyles.innerHTML = '.' + pseudoHide +
                '-parent:before { content: "" !important; display: none !important; }' +
                '.' + pseudoHide + '-parent:after { content: "" !important; display: none !important; }';

        body.appendChild(hidePseudoElementsStyles);

        images = images || {};

        init();

        function init() {
            var background = getCSS(document.documentElement, "backgroundColor"),
                    transparentBackground = (Util.isTransparent(background) && element === document.body),
                    stack = renderElement(element, null, false, transparentBackground);

            // create pseudo elements in a single pass to prevent synchronous layouts
            addPseudoElements(element);

            parseChildren(element, stack, function() {
                if (transparentBackground) {
                    background = stack.backgroundColor;
                }

                removePseudoElements();

                Util.log('Done parsing, moving to Render.');

                cb({
                    backgroundColor: background,
                    stack: stack
                });
            });
        }

        // Given a root element, find all pseudo elements below, create elements mocking pseudo element styles
        // so we can process them as normal elements, and hide the original pseudo elements so they don't interfere
        // with layout.
        function addPseudoElements(el) {
            // These are done in discrete steps to prevent a relayout loop caused by addClass() invalidating
            // layouts & getPseudoElement calling getComputedStyle.
            var jobs = [], classes = [];
            getPseudoElementClasses();
            findPseudoElements(el);
            runJobs();

            function getPseudoElementClasses() {
                var findPsuedoEls = /:before|:after/;
                var sheets = document.styleSheets;
                for (var i = 0, j = sheets.length; i < j; i++) {
                    try {
                        var rules = sheets[i].cssRules;
                        for (var k = 0, l = rules.length; k < l; k++) {
                            if (findPsuedoEls.test(rules[k].selectorText)) {
                                classes.push(rules[k].selectorText);
                            }
                        }
                    }
                    catch (e) { // will throw security exception for style sheets loaded from external domains
                    }
                }

                // Trim off the :after and :before (or ::after and ::before)
                for (i = 0, j = classes.length; i < j; i++) {
                    classes[i] = classes[i].match(/(^[^:]*)/)[1];
                }
            }

            // Using the list of elements we know how pseudo el styles, create fake pseudo elements.
//    function findPseudoElements(el) {
//      var els = document.querySelectorAll(classes.join(','));
//      for(var i = 0, j = els.length; i < j; i++) {
//        createPseudoElements(els[i]);
//      }
//    }

            function findPseudoElements(el) {
                var re = /^\s*$/;
                var newClasses = [];

                for (var i = 0; i < classes.length; i++) {
                    if (!re.test(classes[i])) {
                        newClasses.push(classes[i]);
                    }
                }

                // If you don't need to support IE 6-8, 
                // you can use `Array.filter()` function alternatively.
                /*
                 var newClasses = classes.filter(function(element) {
                 return !re.test(element);
                 });
                 */

                if (newClasses.length === 0)
                    return;

                var els = document.querySelectorAll(newClasses.join(','));
                for (var i = 0, j = els.length; i < j; i++) {
                    createPseudoElements(els[i]);
                }
            }

            function findPseudoElements(el) {
                var re = /^\s*$/;
                var newClasses = [];

                for (var i = 0; i < classes.length; i++) {
                    if (!re.test(classes[i])) {
                        newClasses.push(classes[i]);
                    }
                }

                // If you don't need to support IE 6-8, 
                // you can use `Array.filter()` function alternatively.
                /*
                 var newClasses = classes.filter(function(element) {
                 return !re.test(element);
                 });
                 */

                if (newClasses.length === 0)
                    return;

                var els = document.querySelectorAll(newClasses.join(','));
                for (var i = 0, j = els.length; i < j; i++) {
                    createPseudoElements(els[i]);
                }
            }
            // Create pseudo elements & add them to a job queue.
            function createPseudoElements(el) {
                var before = getPseudoElement(el, ':before'),
                        after = getPseudoElement(el, ':after');

                if (before) {
                    jobs.push({type: 'before', pseudo: before, el: el});
                }

                if (after) {
                    jobs.push({type: 'after', pseudo: after, el: el});
                }
            }

            // Adds a class to the pseudo's parent to prevent the original before/after from messing
            // with layouts.
            // Execute the inserts & addClass() calls in a batch to prevent relayouts.
            function runJobs() {
                // Add Class
                jobs.forEach(function(job) {
                    addClass(job.el, pseudoHide + "-parent");
                });

                // Insert el
                jobs.forEach(function(job) {
                    if (job.type === 'before') {
                        job.el.insertBefore(job.pseudo, job.el.firstChild);
                    } else {
                        job.el.appendChild(job.pseudo);
                    }
                });
            }
        }



        // Delete our fake pseudo elements from the DOM. This will remove those actual elements
        // and the classes on their parents that hide the actual pseudo elements.
        // Note that NodeLists are 'live' collections so you can't use a for loop here. They are
        // actually deleted from the NodeList after each iteration.
        function removePseudoElements() {
            // delete pseudo elements
            body.removeChild(hidePseudoElementsStyles);
            var pseudos = document.getElementsByClassName(pseudoHide + "-element");
            while (pseudos.length) {
                pseudos[0].parentNode.removeChild(pseudos[0]);
            }

            // Remove pseudo hiding classes
            var parents = document.getElementsByClassName(pseudoHide + "-parent");
            while (parents.length) {
                removeClass(parents[0], pseudoHide + "-parent");
            }
        }

        function addClass(el, className) {
            if (el.classList) {
                el.classList.add(className);
            } else {
                el.className = el.className + " " + className;
            }
        }

        function removeClass(el, className) {
            if (el.classList) {
                el.classList.remove(className);
            } else {
                el.className = el.className.replace(className, "").trim();
            }
        }

        function hasClass(el, className) {
            return el.className.indexOf(className) > -1;
        }

        // Note that this doesn't work in < IE8, but we don't support that anyhow
        function nodeListToArray(nodeList) {
            return Array.prototype.slice.call(nodeList);
        }

        function documentWidth() {
            return Math.max(
                    Math.max(doc.body.scrollWidth, doc.documentElement.scrollWidth),
                    Math.max(doc.body.offsetWidth, doc.documentElement.offsetWidth),
                    Math.max(doc.body.clientWidth, doc.documentElement.clientWidth)
                    );
        }

        function documentHeight() {
            return Math.max(
                    Math.max(doc.body.scrollHeight, doc.documentElement.scrollHeight),
                    Math.max(doc.body.offsetHeight, doc.documentElement.offsetHeight),
                    Math.max(doc.body.clientHeight, doc.documentElement.clientHeight)
                    );
        }

        function getCSSInt(element, attribute) {
            var val = parseInt(getCSS(element, attribute), 10);
            return (isNaN(val)) ? 0 : val; // borders in old IE are throwing 'medium' for demo.html
        }

        function renderRect(ctx, x, y, w, h, bgcolor) {
            if (bgcolor !== "transparent") {
                ctx.setVariable("fillStyle", bgcolor);
                ctx.fillRect(x, y, w, h);
                numDraws += 1;
            }
        }

        function capitalize(m, p1, p2) {
            if (m.length > 0) {
                return p1 + p2.toUpperCase();
            }
        }

        function textTransform(text, transform) {
            switch (transform) {
                case "lowercase":
                    return text.toLowerCase();
                case "capitalize":
                    return text.replace(/(^|\s|:|-|\(|\))([a-z])/g, capitalize);
                case "uppercase":
                    return text.toUpperCase();
                default:
                    return text;
            }
        }

        function noLetterSpacing(letter_spacing) {
            return (/^(normal|none|0px)$/.test(letter_spacing));
        }

        function drawText(currentText, x, y, ctx) {
            if (currentText !== null && Util.trimText(currentText).length > 0) {
                ctx.fillText(currentText, x, y);
                numDraws += 1;
            }
        }

        function setTextVariables(ctx, el, text_decoration, color) {
            var align = false,
                    bold = getCSS(el, "fontWeight"),
                    family = getCSS(el, "fontFamily"),
                    size = getCSS(el, "fontSize"),
                    shadows = Util.parseTextShadows(getCSS(el, "textShadow"));

            switch (parseInt(bold, 10)) {
                case 401:
                    bold = "bold";
                    break;
                case 400:
                    bold = "normal";
                    break;
            }

            ctx.setVariable("fillStyle", color);
            ctx.setVariable("font", [getCSS(el, "fontStyle"), getCSS(el, "fontVariant"), bold, size, family].join(" "));
            ctx.setVariable("textAlign", (align) ? "right" : "left");

            if (shadows.length) {
                // TODO: support multiple text shadows
                // apply the first text shadow
                ctx.setVariable("shadowColor", shadows[0].color);
                ctx.setVariable("shadowOffsetX", shadows[0].offsetX);
                ctx.setVariable("shadowOffsetY", shadows[0].offsetY);
                ctx.setVariable("shadowBlur", shadows[0].blur);
            }

            if (text_decoration !== "none") {
                return Util.Font(family, size, doc);
            }
        }

        function renderTextDecoration(ctx, text_decoration, bounds, metrics, color) {
            switch (text_decoration) {
                case "underline":
                    // Draws a line at the baseline of the font
                    // TODO As some browsers display the line as more than 1px if the font-size is big, need to take that into account both in position and size
                    renderRect(ctx, bounds.left, Math.round(bounds.top + metrics.baseline + metrics.lineWidth), bounds.width, 1, color);
                    break;
                case "overline":
                    renderRect(ctx, bounds.left, Math.round(bounds.top), bounds.width, 1, color);
                    break;
                case "line-through":
                    // TODO try and find exact position for line-through
                    renderRect(ctx, bounds.left, Math.ceil(bounds.top + metrics.middle + metrics.lineWidth), bounds.width, 1, color);
                    break;
            }
        }

        function getTextBounds(state, text, textDecoration, isLast, transform) {
            var bounds;
            if (support.rangeBounds && !transform) {
                if (textDecoration !== "none" || Util.trimText(text).length !== 0) {
                    bounds = textRangeBounds(text, state.node, state.textOffset);
                }
                state.textOffset += text.length;
            } else if (state.node && typeof state.node.nodeValue === "string") {
                var newTextNode = (isLast) ? state.node.splitText(text.length) : null;
                bounds = textWrapperBounds(state.node, transform);
                state.node = newTextNode;
            }
            return bounds;
        }

        function textRangeBounds(text, textNode, textOffset) {
            var range = doc.createRange();
            range.setStart(textNode, textOffset);
            range.setEnd(textNode, textOffset + text.length);
            return range.getBoundingClientRect();
        }

        function textWrapperBounds(oldTextNode, transform) {
            var parent = oldTextNode.parentNode,
                    wrapElement = doc.createElement('wrapper'),
                    backupText = oldTextNode.cloneNode(true);

            wrapElement.appendChild(oldTextNode.cloneNode(true));
            parent.replaceChild(wrapElement, oldTextNode);

            var bounds = transform ? Util.OffsetBounds(wrapElement) : Util.Bounds(wrapElement);
            parent.replaceChild(backupText, wrapElement);
            return bounds;
        }

        function renderText(el, textNode, stack) {
            var ctx = stack.ctx,
                    color = getCSS(el, "color"),
                    textDecoration = getCSS(el, "textDecoration"),
                    textAlign = getCSS(el, "textAlign"),
                    metrics,
                    textList,
                    state = {
                        node: textNode,
                        textOffset: 0
                    };

            if (Util.trimText(textNode.nodeValue).length > 0) {
                textNode.nodeValue = textTransform(textNode.nodeValue, getCSS(el, "textTransform"));
                textAlign = textAlign.replace(["-webkit-auto"], ["auto"]);

                textList = (!options.letterRendering && /^(left|right|justify|auto)$/.test(textAlign) && noLetterSpacing(getCSS(el, "letterSpacing"))) ?
                        textNode.nodeValue.split(/(\b| )/)
                        : textNode.nodeValue.split("");

                metrics = setTextVariables(ctx, el, textDecoration, color);

                if (options.chinese) {
                    textList.forEach(function(word, index) {
                        if (/.*[\u4E00-\u9FA5].*$/.test(word)) {
                            word = word.split("");
                            word.unshift(index, 1);
                            textList.splice.apply(textList, word);
                        }
                    });
                }

                textList.forEach(function(text, index) {
                    var bounds = getTextBounds(state, text, textDecoration, (index < textList.length - 1), stack.transform.matrix);
                    if (bounds) {
                        drawText(text, bounds.left, bounds.bottom, ctx);
                        renderTextDecoration(ctx, textDecoration, bounds, metrics, color);
                    }
                });
            }
        }

        function listPosition(element, val) {
            var boundElement = doc.createElement("boundelement"),
                    originalType,
                    bounds;

            boundElement.style.display = "inline";

            originalType = element.style.listStyleType;
            element.style.listStyleType = "none";

            boundElement.appendChild(doc.createTextNode(val));

            element.insertBefore(boundElement, element.firstChild);

            bounds = Util.Bounds(boundElement);
            element.removeChild(boundElement);
            element.style.listStyleType = originalType;
            return bounds;
        }

        function elementIndex(el) {
            var i = -1,
                    count = 1,
                    childs = el.parentNode.childNodes;

            if (el.parentNode) {
                while (childs[++i] !== el) {
                    if (childs[i].nodeType === 1) {
                        count++;
                    }
                }
                return count;
            } else {
                return -1;
            }
        }

        function listItemText(element, type) {
            var currentIndex = elementIndex(element), text;
            switch (type) {
                case "decimal":
                    text = currentIndex;
                    break;
                case "decimal-leading-zero":
                    text = (currentIndex.toString().length === 1) ? currentIndex = "0" + currentIndex.toString() : currentIndex.toString();
                    break;
                case "upper-roman":
                    text = _html2canvas.Generate.ListRoman(currentIndex);
                    break;
                case "lower-roman":
                    text = _html2canvas.Generate.ListRoman(currentIndex).toLowerCase();
                    break;
                case "lower-alpha":
                    text = _html2canvas.Generate.ListAlpha(currentIndex).toLowerCase();
                    break;
                case "upper-alpha":
                    text = _html2canvas.Generate.ListAlpha(currentIndex);
                    break;
            }

            return text + ". ";
        }

        function renderListItem(element, stack, elBounds) {
            var x,
                    text,
                    ctx = stack.ctx,
                    type = getCSS(element, "listStyleType"),
                    listBounds;

            if (/^(decimal|decimal-leading-zero|upper-alpha|upper-latin|upper-roman|lower-alpha|lower-greek|lower-latin|lower-roman)$/i.test(type)) {
                text = listItemText(element, type);
                listBounds = listPosition(element, text);
                setTextVariables(ctx, element, "none", getCSS(element, "color"));

                if (getCSS(element, "listStylePosition") === "inside") {
                    ctx.setVariable("textAlign", "left");
                    x = elBounds.left;
                } else {
                    return;
                }

                drawText(text, x, listBounds.bottom, ctx);
            }
        }

        function loadImage(src) {
            var img = images[src];
            return (img && img.succeeded === true) ? img.img : false;
        }

        function clipBounds(src, dst) {
            var x = Math.max(src.left, dst.left),
                    y = Math.max(src.top, dst.top),
                    x2 = Math.min((src.left + src.width), (dst.left + dst.width)),
                    y2 = Math.min((src.top + src.height), (dst.top + dst.height));

            return {
                left: x,
                top: y,
                width: x2 - x,
                height: y2 - y
            };
        }

        function setZ(element, stack, parentStack) {
            var newContext,
                    isPositioned = stack.cssPosition !== 'static',
                    zIndex = isPositioned ? getCSS(element, 'zIndex') : 'auto',
                    opacity = getCSS(element, 'opacity'),
                    isFloated = getCSS(element, 'cssFloat') !== 'none';

            // https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context
            // When a new stacking context should be created:
            // the root element (HTML),
            // positioned (absolutely or relatively) with a z-index value other than "auto",
            // elements with an opacity value less than 1. (See the specification for opacity),
            // on mobile WebKit and Chrome 22+, position: fixed always creates a new stacking context, even when z-index is "auto" (See this post)

            stack.zIndex = newContext = h2czContext(zIndex);
            newContext.isPositioned = isPositioned;
            newContext.isFloated = isFloated;
            newContext.opacity = opacity;
            newContext.ownStacking = (zIndex !== 'auto' || opacity < 1);
            newContext.depth = parentStack ? (parentStack.zIndex.depth + 1) : 0;

            if (parentStack) {
                parentStack.zIndex.children.push(stack);
            }
        }

        function h2czContext(zindex) {
            return {
                depth: 0,
                zindex: zindex,
                children: []
            };
        }

        function renderImage(ctx, element, image, bounds, borders) {

            var paddingLeft = getCSSInt(element, 'paddingLeft'),
                    paddingTop = getCSSInt(element, 'paddingTop'),
                    paddingRight = getCSSInt(element, 'paddingRight'),
                    paddingBottom = getCSSInt(element, 'paddingBottom');

            drawImage(
                    ctx,
                    image,
                    0, //sx
                    0, //sy
                    image.width, //sw
                    image.height, //sh
                    bounds.left + paddingLeft + borders[3].width, //dx
                    bounds.top + paddingTop + borders[0].width, // dy
                    bounds.width - (borders[1].width + borders[3].width + paddingLeft + paddingRight), //dw
                    bounds.height - (borders[0].width + borders[2].width + paddingTop + paddingBottom) //dh
                    );
        }

        function getBorderData(element) {
            return ["Top", "Right", "Bottom", "Left"].map(function(side) {
                return {
                    width: getCSSInt(element, 'border' + side + 'Width'),
                    color: getCSS(element, 'border' + side + 'Color')
                };
            });
        }

        function getBorderRadiusData(element) {
            return ["TopLeft", "TopRight", "BottomRight", "BottomLeft"].map(function(side) {
                return getCSS(element, 'border' + side + 'Radius');
            });
        }

        function getCurvePoints(x, y, r1, r2) {
            var kappa = 4 * ((Math.sqrt(2) - 1) / 3);
            var ox = (r1) * kappa, // control point offset horizontal
                    oy = (r2) * kappa, // control point offset vertical
                    xm = x + r1, // x-middle
                    ym = y + r2; // y-middle
            return {
                topLeft: bezierCurve({
                    x: x,
                    y: ym
                }, {
                    x: x,
                    y: ym - oy
                }, {
                    x: xm - ox,
                    y: y
                }, {
                    x: xm,
                    y: y
                }),
                topRight: bezierCurve({
                    x: x,
                    y: y
                }, {
                    x: x + ox,
                    y: y
                }, {
                    x: xm,
                    y: ym - oy
                }, {
                    x: xm,
                    y: ym
                }),
                bottomRight: bezierCurve({
                    x: xm,
                    y: y
                }, {
                    x: xm,
                    y: y + oy
                }, {
                    x: x + ox,
                    y: ym
                }, {
                    x: x,
                    y: ym
                }),
                bottomLeft: bezierCurve({
                    x: xm,
                    y: ym
                }, {
                    x: xm - ox,
                    y: ym
                }, {
                    x: x,
                    y: y + oy
                }, {
                    x: x,
                    y: y
                })
            };
        }

        function bezierCurve(start, startControl, endControl, end) {

            var lerp = function(a, b, t) {
                return {
                    x: a.x + (b.x - a.x) * t,
                    y: a.y + (b.y - a.y) * t
                };
            };

            return {
                start: start,
                startControl: startControl,
                endControl: endControl,
                end: end,
                subdivide: function(t) {
                    var ab = lerp(start, startControl, t),
                            bc = lerp(startControl, endControl, t),
                            cd = lerp(endControl, end, t),
                            abbc = lerp(ab, bc, t),
                            bccd = lerp(bc, cd, t),
                            dest = lerp(abbc, bccd, t);
                    return [bezierCurve(start, ab, abbc, dest), bezierCurve(dest, bccd, cd, end)];
                },
                curveTo: function(borderArgs) {
                    borderArgs.push(["bezierCurve", startControl.x, startControl.y, endControl.x, endControl.y, end.x, end.y]);
                },
                curveToReversed: function(borderArgs) {
                    borderArgs.push(["bezierCurve", endControl.x, endControl.y, startControl.x, startControl.y, start.x, start.y]);
                }
            };
        }

        function parseCorner(borderArgs, radius1, radius2, corner1, corner2, x, y) {
            if (radius1[0] > 0 || radius1[1] > 0) {
                borderArgs.push(["line", corner1[0].start.x, corner1[0].start.y]);
                corner1[0].curveTo(borderArgs);
                corner1[1].curveTo(borderArgs);
            } else {
                borderArgs.push(["line", x, y]);
            }

            if (radius2[0] > 0 || radius2[1] > 0) {
                borderArgs.push(["line", corner2[0].start.x, corner2[0].start.y]);
            }
        }

        function drawSide(borderData, radius1, radius2, outer1, inner1, outer2, inner2) {
            var borderArgs = [];

            if (radius1[0] > 0 || radius1[1] > 0) {
                borderArgs.push(["line", outer1[1].start.x, outer1[1].start.y]);
                outer1[1].curveTo(borderArgs);
            } else {
                borderArgs.push(["line", borderData.c1[0], borderData.c1[1]]);
            }

            if (radius2[0] > 0 || radius2[1] > 0) {
                borderArgs.push(["line", outer2[0].start.x, outer2[0].start.y]);
                outer2[0].curveTo(borderArgs);
                borderArgs.push(["line", inner2[0].end.x, inner2[0].end.y]);
                inner2[0].curveToReversed(borderArgs);
            } else {
                borderArgs.push(["line", borderData.c2[0], borderData.c2[1]]);
                borderArgs.push(["line", borderData.c3[0], borderData.c3[1]]);
            }

            if (radius1[0] > 0 || radius1[1] > 0) {
                borderArgs.push(["line", inner1[1].end.x, inner1[1].end.y]);
                inner1[1].curveToReversed(borderArgs);
            } else {
                borderArgs.push(["line", borderData.c4[0], borderData.c4[1]]);
            }

            return borderArgs;
        }

        function calculateCurvePoints(bounds, borderRadius, borders) {

            var x = bounds.left,
                    y = bounds.top,
                    width = bounds.width,
                    height = bounds.height,
                    tlh = borderRadius[0][0],
                    tlv = borderRadius[0][1],
                    trh = borderRadius[1][0],
                    trv = borderRadius[1][1],
                    brh = borderRadius[2][0],
                    brv = borderRadius[2][1],
                    blh = borderRadius[3][0],
                    blv = borderRadius[3][1],
                    topWidth = width - trh,
                    rightHeight = height - brv,
                    bottomWidth = width - brh,
                    leftHeight = height - blv;

            return {
                topLeftOuter: getCurvePoints(
                        x,
                        y,
                        tlh,
                        tlv
                        ).topLeft.subdivide(0.5),
                topLeftInner: getCurvePoints(
                        x + borders[3].width,
                        y + borders[0].width,
                        Math.max(0, tlh - borders[3].width),
                        Math.max(0, tlv - borders[0].width)
                        ).topLeft.subdivide(0.5),
                topRightOuter: getCurvePoints(
                        x + topWidth,
                        y,
                        trh,
                        trv
                        ).topRight.subdivide(0.5),
                topRightInner: getCurvePoints(
                        x + Math.min(topWidth, width + borders[3].width),
                        y + borders[0].width,
                        (topWidth > width + borders[3].width) ? 0 : trh - borders[3].width,
                        trv - borders[0].width
                        ).topRight.subdivide(0.5),
                bottomRightOuter: getCurvePoints(
                        x + bottomWidth,
                        y + rightHeight,
                        brh,
                        brv
                        ).bottomRight.subdivide(0.5),
                bottomRightInner: getCurvePoints(
                        x + Math.min(bottomWidth, width + borders[3].width),
                        y + Math.min(rightHeight, height + borders[0].width),
                        Math.max(0, brh - borders[1].width),
                        Math.max(0, brv - borders[2].width)
                        ).bottomRight.subdivide(0.5),
                bottomLeftOuter: getCurvePoints(
                        x,
                        y + leftHeight,
                        blh,
                        blv
                        ).bottomLeft.subdivide(0.5),
                bottomLeftInner: getCurvePoints(
                        x + borders[3].width,
                        y + leftHeight,
                        Math.max(0, blh - borders[3].width),
                        Math.max(0, blv - borders[2].width)
                        ).bottomLeft.subdivide(0.5)
            };
        }

        function getBorderClip(element, borderPoints, borders, radius, bounds) {
            var backgroundClip = getCSS(element, 'backgroundClip'),
                    borderArgs = [];

            switch (backgroundClip) {
                case "content-box":
                case "padding-box":
                    parseCorner(borderArgs, radius[0], radius[1], borderPoints.topLeftInner, borderPoints.topRightInner, bounds.left + borders[3].width, bounds.top + borders[0].width);
                    parseCorner(borderArgs, radius[1], radius[2], borderPoints.topRightInner, borderPoints.bottomRightInner, bounds.left + bounds.width - borders[1].width, bounds.top + borders[0].width);
                    parseCorner(borderArgs, radius[2], radius[3], borderPoints.bottomRightInner, borderPoints.bottomLeftInner, bounds.left + bounds.width - borders[1].width, bounds.top + bounds.height - borders[2].width);
                    parseCorner(borderArgs, radius[3], radius[0], borderPoints.bottomLeftInner, borderPoints.topLeftInner, bounds.left + borders[3].width, bounds.top + bounds.height - borders[2].width);
                    break;

                default:
                    parseCorner(borderArgs, radius[0], radius[1], borderPoints.topLeftOuter, borderPoints.topRightOuter, bounds.left, bounds.top);
                    parseCorner(borderArgs, radius[1], radius[2], borderPoints.topRightOuter, borderPoints.bottomRightOuter, bounds.left + bounds.width, bounds.top);
                    parseCorner(borderArgs, radius[2], radius[3], borderPoints.bottomRightOuter, borderPoints.bottomLeftOuter, bounds.left + bounds.width, bounds.top + bounds.height);
                    parseCorner(borderArgs, radius[3], radius[0], borderPoints.bottomLeftOuter, borderPoints.topLeftOuter, bounds.left, bounds.top + bounds.height);
                    break;
            }

            return borderArgs;
        }

        function parseBorders(element, bounds, borders) {
            var x = bounds.left,
                    y = bounds.top,
                    width = bounds.width,
                    height = bounds.height,
                    borderSide,
                    bx,
                    by,
                    bw,
                    bh,
                    borderArgs,
                    // http://www.w3.org/TR/css3-background/#the-border-radius
                    borderRadius = getBorderRadiusData(element),
                    borderPoints = calculateCurvePoints(bounds, borderRadius, borders),
                    borderData = {
                        clip: getBorderClip(element, borderPoints, borders, borderRadius, bounds),
                        borders: []
                    };

            for (borderSide = 0; borderSide < 4; borderSide++) {

                if (borders[borderSide].width > 0) {
                    bx = x;
                    by = y;
                    bw = width;
                    bh = height - (borders[2].width);

                    switch (borderSide) {
                        case 0:
                            // top border
                            bh = borders[0].width;

                            borderArgs = drawSide({
                                c1: [bx, by],
                                c2: [bx + bw, by],
                                c3: [bx + bw - borders[1].width, by + bh],
                                c4: [bx + borders[3].width, by + bh]
                            }, borderRadius[0], borderRadius[1],
                                    borderPoints.topLeftOuter, borderPoints.topLeftInner, borderPoints.topRightOuter, borderPoints.topRightInner);
                            break;
                        case 1:
                            // right border
                            bx = x + width - (borders[1].width);
                            bw = borders[1].width;

                            borderArgs = drawSide({
                                c1: [bx + bw, by],
                                c2: [bx + bw, by + bh + borders[2].width],
                                c3: [bx, by + bh],
                                c4: [bx, by + borders[0].width]
                            }, borderRadius[1], borderRadius[2],
                                    borderPoints.topRightOuter, borderPoints.topRightInner, borderPoints.bottomRightOuter, borderPoints.bottomRightInner);
                            break;
                        case 2:
                            // bottom border
                            by = (by + height) - (borders[2].width);
                            bh = borders[2].width;

                            borderArgs = drawSide({
                                c1: [bx + bw, by + bh],
                                c2: [bx, by + bh],
                                c3: [bx + borders[3].width, by],
                                c4: [bx + bw - borders[3].width, by]
                            }, borderRadius[2], borderRadius[3],
                                    borderPoints.bottomRightOuter, borderPoints.bottomRightInner, borderPoints.bottomLeftOuter, borderPoints.bottomLeftInner);
                            break;
                        case 3:
                            // left border
                            bw = borders[3].width;

                            borderArgs = drawSide({
                                c1: [bx, by + bh + borders[2].width],
                                c2: [bx, by],
                                c3: [bx + bw, by + borders[0].width],
                                c4: [bx + bw, by + bh]
                            }, borderRadius[3], borderRadius[0],
                                    borderPoints.bottomLeftOuter, borderPoints.bottomLeftInner, borderPoints.topLeftOuter, borderPoints.topLeftInner);
                            break;
                    }

                    borderData.borders.push({
                        args: borderArgs,
                        color: borders[borderSide].color
                    });

                }
            }

            return borderData;
        }

        function createShape(ctx, args) {
            var shape = ctx.drawShape();
            args.forEach(function(border, index) {
                shape[(index === 0) ? "moveTo" : border[0] + "To" ].apply(null, border.slice(1));
            });
            return shape;
        }

        function renderBorders(ctx, borderArgs, color) {
            if (color !== "transparent") {
                ctx.setVariable("fillStyle", color);
                createShape(ctx, borderArgs);
                ctx.fill();
                numDraws += 1;
            }
        }

        function renderFormValue(el, bounds, stack) {

            var valueWrap = doc.createElement('valuewrap'),
                    cssPropertyArray = ['lineHeight', 'textAlign', 'fontFamily', 'color', 'fontSize', 'paddingLeft', 'paddingTop', 'width', 'height', 'border', 'borderLeftWidth', 'borderTopWidth'],
                    textValue,
                    textNode;

            cssPropertyArray.forEach(function(property) {
                try {
                    valueWrap.style[property] = getCSS(el, property);
                } catch (e) {
                    // Older IE has issues with "border"
                    Util.log("html2canvas: Parse: Exception caught in renderFormValue: " + e.message);
                }
            });

            valueWrap.style.borderColor = "black";
            valueWrap.style.borderStyle = "solid";
            valueWrap.style.display = "block";
            valueWrap.style.position = "absolute";

            if (/^(submit|reset|button|text|password)$/.test(el.type) || el.nodeName === "SELECT") {
                valueWrap.style.lineHeight = getCSS(el, "height");
            }

            valueWrap.style.top = bounds.top + "px";
            valueWrap.style.left = bounds.left + "px";

            textValue = (el.nodeName === "SELECT") ? (el.options[el.selectedIndex] || 0).text : el.value;
            if (!textValue) {
                textValue = el.placeholder;
            }

            textNode = doc.createTextNode(textValue);

            valueWrap.appendChild(textNode);
            body.appendChild(valueWrap);

            renderText(el, textNode, stack);
            body.removeChild(valueWrap);
        }

        function drawImage(ctx) {
            ctx.drawImage.apply(ctx, Array.prototype.slice.call(arguments, 1));
            numDraws += 1;
        }

        function getPseudoElement(el, which) {
            var elStyle = window.getComputedStyle(el, which);
            var parentStyle = window.getComputedStyle(el);
            // If no content attribute is present, the pseudo element is hidden,
            // or the parent has a content property equal to the content on the pseudo element,
            // move along.
            if (!elStyle || !elStyle.content || elStyle.content === "none" || elStyle.content === "-moz-alt-content" ||
                    elStyle.display === "none" || parentStyle.content === elStyle.content) {
                return;
            }
            var content = elStyle.content + '';

            // Strip inner quotes
            if (content[0] === "'" || content[0] === "\"") {
                content = content.replace(/(^['"])|(['"]$)/g, '');
            }

            var isImage = content.substr(0, 3) === 'url',
                    elps = document.createElement(isImage ? 'img' : 'span');

            elps.className = pseudoHide + "-element ";

            Object.keys(elStyle).filter(indexedProperty).forEach(function(prop) {
                // Prevent assigning of read only CSS Rules, ex. length, parentRule
                try {
                    elps.style[prop] = elStyle[prop];
                } catch (e) {
                    Util.log(['Tried to assign readonly property ', prop, 'Error:', e]);
                }
            });

            if (isImage) {
                elps.src = Util.parseBackgroundImage(content)[0].args[0];
            } else {
                elps.innerHTML = content;
            }
            return elps;
        }

        function indexedProperty(property) {
            return (isNaN(window.parseInt(property, 10)));
        }

        function renderBackgroundRepeat(ctx, image, backgroundPosition, bounds) {
            var offsetX = Math.round(bounds.left + backgroundPosition.left),
                    offsetY = Math.round(bounds.top + backgroundPosition.top);

            ctx.createPattern(image);
            ctx.translate(offsetX, offsetY);
            ctx.fill();
            ctx.translate(-offsetX, -offsetY);
        }

        function backgroundRepeatShape(ctx, image, backgroundPosition, bounds, left, top, width, height) {
            var args = [];
            args.push(["line", Math.round(left), Math.round(top)]);
            args.push(["line", Math.round(left + width), Math.round(top)]);
            args.push(["line", Math.round(left + width), Math.round(height + top)]);
            args.push(["line", Math.round(left), Math.round(height + top)]);
            createShape(ctx, args);
            ctx.save();
            ctx.clip();
            renderBackgroundRepeat(ctx, image, backgroundPosition, bounds);
            ctx.restore();
        }

        function renderBackgroundColor(ctx, backgroundBounds, bgcolor) {
            renderRect(
                    ctx,
                    backgroundBounds.left,
                    backgroundBounds.top,
                    backgroundBounds.width,
                    backgroundBounds.height,
                    bgcolor
                    );
        }

        function renderBackgroundRepeating(el, bounds, ctx, image, imageIndex) {
            var backgroundSize = Util.BackgroundSize(el, bounds, image, imageIndex),
                    backgroundPosition = Util.BackgroundPosition(el, bounds, image, imageIndex, backgroundSize),
                    backgroundRepeat = Util.BackgroundRepeat(el, imageIndex);

            image = resizeImage(image, backgroundSize);

            switch (backgroundRepeat) {
                case "repeat-x":
                case "repeat no-repeat":
                    backgroundRepeatShape(ctx, image, backgroundPosition, bounds,
                            bounds.left, bounds.top + backgroundPosition.top, 99999, image.height);
                    break;
                case "repeat-y":
                case "no-repeat repeat":
                    backgroundRepeatShape(ctx, image, backgroundPosition, bounds,
                            bounds.left + backgroundPosition.left, bounds.top, image.width, 99999);
                    break;
                case "no-repeat":
                    backgroundRepeatShape(ctx, image, backgroundPosition, bounds,
                            bounds.left + backgroundPosition.left, bounds.top + backgroundPosition.top, image.width, image.height);
                    break;
                default:
                    renderBackgroundRepeat(ctx, image, backgroundPosition, {
                        top: bounds.top,
                        left: bounds.left,
                        width: image.width,
                        height: image.height
                    });
                    break;
            }
        }

        function renderBackgroundImage(element, bounds, ctx) {
            var backgroundImage = getCSS(element, "backgroundImage"),
                    backgroundImages = Util.parseBackgroundImage(backgroundImage),
                    image,
                    imageIndex = backgroundImages.length;

            while (imageIndex--) {
                backgroundImage = backgroundImages[imageIndex];

                if (!backgroundImage.args || backgroundImage.args.length === 0) {
                    continue;
                }

                var key = backgroundImage.method === 'url' ?
                        backgroundImage.args[0] :
                        backgroundImage.value;

                image = loadImage(key);

                // TODO add support for background-origin
                if (image) {
                    renderBackgroundRepeating(element, bounds, ctx, image, imageIndex);
                } else {
                    Util.log("html2canvas: Error loading background:", backgroundImage);
                }
            }
        }

        function resizeImage(image, bounds) {
            if (image.width === bounds.width && image.height === bounds.height) {
                return image;
            }

            var ctx, canvas = doc.createElement('canvas');
            canvas.width = bounds.width;
            canvas.height = bounds.height;
            ctx = canvas.getContext("2d");
            drawImage(ctx, image, 0, 0, image.width, image.height, 0, 0, bounds.width, bounds.height);
            return canvas;
        }

        function setOpacity(ctx, element, parentStack) {
            return ctx.setVariable("globalAlpha", getCSS(element, "opacity") * ((parentStack) ? parentStack.opacity : 1));
        }

        function removePx(str) {
            return str.replace("px", "");
        }

        function getTransform(element, parentStack) {
            var transformRegExp = /(matrix)\((.+)\)/;
            var transform = getCSS(element, "transform") || getCSS(element, "-webkit-transform") || getCSS(element, "-moz-transform") || getCSS(element, "-ms-transform") || getCSS(element, "-o-transform");
            var transformOrigin = getCSS(element, "transform-origin") || getCSS(element, "-webkit-transform-origin") || getCSS(element, "-moz-transform-origin") || getCSS(element, "-ms-transform-origin") || getCSS(element, "-o-transform-origin") || "0px 0px";

            transformOrigin = transformOrigin.split(" ").map(removePx).map(Util.asFloat);

            var matrix;
            if (transform && transform !== "none") {
                var match = transform.match(transformRegExp);
                if (match) {
                    switch (match[1]) {
                        case "matrix":
                            matrix = match[2].split(",").map(Util.trimText).map(Util.asFloat);
                            break;
                    }
                }
            }

            return {
                origin: transformOrigin,
                matrix: matrix
            };
        }

        function createStack(element, parentStack, bounds, transform) {
            var ctx = h2cRenderContext((!parentStack) ? documentWidth() : bounds.width, (!parentStack) ? documentHeight() : bounds.height),
                    stack = {
                        ctx: ctx,
                        opacity: setOpacity(ctx, element, parentStack),
                        cssPosition: getCSS(element, "position"),
                        borders: getBorderData(element),
                        transform: transform,
                        clip: (parentStack && parentStack.clip) ? Util.Extend({}, parentStack.clip) : null
                    };

            setZ(element, stack, parentStack);

            // TODO correct overflow for absolute content residing under a static position
            if (options.useOverflow === true && /(hidden|scroll|auto)/.test(getCSS(element, "overflow")) === true && /(BODY)/i.test(element.nodeName) === false) {
                stack.clip = (stack.clip) ? clipBounds(stack.clip, bounds) : bounds;
            }

            return stack;
        }

        function getBackgroundBounds(borders, bounds, clip) {
            var backgroundBounds = {
                left: bounds.left + borders[3].width,
                top: bounds.top + borders[0].width,
                width: bounds.width - (borders[1].width + borders[3].width),
                height: bounds.height - (borders[0].width + borders[2].width)
            };

            if (clip) {
                backgroundBounds = clipBounds(backgroundBounds, clip);
            }

            return backgroundBounds;
        }

        function getBounds(element, transform) {
            var bounds = (transform.matrix) ? Util.OffsetBounds(element) : Util.Bounds(element);
            transform.origin[0] += bounds.left;
            transform.origin[1] += bounds.top;
            return bounds;
        }

        function renderElement(element, parentStack, ignoreBackground) {
            var transform = getTransform(element, parentStack),
                    bounds = getBounds(element, transform),
                    image,
                    stack = createStack(element, parentStack, bounds, transform),
                    borders = stack.borders,
                    ctx = stack.ctx,
                    backgroundBounds = getBackgroundBounds(borders, bounds, stack.clip),
                    borderData = parseBorders(element, bounds, borders),
                    backgroundColor = (ignoreElementsRegExp.test(element.nodeName)) ? "#efefef" : getCSS(element, "backgroundColor");


            createShape(ctx, borderData.clip);

            ctx.save();
            ctx.clip();

            if (backgroundBounds.height > 0 && backgroundBounds.width > 0 && !ignoreBackground) {
                renderBackgroundColor(ctx, bounds, backgroundColor);
                renderBackgroundImage(element, backgroundBounds, ctx);
            } else if (ignoreBackground) {
                stack.backgroundColor = backgroundColor;
            }

            ctx.restore();

            borderData.borders.forEach(function(border) {
                renderBorders(ctx, border.args, border.color);
            });

            switch (element.nodeName) {
                case "IMG":
                    if ((image = loadImage(element.getAttribute('src')))) {
                        renderImage(ctx, element, image, bounds, borders);
                    } else {
                        Util.log("html2canvas: Error loading <img>:" + element.getAttribute('src'));
                    }
                    break;
                case "INPUT":
                    // TODO add all relevant type's, i.e. HTML5 new stuff
                    // todo add support for placeholder attribute for browsers which support it
                    if (/^(text|url|email|submit|button|reset)$/.test(element.type) && (element.value || element.placeholder || "").length > 0) {
                        renderFormValue(element, bounds, stack);
                    }
                    break;
                case "TEXTAREA":
                    if ((element.value || element.placeholder || "").length > 0) {
                        renderFormValue(element, bounds, stack);
                    }
                    break;
                case "SELECT":
                    if ((element.options || element.placeholder || "").length > 0) {
                        renderFormValue(element, bounds, stack);
                    }
                    break;
                case "LI":
                    renderListItem(element, stack, backgroundBounds);
                    break;
                case "CANVAS":
                    renderImage(ctx, element, element, bounds, borders);
                    break;
            }

            return stack;
        }

        function isElementVisible(element) {
            return (getCSS(element, 'display') !== "none" && getCSS(element, 'visibility') !== "hidden" && !element.hasAttribute("data-html2canvas-ignore"));
        }

        function parseElement(element, stack, cb) {
            if (!cb) {
                cb = function() {
                };
            }
            if (isElementVisible(element)) {
                stack = renderElement(element, stack, false) || stack;
                if (!ignoreElementsRegExp.test(element.nodeName)) {
                    return parseChildren(element, stack, cb);
                }
            }
            cb();
        }

        function parseChildren(element, stack, cb) {
            var children = Util.Children(element);
            // After all nodes have processed, finished() will call the cb.
            // We add one and kick it off so this will still work when children.length === 0.
            // Note that unless async is true, this will happen synchronously, just will callbacks.
            var jobs = children.length + 1;
            finished();

            if (options.async) {
                children.forEach(function(node) {
                    // Don't block the page from rendering
                    setTimeout(function() {
                        parseNode(node);
                    }, 0);
                });
            } else {
                children.forEach(parseNode);
            }

            function parseNode(node) {
                if (node.nodeType === node.ELEMENT_NODE) {
                    parseElement(node, stack, finished);
                } else if (node.nodeType === node.TEXT_NODE) {
                    renderText(element, node, stack);
                    finished();
                } else {
                    finished();
                }
            }
            function finished(el) {
                if (--jobs <= 0) {
                    Util.log("finished rendering " + children.length + " children.");
                    cb();
                }
            }
        }
    };
    _html2canvas.Preload = function(options) {

        var images = {
            numLoaded: 0, // also failed are counted here
            numFailed: 0,
            numTotal: 0,
            cleanupDone: false
        },
        pageOrigin,
                Util = _html2canvas.Util,
                methods,
                i,
                count = 0,
                element = options.elements[0] || document.body,
                doc = element.ownerDocument,
                domImages = element.getElementsByTagName('img'), // Fetch images of the present element only
                imgLen = domImages.length,
                link = doc.createElement("a"),
                supportCORS = (function(img) {
                    return (img.crossOrigin !== undefined);
                })(new Image()),
                timeoutTimer;

        link.href = window.location.href;
        pageOrigin = link.protocol + link.host;

        function isSameOrigin(url) {
            link.href = url;
            link.href = link.href; // YES, BELIEVE IT OR NOT, that is required for IE9 - http://jsfiddle.net/niklasvh/2e48b/
            var origin = link.protocol + link.host;
            return (origin === pageOrigin);
        }

        function start() {
            Util.log("html2canvas: start: images: " + images.numLoaded + " / " + images.numTotal + " (failed: " + images.numFailed + ")");
            if (!images.firstRun && images.numLoaded >= images.numTotal) {
                Util.log("Finished loading images: # " + images.numTotal + " (failed: " + images.numFailed + ")");

                if (typeof options.complete === "function") {
                    options.complete(images);
                }

            }
        }

        // TODO modify proxy to serve images with CORS enabled, where available
        function proxyGetImage(url, img, imageObj) {
            var callback_name,
                    scriptUrl = options.proxy,
                    script;

            link.href = url;
            url = link.href; // work around for pages with base href="" set - WARNING: this may change the url

            callback_name = 'html2canvas_' + (count++);
            imageObj.callbackname = callback_name;

            if (scriptUrl.indexOf("?") > -1) {
                scriptUrl += "&";
            } else {
                scriptUrl += "?";
            }
            scriptUrl += 'url=' + encodeURIComponent(url) + '&callback=' + callback_name;
            script = doc.createElement("script");

            window[callback_name] = function(a) {
                if (a.substring(0, 6) === "error:") {
                    imageObj.succeeded = false;
                    images.numLoaded++;
                    images.numFailed++;
                    start();
                } else {
                    setImageLoadHandlers(img, imageObj);
                    img.src = a;
                }
                window[callback_name] = undefined; // to work with IE<9  // NOTE: that the undefined callback property-name still exists on the window object (for IE<9)
                try {
                    delete window[callback_name];  // for all browser that support this
                } catch (ex) {
                }
                script.parentNode.removeChild(script);
                script = null;
                delete imageObj.script;
                delete imageObj.callbackname;
            };

            script.setAttribute("type", "text/javascript");
            script.setAttribute("src", scriptUrl);
            imageObj.script = script;
            window.document.body.appendChild(script);

        }

        function loadPseudoElement(element, type) {
            var style = window.getComputedStyle(element, type),
                    content = style.content;
            if (content.substr(0, 3) === 'url') {
                methods.loadImage(_html2canvas.Util.parseBackgroundImage(content)[0].args[0]);
            }
            loadBackgroundImages(style.backgroundImage, element);
        }

        function loadPseudoElementImages(element) {
            loadPseudoElement(element, ":before");
            loadPseudoElement(element, ":after");
        }

        function loadGradientImage(backgroundImage, bounds) {
            var img = _html2canvas.Generate.Gradient(backgroundImage, bounds);

            if (img !== undefined) {
                images[backgroundImage] = {
                    img: img,
                    succeeded: true
                };
                images.numTotal++;
                images.numLoaded++;
                start();
            }
        }

        function invalidBackgrounds(background_image) {
            return (background_image && background_image.method && background_image.args && background_image.args.length > 0);
        }

        function loadBackgroundImages(background_image, el) {
            var bounds;

            _html2canvas.Util.parseBackgroundImage(background_image).filter(invalidBackgrounds).forEach(function(background_image) {
                if (background_image.method === 'url') {
                    methods.loadImage(background_image.args[0]);
                } else if (background_image.method.match(/\-?gradient$/)) {
                    if (bounds === undefined) {
                        bounds = _html2canvas.Util.Bounds(el);
                    }
                    loadGradientImage(background_image.value, bounds);
                }
            });
        }

        function getImages(el) {
            var elNodeType = false;

            // Firefox fails with permission denied on pages with iframes
            try {
                Util.Children(el).forEach(getImages);
            }
            catch (e) {
            }

            try {
                elNodeType = el.nodeType;
            } catch (ex) {
                elNodeType = false;
                Util.log("html2canvas: failed to access some element's nodeType - Exception: " + ex.message);
            }

            if (elNodeType === 1 || elNodeType === undefined) {
                loadPseudoElementImages(el);
                try {
                    loadBackgroundImages(Util.getCSS(el, 'backgroundImage'), el);
                } catch (e) {
                    Util.log("html2canvas: failed to get background-image - Exception: " + e.message);
                }
                loadBackgroundImages(el);
            }
        }

        function setImageLoadHandlers(img, imageObj) {
            img.onload = function() {
                if (imageObj.timer !== undefined) {
                    // CORS succeeded
                    window.clearTimeout(imageObj.timer);
                }

                images.numLoaded++;
                imageObj.succeeded = true;
                img.onerror = img.onload = null;
                start();
            };
            img.onerror = function() {
                if (img.crossOrigin === "anonymous") {
                    // CORS failed
                    window.clearTimeout(imageObj.timer);

                    // let's try with proxy instead
                    if (options.proxy) {
                        var src = img.src;
                        img = new Image();
                        imageObj.img = img;
                        img.src = src;

                        proxyGetImage(img.src, img, imageObj);
                        return;
                    }
                }

                images.numLoaded++;
                images.numFailed++;
                imageObj.succeeded = false;
                img.onerror = img.onload = null;
                start();
            };
        }

        methods = {
            loadImage: function(src) {
                var img, imageObj;
                if (src && images[src] === undefined) {
                    img = new Image();
                    if (src.match(/data:image\/.*;base64,/i)) {
                        img.src = src.replace(/url\(['"]{0,}|['"]{0,}\)$/ig, '');
                        imageObj = images[src] = {
                            img: img
                        };
                        images.numTotal++;
                        setImageLoadHandlers(img, imageObj);
                    } else if (isSameOrigin(src) || options.allowTaint === true) {
                        imageObj = images[src] = {
                            img: img
                        };
                        images.numTotal++;
                        setImageLoadHandlers(img, imageObj);
                        img.src = src;
                    } else if (supportCORS && !options.allowTaint && options.useCORS) {
                        // attempt to load with CORS

                        img.crossOrigin = "anonymous";
                        imageObj = images[src] = {
                            img: img
                        };
                        images.numTotal++;
                        setImageLoadHandlers(img, imageObj);
                        img.src = src;
                    } else if (options.proxy) {
                        imageObj = images[src] = {
                            img: img
                        };
                        images.numTotal++;
                        proxyGetImage(src, img, imageObj);
                    }
                }

            },
            cleanupDOM: function(cause) {
                var img, src;
                if (!images.cleanupDone) {
                    if (cause && typeof cause === "string") {
                        Util.log("html2canvas: Cleanup because: " + cause);
                    } else {
                        Util.log("html2canvas: Cleanup after timeout: " + options.timeout + " ms.");
                    }

                    for (src in images) {
                        if (images.hasOwnProperty(src)) {
                            img = images[src];
                            if (typeof img === "object" && img.callbackname && img.succeeded === undefined) {
                                // cancel proxy image request
                                window[img.callbackname] = undefined; // to work with IE<9  // NOTE: that the undefined callback property-name still exists on the window object (for IE<9)
                                try {
                                    delete window[img.callbackname];  // for all browser that support this
                                } catch (ex) {
                                }
                                if (img.script && img.script.parentNode) {
                                    img.script.setAttribute("src", "about:blank");  // try to cancel running request
                                    img.script.parentNode.removeChild(img.script);
                                }
                                images.numLoaded++;
                                images.numFailed++;
                                Util.log("html2canvas: Cleaned up failed img: '" + src + "' Steps: " + images.numLoaded + " / " + images.numTotal);
                            }
                        }
                    }

                    // cancel any pending requests
                    if (window.stop !== undefined) {
                        window.stop();
                    } else if (document.execCommand !== undefined) {
                        document.execCommand("Stop", false);
                    }
                    if (document.close !== undefined) {
                        document.close();
                    }
                    images.cleanupDone = true;
                    if (!(cause && typeof cause === "string")) {
                        start();
                    }
                }
            },
            renderingDone: function() {
                if (timeoutTimer) {
                    window.clearTimeout(timeoutTimer);
                }
            }
        };

        if (options.timeout > 0) {
            timeoutTimer = window.setTimeout(methods.cleanupDOM, options.timeout);
        }

        Util.log('html2canvas: Preload starts: finding background-images');
        images.firstRun = true;

        getImages(element);

        Util.log('html2canvas: Preload: Finding images');
        // load <img> images
        for (i = 0; i < imgLen; i += 1) {
            methods.loadImage(domImages[i].getAttribute("src"));
        }

        images.firstRun = false;
        Util.log('html2canvas: Preload: Done.');
        if (images.numTotal === images.numLoaded) {
            start();
        }

        return methods;
    };

    _html2canvas.Renderer = function(parseQueue, options) {
        function sortZindex(a, b) {
            if (a === 'children') {
                return -1;
            } else if (b === 'children') {
                return 1;
            } else {
                return a - b;
            }
        }

        // http://www.w3.org/TR/CSS21/zindex.html
        function createRenderQueue(parseQueue) {
            var queue = [],
                    rootContext;

            rootContext = (function buildStackingContext(rootNode) {
                var rootContext = {};
                function insert(context, node, specialParent) {
                    var zi = (node.zIndex.zindex === 'auto') ? 0 : Number(node.zIndex.zindex),
                            contextForChildren = context, // the stacking context for children
                            isPositioned = node.zIndex.isPositioned,
                            isFloated = node.zIndex.isFloated,
                            stub = {node: node},
                    childrenDest = specialParent; // where children without z-index should be pushed into

                    if (node.zIndex.ownStacking) {
                        contextForChildren = stub.context = {
                            children: [{node: node, children: []}]
                        };
                        childrenDest = undefined;
                    } else if (isPositioned || isFloated) {
                        childrenDest = stub.children = [];
                    }

                    if (zi === 0 && specialParent) {
                        specialParent.push(stub);
                    } else {
                        if (!context[zi]) {
                            context[zi] = [];
                        }
                        context[zi].push(stub);
                    }

                    node.zIndex.children.forEach(function(childNode) {
                        insert(contextForChildren, childNode, childrenDest);
                    });
                }
                insert(rootContext, rootNode);
                return rootContext;
            })(parseQueue);

            function sortZ(context) {
                Object.keys(context).sort(sortZindex).forEach(function(zi) {
                    var nonPositioned = [],
                            floated = [],
                            positioned = [],
                            list = [];

                    // positioned after static
                    context[zi].forEach(function(v) {
                        if (v.node.zIndex.isPositioned || v.node.zIndex.opacity < 1) {
                            // http://www.w3.org/TR/css3-color/#transparency
                            // non-positioned element with opactiy < 1 should be stacked as if it were a positioned element with ‘z-index: 0’ and ‘opacity: 1’.
                            positioned.push(v);
                        } else if (v.node.zIndex.isFloated) {
                            floated.push(v);
                        } else {
                            nonPositioned.push(v);
                        }
                    });

                    (function walk(arr) {
                        arr.forEach(function(v) {
                            list.push(v);
                            if (v.children) {
                                walk(v.children);
                            }
                        });
                    })(nonPositioned.concat(floated, positioned));

                    list.forEach(function(v) {
                        if (v.context) {
                            sortZ(v.context);
                        } else {
                            queue.push(v.node);
                        }
                    });
                });
            }

            sortZ(rootContext);

            return queue;
        }

        function getRenderer(rendererName) {
            var renderer;

            if (typeof options.renderer === "string" && _html2canvas.Renderer[rendererName] !== undefined) {
                renderer = _html2canvas.Renderer[rendererName](options);
            } else if (typeof rendererName === "function") {
                renderer = rendererName(options);
            } else {
                throw new Error("Unknown renderer");
            }

            if (typeof renderer !== "function") {
                throw new Error("Invalid renderer defined");
            }
            return renderer;
        }

        return getRenderer(options.renderer)(parseQueue, options, document, createRenderQueue(parseQueue.stack), _html2canvas);
    };

    _html2canvas.Util.Support = function(options, doc) {

        function supportSVGRendering() {
            var img = new Image(),
                    canvas = doc.createElement("canvas"),
                    ctx = (canvas.getContext === undefined) ? false : canvas.getContext("2d");
            if (ctx === false) {
                return false;
            }
            canvas.width = canvas.height = 10;
            img.src = [
                "data:image/svg+xml,",
                "<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'>",
                "<foreignObject width='10' height='10'>",
                "<div xmlns='http://www.w3.org/1999/xhtml' style='width:10;height:10;'>",
                "sup",
                "</div>",
                "</foreignObject>",
                "</svg>"
            ].join("");
            try {
                ctx.drawImage(img, 0, 0);
                canvas.toDataURL();
            } catch (e) {
                return false;
            }
            _html2canvas.Util.log('html2canvas: Parse: SVG powered rendering available');
            return true;
        }

        // Test whether we can use ranges to measure bounding boxes
        // Opera doesn't provide valid bounds.height/bottom even though it supports the method.

        function supportRangeBounds() {
            var r, testElement, rangeBounds, rangeHeight, support = false;

            if (doc.createRange) {
                r = doc.createRange();
                if (r.getBoundingClientRect) {
                    testElement = doc.createElement('boundtest');
                    testElement.style.height = "123px";
                    testElement.style.display = "block";
                    doc.body.appendChild(testElement);

                    r.selectNode(testElement);
                    rangeBounds = r.getBoundingClientRect();
                    rangeHeight = rangeBounds.height;

                    if (rangeHeight === 123) {
                        support = true;
                    }
                    doc.body.removeChild(testElement);
                }
            }

            return support;
        }

        return {
            rangeBounds: supportRangeBounds(),
            svgRendering: options.svgRendering && supportSVGRendering()
        };
    };
    window.html2canvas = function(elements, opts) {
        elements = (elements.length) ? elements : [elements];
        var queue,
                canvas,
                options = {
                    // general
                    logging: false,
                    elements: elements,
                    background: "#fff",
                    // preload options
                    proxy: null,
                    timeout: 0, // no timeout
                    useCORS: false, // try to load images as CORS (where available), before falling back to proxy
                    allowTaint: false, // whether to allow images to taint the canvas, won't need proxy if set to true

                    // parse options
                    svgRendering: false, // use svg powered rendering where available (FF11+)
                    ignoreElements: "IFRAME|OBJECT|PARAM",
                    useOverflow: true,
                    letterRendering: false,
                    chinese: false,
                    async: false, // If true, parsing will not block, but if the user scrolls during parse the image can get weird

                    // render options
                    width: null,
                    height: null,
                    taintTest: true, // do a taint test with all images before applying to canvas
                    renderer: "Canvas"
                };

        options = _html2canvas.Util.Extend(opts, options);

        _html2canvas.logging = options.logging;
        options.complete = function(images) {

            if (typeof options.onpreloaded === "function") {
                if (options.onpreloaded(images) === false) {
                    return;
                }
            }
            _html2canvas.Parse(images, options, function(queue) {
                if (typeof options.onparsed === "function") {
                    if (options.onparsed(queue) === false) {
                        return;
                    }
                }

                canvas = _html2canvas.Renderer(queue, options);

                if (typeof options.onrendered === "function") {
                    options.onrendered(canvas);
                }
            });
        };

        // for pages without images, we still want this to be async, i.e. return methods before executing
        window.setTimeout(function() {
            _html2canvas.Preload(options);
        }, 0);

        return {
            render: function(queue, opts) {
                return _html2canvas.Renderer(queue, _html2canvas.Util.Extend(opts, options));
            },
            parse: function(images, opts) {
                return _html2canvas.Parse(images, _html2canvas.Util.Extend(opts, options));
            },
            preload: function(opts) {
                return _html2canvas.Preload(_html2canvas.Util.Extend(opts, options));
            },
            log: _html2canvas.Util.log
        };
    };

    window.html2canvas.log = _html2canvas.Util.log; // for renderers
    window.html2canvas.Renderer = {
        Canvas: undefined // We are assuming this will be used
    };
    _html2canvas.Renderer.Canvas = function(options) {
        options = options || {};

        var doc = document,
                safeImages = [],
                testCanvas = document.createElement("canvas"),
                testctx = testCanvas.getContext("2d"),
                Util = _html2canvas.Util,
                canvas = options.canvas || doc.createElement('canvas');

        function createShape(ctx, args) {
            ctx.beginPath();
            args.forEach(function(arg) {
                ctx[arg.name].apply(ctx, arg['arguments']);
            });
            ctx.closePath();
        }

        function safeImage(item) {
            if (safeImages.indexOf(item['arguments'][0].src) === -1) {
                testctx.drawImage(item['arguments'][0], 0, 0);
                try {
                    testctx.getImageData(0, 0, 1, 1);
                } catch (e) {
                    testCanvas = doc.createElement("canvas");
                    testctx = testCanvas.getContext("2d");
                    return false;
                }
                safeImages.push(item['arguments'][0].src);
            }
            return true;
        }

        function renderItem(ctx, item) {
            switch (item.type) {
                case "variable":
                    ctx[item.name] = item['arguments'];
                    break;
                case "function":
                    switch (item.name) {
                        case "createPattern":
                            if (item['arguments'][0].width > 0 && item['arguments'][0].height > 0) {
                                try {
                                    ctx.fillStyle = ctx.createPattern(item['arguments'][0], "repeat");
                                } catch (e) {
                                    Util.log("html2canvas: Renderer: Error creating pattern", e.message);
                                }
                            }
                            break;
                        case "drawShape":
                            createShape(ctx, item['arguments']);
                            break;
                        case "drawImage":
                            if (item['arguments'][8] > 0 && item['arguments'][7] > 0) {
                                if (!options.taintTest || (options.taintTest && safeImage(item))) {
                                    ctx.drawImage.apply(ctx, item['arguments']);
                                }
                            }
                            break;
                        default:
                            ctx[item.name].apply(ctx, item['arguments']);
                    }
                    break;
            }
        }

        return function(parsedData, options, document, queue, _html2canvas) {
            var ctx = canvas.getContext("2d"),
                    newCanvas,
                    bounds,
                    fstyle,
                    zStack = parsedData.stack;

            canvas.width = canvas.style.width = options.width || zStack.ctx.width;
            canvas.height = canvas.style.height = options.height || zStack.ctx.height;

            fstyle = ctx.fillStyle;
            ctx.fillStyle = (Util.isTransparent(parsedData.backgroundColor) && options.background !== undefined) ? options.background : parsedData.backgroundColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = fstyle;
            queue.forEach(function(storageContext) {
                // set common settings for canvas
                ctx.textBaseline = "bottom";
                ctx.save();

                if (storageContext.transform.matrix) {
                    ctx.translate(storageContext.transform.origin[0], storageContext.transform.origin[1]);
                    ctx.transform.apply(ctx, storageContext.transform.matrix);
                    ctx.translate(-storageContext.transform.origin[0], -storageContext.transform.origin[1]);
                }

                if (storageContext.clip) {
                    ctx.beginPath();
                    ctx.rect(storageContext.clip.left, storageContext.clip.top, storageContext.clip.width, storageContext.clip.height);
                    ctx.clip();
                }

                if (storageContext.ctx.storage) {
                    storageContext.ctx.storage.forEach(function(item) {
                        renderItem(ctx, item);
                    });
                }

                ctx.restore();
            });

            Util.log("html2canvas: Renderer: Canvas renderer done - returning canvas obj");

            if (options.elements.length === 1) {
                if (typeof options.elements[0] === "object" && options.elements[0].nodeName !== "BODY") {
                    // crop image to the bounds of selected (single) element
                    bounds = _html2canvas.Util.Bounds(options.elements[0]);
                    newCanvas = document.createElement('canvas');
                    newCanvas.width = Math.ceil(bounds.width);
                    newCanvas.height = Math.ceil(bounds.height);
                    ctx = newCanvas.getContext("2d");

                    ctx.drawImage(canvas, bounds.left, bounds.top, bounds.width, bounds.height, 0, 0, bounds.width, bounds.height);
                    canvas = null;
                    return newCanvas;
                }
            }

            return canvas;
        };
    };
})(window, document);
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
if (!Array.prototype.indexOf) {
    Array.prototype.indexOf = function (searchElement /*, fromIndex */) {
        "use strict";

        if (this === void 0 || this === null) {
            throw new TypeError();
        }

        var t = Object(this);
        var len = t.length >>> 0;

        if (len === 0) {
            return -1;
        }

        var n = 0;
        if (arguments.length > 0) {
            n = Number(arguments[1]);
            if (n !== n) { // shortcut for verifying if it's NaN
                n = 0;
            } else if (n !== 0 && n !== (Infinity) && n !== -(Infinity)) {
                n = (n > 0 || -1) * Math.floor(Math.abs(n));
            }
        }

        if (n >= len) {
            return -1;
        }

        var k = n >= 0
                ? n
                : Math.max(len - Math.abs(n), 0);

        for (; k < len; k++) {
            if (k in t && t[k] === searchElement) {
                return k;
            }
        }

        return -1;
    };
}

// Instantiate the object
var I18n = I18n || {};

// Set default locale to english
I18n.defaultLocale = "en";

// Set default handling of translation fallbacks to false
I18n.fallbacks = false;

// Set default separator
I18n.defaultSeparator = ".";

// Set current locale to null
I18n.locale = null;

// Set the placeholder format. Accepts `{{placeholder}}` and `%{placeholder}`.
I18n.PLACEHOLDER = /(?:\{\{|%\{)(.*?)(?:\}\}?)/gm;

I18n.fallbackRules = {
};

I18n.pluralizationRules = {
    en: function (n) {
        return n === 0 ? ["zero", "none", "other"] : n === 1 ? "one" : "other";
    }
};

I18n.getFallbacks = function (locale) {
    if (locale === I18n.defaultLocale) {
        return [];
    } else if (!I18n.fallbackRules[locale]) {
        var rules = []
                , components = locale.split("-");

        for (var l = 1; l < components.length; l++) {
            rules.push(components.slice(0, l).join("-"));
        }

        rules.push(I18n.defaultLocale);

        I18n.fallbackRules[locale] = rules;
    }
    return I18n.fallbackRules[locale];
};

I18n.isValidNode = function (obj, node, undefined) {
    return obj[node] !== null && obj[node] !== undefined;
};

I18n.lookup = function (scope, options) {
    var options = options || {}
    , lookupInitialScope = scope
            , translations = this.prepareOptions(I18n.translations)
            , locale = options.locale || I18n.currentLocale()
            , messages = translations[locale] || {}
    , options = this.prepareOptions(options)
            , currentScope
            ;

    if (typeof (scope) === "object") {
        scope = scope.join(this.defaultSeparator);
    }

    if (options.scope) {
        scope = options.scope.toString() + this.defaultSeparator + scope;
    }

    scope = scope.split(this.defaultSeparator);

    while (messages && scope.length > 0) {
        currentScope = scope.shift();
        messages = messages[currentScope];
    }

    if (!messages) {
        if (I18n.fallbacks) {
            var fallbacks = this.getFallbacks(locale);
            for (var fallback = 0; fallback < fallbacks.length; fallbacks++) {
                messages = I18n.lookup(lookupInitialScope, this.prepareOptions({locale: fallbacks[fallback]}, options));
                if (messages) {
                    break;
                }
            }
        }

        if (!messages && this.isValidNode(options, "defaultValue")) {
            messages = options.defaultValue;
        }
    }

    return messages;
};

// Merge serveral hash options, checking if value is set before
// overwriting any value. The precedence is from left to right.
//
//   I18n.prepareOptions({name: "John Doe"}, {name: "Mary Doe", role: "user"});
//   #=> {name: "John Doe", role: "user"}
//
I18n.prepareOptions = function () {
    var options = {}
    , opts
            , count = arguments.length
            ;

    for (var i = 0; i < count; i++) {
        opts = arguments[i];

        if (!opts) {
            continue;
        }

        for (var key in opts) {
            if (!this.isValidNode(options, key)) {
                options[key] = opts[key];
            }
        }
    }

    return options;
};

I18n.interpolate = function (message, options) {
    if (message === undefined)
        return null;
    options = this.prepareOptions(options);
    var matches = message.match(this.PLACEHOLDER)
            , placeholder
            , value
            , name
            ;

    if (!matches) {
        return message;
    }

    for (var i = 0; placeholder === matches[i]; i++) {

        name = placeholder.replace(this.PLACEHOLDER, "$1");

        value = options[name];

        if (!this.isValidNode(options, name)) {
            value = "[missing " + placeholder + " value]";
        }

        regex = new RegExp(placeholder.replace(/\{/gm, "\\{").replace(/\}/gm, "\\}"));
        message = message.replace(regex, value);
    }

    return message;
};

I18n.translate = function (scope, options) {
    options = this.prepareOptions(options);
    var translation = this.lookup(scope, options);

    try {
        if (typeof (translation) === "object") {
            if (typeof (options.count) === "number") {
                return this.pluralize(options.count, scope, options);
            } else {
                return translation;
            }
        } else {
            return this.interpolate(translation, options);
        }
    } catch (err) {
        return this.missingTranslation(scope);
    }
};

I18n.localize = function (scope, value) {
    switch (scope) {
        case "currency":
            return this.toCurrency(value);
        case "number":
            scope = this.lookup("number.format");
            return this.toNumber(value, scope);
        case "percentage":
            return this.toPercentage(value);
        default:
            if (scope.match(/^(date|time)/)) {
                return this.toTime(scope, value);
            } else {
                return value.toString();
            }
    }
};

I18n.parseDate = function (date) {
    var matches, convertedDate;

    // we have a date, so just return it.
    if (typeof (date) === "object") {
        return date;
    }
    ;

    // it matches the following formats:
    //   yyyy-mm-dd
    //   yyyy-mm-dd[ T]hh:mm::ss
    //   yyyy-mm-dd[ T]hh:mm::ss
    //   yyyy-mm-dd[ T]hh:mm::ssZ
    //   yyyy-mm-dd[ T]hh:mm::ss+0000
    //
    matches = date.toString().match(/(\d{4})-(\d{2})-(\d{2})(?:[ T](\d{2}):(\d{2}):(\d{2}))?(Z|\+0000)?/);

    if (matches) {
        for (var i = 1; i <= 6; i++) {
            matches[i] = parseInt(matches[i], 10) || 0;
        }

        // month starts on 0
        matches[2] -= 1;

        if (matches[7]) {
            convertedDate = new Date(Date.UTC(matches[1], matches[2], matches[3], matches[4], matches[5], matches[6]));
        } else {
            convertedDate = new Date(matches[1], matches[2], matches[3], matches[4], matches[5], matches[6]);
        }
    } else if (typeof (date) === "number") {
        // UNIX timestamp
        convertedDate = new Date();
        convertedDate.setTime(date);
    } else if (date.match(/\d+ \d+:\d+:\d+ [+-]\d+ \d+/)) {
        // a valid javascript format with timezone info
        convertedDate = new Date();
        convertedDate.setTime(Date.parse(date));
    } else {
        // an arbitrary javascript string
        convertedDate = new Date();
        convertedDate.setTime(Date.parse(date));
    }

    return convertedDate;
};

I18n.toTime = function (scope, d) {
    var date = this.parseDate(d)
            , format = this.lookup(scope)
            ;

    if (date.toString().match(/invalid/i)) {
        return date.toString();
    }

    if (!format) {
        return date.toString();
    }

    return this.strftime(date, format);
};

I18n.strftime = function (date, format) {
    var options = this.lookup("date");

    if (!options) {
        return date.toString();
    }

    options.meridian = options.meridian || ["AM", "PM"];

    var weekDay = date.getDay()
            , day = date.getDate()
            , year = date.getFullYear()
            , month = date.getMonth() + 1
            , hour = date.getHours()
            , hour12 = hour
            , meridian = hour > 11 ? 1 : 0
            , secs = date.getSeconds()
            , mins = date.getMinutes()
            , offset = date.getTimezoneOffset()
            , absOffsetHours = Math.floor(Math.abs(offset / 60))
            , absOffsetMinutes = Math.abs(offset) - (absOffsetHours * 60)
            , timezoneoffset = (offset > 0 ? "-" : "+") + (absOffsetHours.toString().length < 2 ? "0" + absOffsetHours : absOffsetHours) + (absOffsetMinutes.toString().length < 2 ? "0" + absOffsetMinutes : absOffsetMinutes)
            ;

    if (hour12 > 12) {
        hour12 = hour12 - 12;
    } else if (hour12 === 0) {
        hour12 = 12;
    }

    var padding = function (n) {
        var s = "0" + n.toString();
        return s.substr(s.length - 2);
    };

    var f = format;
    f = f.replace("%a", options.abbr_day_names[weekDay]);
    f = f.replace("%A", options.day_names[weekDay]);
    f = f.replace("%b", options.abbr_month_names[month]);
    f = f.replace("%B", options.month_names[month]);
    f = f.replace("%d", padding(day));
    f = f.replace("%e", day);
    f = f.replace("%-d", day);
    f = f.replace("%H", padding(hour));
    f = f.replace("%-H", hour);
    f = f.replace("%I", padding(hour12));
    f = f.replace("%-I", hour12);
    f = f.replace("%m", padding(month));
    f = f.replace("%-m", month);
    f = f.replace("%M", padding(mins));
    f = f.replace("%-M", mins);
    f = f.replace("%p", options.meridian[meridian]);
    f = f.replace("%S", padding(secs));
    f = f.replace("%-S", secs);
    f = f.replace("%w", weekDay);
    f = f.replace("%y", padding(year));
    f = f.replace("%-y", padding(year).replace(/^0+/, ""));
    f = f.replace("%Y", year);
    f = f.replace("%z", timezoneoffset);

    return f;
};

I18n.toNumber = function (number, options) {
    options = this.prepareOptions(
            options,
            this.lookup("number.format"),
            {precision: 3, separator: ".", delimiter: ",", strip_insignificant_zeros: false}
    );

    var negative = number < 0
            , string = Math.abs(number).toFixed(options.precision).toString()
            , parts = string.split(".")
            , precision
            , buffer = []
            , formattedNumber
            ;

    number = parts[0];
    precision = parts[1];

    while (number.length > 0) {
        buffer.unshift(number.substr(Math.max(0, number.length - 3), 3));
        number = number.substr(0, number.length - 3);
    }

    formattedNumber = buffer.join(options.delimiter);

    if (options.precision > 0) {
        formattedNumber += options.separator + parts[1];
    }

    if (negative) {
        formattedNumber = "-" + formattedNumber;
    }

    if (options.strip_insignificant_zeros) {
        var regex = {
            separator: new RegExp(options.separator.replace(/\./, "\\.") + "$")
            , zeros: /0+$/
        };

        formattedNumber = formattedNumber
                .replace(regex.zeros, "")
                .replace(regex.separator, "")
                ;
    }

    return formattedNumber;
};

I18n.toCurrency = function (number, options) {
    options = this.prepareOptions(
            options,
            this.lookup("number.currency.format"),
            this.lookup("number.format"),
            {unit: "$", precision: 2, format: "%u%n", delimiter: ",", separator: "."}
    );

    number = this.toNumber(number, options);
    number = options.format
            .replace("%u", options.unit)
            .replace("%n", number)
            ;

    return number;
};

I18n.toHumanSize = function (number, options) {
    var kb = 1024
            , size = number
            , iterations = 0
            , unit
            , precision
            ;

    while (size >= kb && iterations < 4) {
        size = size / kb;
        iterations += 1;
    }

    if (iterations === 0) {
        unit = this.t("number.human.storage_units.units.byte", {count: size});
        precision = 0;
    } else {
        unit = this.t("number.human.storage_units.units." + [null, "kb", "mb", "gb", "tb"][iterations]);
        precision = (size - Math.floor(size) === 0) ? 0 : 1;
    }

    options = this.prepareOptions(
            options,
            {precision: precision, format: "%n%u", delimiter: ""}
    );

    number = this.toNumber(size, options);
    number = options.format
            .replace("%u", unit)
            .replace("%n", number)
            ;

    return number;
};

I18n.toPercentage = function (number, options) {
    options = this.prepareOptions(
            options,
            this.lookup("number.percentage.format"),
            this.lookup("number.format"),
            {precision: 3, separator: ".", delimiter: ""}
    );

    number = this.toNumber(number, options);
    return number + "%";
};

I18n.pluralizer = function (locale) {
    pluralizer = this.pluralizationRules[locale];
    if (pluralizer !== undefined)
        return pluralizer;
    return this.pluralizationRules["en"];
};

I18n.findAndTranslateValidNode = function (keys, translation) {
    for (i = 0; i < keys.length; i++) {
        key = keys[i];
        if (this.isValidNode(translation, key))
            return translation[key];
    }
    return null;
};

I18n.pluralize = function (count, scope, options) {
    var translation;

    try {
        translation = this.lookup(scope, options);
    } catch (error) {
    }

    if (!translation) {
        return this.missingTranslation(scope);
    }

    var message;
    options = this.prepareOptions(options);
    options.count = count.toString();

    pluralizer = this.pluralizer(this.currentLocale());
    key = pluralizer(Math.abs(count));
    keys = ((typeof key === "object") && (key instanceof Array)) ? key : [key];

    message = this.findAndTranslateValidNode(keys, translation);
    if (message === null)
        message = this.missingTranslation(scope, keys[0]);

    return this.interpolate(message, options);
};

I18n.missingTranslation = function () {
    var message = '[missing "' + this.currentLocale()
            , count = arguments.length
            ;

    for (var i = 0; i < count; i++) {
        message += "." + arguments[i];
    }

    message += '" translation]';

    return message;
};

I18n.currentLocale = function () {
    return (I18n.locale || I18n.defaultLocale);
};

// shortcuts
I18n.t = I18n.translate;
I18n.l = I18n.localize;
I18n.p = I18n.pluralize;

/** @preserve
 * jsPDF - PDF Document creation from JavaScript
 * Version ${versionID}
 *                           CommitID ${commitID}
 *
 * Copyright (c) 2010-2014 James Hall, https://github.com/MrRio/jsPDF
 *               2010 Aaron Spike, https://github.com/acspike
 *               2012 Willow Systems Corporation, willow-systems.com
 *               2012 Pablo Hess, https://github.com/pablohess
 *               2012 Florian Jenett, https://github.com/fjenett
 *               2013 Warren Weckesser, https://github.com/warrenweckesser
 *               2013 Youssef Beddad, https://github.com/lifof
 *               2013 Lee Driscoll, https://github.com/lsdriscoll
 *               2013 Stefan Slonevskiy, https://github.com/stefslon
 *               2013 Jeremy Morel, https://github.com/jmorel
 *               2013 Christoph Hartmann, https://github.com/chris-rock
 *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
 *               2014 James Makes, https://github.com/dollaruw
 *               2014 Diego Casorran, https://github.com/diegocr
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Contributor(s):
 *    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,
 *    kim3er, mfo, alnorth,
 */

/**
 * Creates new jsPDF document object instance.
 *
 * @class
 * @param orientation One of "portrait" or "landscape" (or shortcuts "p" (Default), "l")
 * @param unit        Measurement unit to be used when coordinates are specified.
 *                    One of "pt" (points), "mm" (Default), "cm", "in"
 * @param format      One of 'pageFormats' as shown below, default: a4
 * @returns {jsPDF}
 * @name jsPDF
 */
var jsPDF = (function(global) {
	'use strict';
	var pdfVersion = '1.3',
		pageFormats = { // Size in pt of various paper formats
			'a0'  : [2383.94, 3370.39], 'a1'  : [1683.78, 2383.94],
			'a2'  : [1190.55, 1683.78], 'a3'  : [ 841.89, 1190.55],
			'a4'  : [ 595.28,  841.89], 'a5'  : [ 419.53,  595.28],
			'a6'  : [ 297.64,  419.53], 'a7'  : [ 209.76,  297.64],
			'a8'  : [ 147.40,  209.76], 'a9'  : [ 104.88,  147.40],
			'a10' : [  73.70,  104.88], 'b0'  : [2834.65, 4008.19],
			'b1'  : [2004.09, 2834.65], 'b2'  : [1417.32, 2004.09],
			'b3'  : [1000.63, 1417.32], 'b4'  : [ 708.66, 1000.63],
			'b5'  : [ 498.90,  708.66], 'b6'  : [ 354.33,  498.90],
			'b7'  : [ 249.45,  354.33], 'b8'  : [ 175.75,  249.45],
			'b9'  : [ 124.72,  175.75], 'b10' : [  87.87,  124.72],
			'c0'  : [2599.37, 3676.54], 'c1'  : [1836.85, 2599.37],
			'c2'  : [1298.27, 1836.85], 'c3'  : [ 918.43, 1298.27],
			'c4'  : [ 649.13,  918.43], 'c5'  : [ 459.21,  649.13],
			'c6'  : [ 323.15,  459.21], 'c7'  : [ 229.61,  323.15],
			'c8'  : [ 161.57,  229.61], 'c9'  : [ 113.39,  161.57],
			'c10' : [  79.37,  113.39], 'dl'  : [ 311.81,  623.62],
			'letter'            : [612,   792],
			'government-letter' : [576,   756],
			'legal'             : [612,  1008],
			'junior-legal'      : [576,   360],
			'ledger'            : [1224,  792],
			'tabloid'           : [792,  1224],
			'credit-card'       : [153,   243]
		};

	/**
	 * jsPDF's Internal PubSub Implementation.
	 * See mrrio.github.io/jsPDF/doc/symbols/PubSub.html
	 * Backward compatible rewritten on 2014 by
	 * Diego Casorran, https://github.com/diegocr
	 *
	 * @class
	 * @name PubSub
	 */
	function PubSub(context) {
		var topics = {};

		this.subscribe = function(topic, callback, once) {
			if(typeof callback !== 'function') {
				return false;
			}

			if(!topics.hasOwnProperty(topic)) {
				topics[topic] = {};
			}

			var id = Math.random().toString(35);
			topics[topic][id] = [callback,!!once];

			return id;
		};

		this.unsubscribe = function(token) {
			for(var topic in topics) {
				if(topics[topic][token]) {
					delete topics[topic][token];
					return true;
				}
			}
			return false;
		};

		this.publish = function(topic) {
			if(topics.hasOwnProperty(topic)) {
				var args = Array.prototype.slice.call(arguments, 1), idr = [];

				for(var id in topics[topic]) {
					var sub = topics[topic][id];
					try {
						sub[0].apply(context, args);
					} catch(ex) {
						if(global.console) {
							console.error('jsPDF PubSub Error', ex.message, ex);
						}
					}
					if(sub[1]) idr.push(id);
				}
				if(idr.length) idr.forEach(this.unsubscribe);
			}
		};
	}

	/**
	 * @constructor
	 * @private
	 */
	function jsPDF(orientation, unit, format, compressPdf) {
		var options = {};

		if (typeof orientation === 'object') {
			options = orientation;

			orientation = options.orientation;
			unit = options.unit || unit;
			format = options.format || format;
			compressPdf = options.compress || options.compressPdf || compressPdf;
		}

		// Default options
		unit        = unit || 'mm';
		format      = format || 'a4';
		orientation = ('' + (orientation || 'P')).toLowerCase();

		var format_as_string = ('' + format).toLowerCase(),
			compress = !!compressPdf && typeof Uint8Array === 'function',
			textColor            = options.textColor  || '0 g',
			drawColor            = options.drawColor  || '0 G',
			activeFontSize       = options.fontSize   || 16,
			lineHeightProportion = options.lineHeight || 1.15,
			lineWidth            = options.lineWidth  || 0.200025, // 2mm
			objectNumber =  2,  // 'n' Current object number
			outToPages   = !1,  // switches where out() prints. outToPages true = push to pages obj. outToPages false = doc builder content
			offsets      = [],  // List of offsets. Activated and reset by buildDocument(). Pupulated by various calls buildDocument makes.
			fonts        = {},  // collection of font objects, where key is fontKey - a dynamically created label for a given font.
			fontmap      = {},  // mapping structure fontName > fontStyle > font key - performance layer. See addFont()
			activeFontKey,      // will be string representing the KEY of the font as combination of fontName + fontStyle
			k,                  // Scale factor
			tmp,
			page = 0,
			pages = [],
			content = [],
			lineCapID = 0,
			lineJoinID = 0,
			content_length = 0,
			pageWidth,
			pageHeight,
			documentProperties = {
				'title'    : '',
				'subject'  : '',
				'author'   : '',
				'keywords' : '',
				'creator'  : ''
			},
			API = {},
			events = new PubSub(API),

		/////////////////////
		// Private functions
		/////////////////////
		f2 = function(number) {
			return number.toFixed(2); // Ie, %.2f
		},
		f3 = function(number) {
			return number.toFixed(3); // Ie, %.3f
		},
		padd2 = function(number) {
			return ('0' + parseInt(number)).slice(-2);
		},
		out = function(string) {
			if (outToPages) {
				/* set by beginPage */
				pages[page].push(string);
			} else {
				// +1 for '\n' that will be used to join 'content'
				content_length += string.length + 1;
				content.push(string);
			}
		},
		newObject = function() {
			// Begin a new object
			objectNumber++;
			offsets[objectNumber] = content_length;
			out(objectNumber + ' 0 obj');
			return objectNumber;
		},
		putStream = function(str) {
			out('stream');
			out(str);
			out('endstream');
		},
		putPages = function() {
			var n,p,arr,i,deflater,adler32,wPt = pageWidth * k, hPt = pageHeight * k, adler32cs;

			adler32cs = global.adler32cs || jsPDF.adler32cs;
			if (compress && typeof adler32cs === 'undefined') {
				compress = false;
			}

			// outToPages = false as set in endDocument(). out() writes to content.

			for (n = 1; n <= page; n++) {
				newObject();
				out('<</Type /Page');
				out('/Parent 1 0 R');
				out('/Resources 2 0 R');
				out('/Contents ' + (objectNumber + 1) + ' 0 R>>');
				out('endobj');

				// Page content
				p = pages[n].join('\n');
				newObject();
				if (compress) {
					arr = [];
					i = p.length;
					while(i--) {
						arr[i] = p.charCodeAt(i);
					}
					adler32 = adler32cs.from(p);
					deflater = new Deflater(6);
					deflater.append(new Uint8Array(arr));
					p = deflater.flush();
					arr = new Uint8Array(p.length + 6);
					arr.set(new Uint8Array([120, 156])),
					arr.set(p, 2);
					arr.set(new Uint8Array([adler32 & 0xFF, (adler32 >> 8) & 0xFF, (adler32 >> 16) & 0xFF, (adler32 >> 24) & 0xFF]), p.length+2);
					p = String.fromCharCode.apply(null, arr);
					out('<</Length ' + p.length + ' /Filter [/FlateDecode]>>');
				} else {
					out('<</Length ' + p.length + '>>');
				}
				putStream(p);
				out('endobj');
			}
			offsets[1] = content_length;
			out('1 0 obj');
			out('<</Type /Pages');
			var kids = '/Kids [';
			for (i = 0; i < page; i++) {
				kids += (3 + 2 * i) + ' 0 R ';
			}
			out(kids + ']');
			out('/Count ' + page);
			out('/MediaBox [0 0 ' + f2(wPt) + ' ' + f2(hPt) + ']');
			out('>>');
			out('endobj');
		},
		putFont = function(font) {
			font.objectNumber = newObject();
			out('<</BaseFont/' + font.PostScriptName + '/Type/Font');
			if (typeof font.encoding === 'string') {
				out('/Encoding/' + font.encoding);
			}
			out('/Subtype/Type1>>');
			out('endobj');
		},
		putFonts = function() {
			for (var fontKey in fonts) {
				if (fonts.hasOwnProperty(fontKey)) {
					putFont(fonts[fontKey]);
				}
			}
		},
		putXobjectDict = function() {
			// Loop through images, or other data objects
			events.publish('putXobjectDict');
		},
		putResourceDictionary = function() {
			out('/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]');
			out('/Font <<');

			// Do this for each font, the '1' bit is the index of the font
			for (var fontKey in fonts) {
				if (fonts.hasOwnProperty(fontKey)) {
					out('/' + fontKey + ' ' + fonts[fontKey].objectNumber + ' 0 R');
				}
			}
			out('>>');
			out('/XObject <<');
			putXobjectDict();
			out('>>');
		},
		putResources = function() {
			putFonts();
			events.publish('putResources');
			// Resource dictionary
			offsets[2] = content_length;
			out('2 0 obj');
			out('<<');
			putResourceDictionary();
			out('>>');
			out('endobj');
			events.publish('postPutResources');
		},
		addToFontDictionary = function(fontKey, fontName, fontStyle) {
			// this is mapping structure for quick font key lookup.
			// returns the KEY of the font (ex: "F1") for a given
			// pair of font name and type (ex: "Arial". "Italic")
			if (!fontmap.hasOwnProperty(fontName)) {
				fontmap[fontName] = {};
			}
			fontmap[fontName][fontStyle] = fontKey;
		},
		/**
		 * FontObject describes a particular font as member of an instnace of jsPDF
		 *
		 * It's a collection of properties like 'id' (to be used in PDF stream),
		 * 'fontName' (font's family name), 'fontStyle' (font's style variant label)
		 *
		 * @class
		 * @public
		 * @property id {String} PDF-document-instance-specific label assinged to the font.
		 * @property PostScriptName {String} PDF specification full name for the font
		 * @property encoding {Object} Encoding_name-to-Font_metrics_object mapping.
		 * @name FontObject
		 */
		addFont = function(PostScriptName, fontName, fontStyle, encoding) {
			var fontKey = 'F' + (Object.keys(fonts).length + 1).toString(10),
			// This is FontObject
			font = fonts[fontKey] = {
				'id'             : fontKey,
				'PostScriptName' : PostScriptName,
				'fontName'       : fontName,
				'fontStyle'      : fontStyle,
				'encoding'       : encoding,
				'metadata'       : {}
			};
			addToFontDictionary(fontKey, fontName, fontStyle);
			events.publish('addFont', font);

			return fontKey;
		},
		addFonts = function() {

			var HELVETICA     = "helvetica",
				TIMES         = "times",
				COURIER       = "courier",
				NORMAL        = "normal",
				BOLD          = "bold",
				ITALIC        = "italic",
				BOLD_ITALIC   = "bolditalic",
				encoding      = 'StandardEncoding',
				standardFonts = [
					['Helvetica', HELVETICA, NORMAL],
					['Helvetica-Bold', HELVETICA, BOLD],
					['Helvetica-Oblique', HELVETICA, ITALIC],
					['Helvetica-BoldOblique', HELVETICA, BOLD_ITALIC],
					['Courier', COURIER, NORMAL],
					['Courier-Bold', COURIER, BOLD],
					['Courier-Oblique', COURIER, ITALIC],
					['Courier-BoldOblique', COURIER, BOLD_ITALIC],
					['Times-Roman', TIMES, NORMAL],
					['Times-Bold', TIMES, BOLD],
					['Times-Italic', TIMES, ITALIC],
					['Times-BoldItalic', TIMES, BOLD_ITALIC]
				];

			for (var i = 0, l = standardFonts.length; i < l; i++) {
				var fontKey = addFont(
						standardFonts[i][0],
						standardFonts[i][1],
						standardFonts[i][2],
						encoding);

				// adding aliases for standard fonts, this time matching the capitalization
				var parts = standardFonts[i][0].split('-');
				addToFontDictionary(fontKey, parts[0], parts[1] || '');
			}
			events.publish('addFonts', { fonts : fonts, dictionary : fontmap });
		},
		SAFE = function __safeCall(fn) {
			fn.foo = function __safeCallWrapper() {
				try {
					return fn.apply(this, arguments);
				} catch (e) {
					var stack = e.stack || '';
					if(~stack.indexOf(' at ')) stack = stack.split(" at ")[1];
					var m = "Error in function " + stack.split("\n")[0].split('<')[0] + ": " + e.message;
					if(global.console) {
						global.console.error(m, e);
						if(global.alert) alert(m);
					} else {
						throw new Error(m);
					}
				}
			};
			fn.foo.bar = fn;
			return fn.foo;
		},
		to8bitStream = function(text, flags) {
		/**
		 * PDF 1.3 spec:
		 * "For text strings encoded in Unicode, the first two bytes must be 254 followed by
		 * 255, representing the Unicode byte order marker, U+FEFF. (This sequence conflicts
		 * with the PDFDocEncoding character sequence thorn ydieresis, which is unlikely
		 * to be a meaningful beginning of a word or phrase.) The remainder of the
		 * string consists of Unicode character codes, according to the UTF-16 encoding
		 * specified in the Unicode standard, version 2.0. Commonly used Unicode values
		 * are represented as 2 bytes per character, with the high-order byte appearing first
		 * in the string."
		 *
		 * In other words, if there are chars in a string with char code above 255, we
		 * recode the string to UCS2 BE - string doubles in length and BOM is prepended.
		 *
		 * HOWEVER!
		 * Actual *content* (body) text (as opposed to strings used in document properties etc)
		 * does NOT expect BOM. There, it is treated as a literal GID (Glyph ID)
		 *
		 * Because of Adobe's focus on "you subset your fonts!" you are not supposed to have
		 * a font that maps directly Unicode (UCS2 / UTF16BE) code to font GID, but you could
		 * fudge it with "Identity-H" encoding and custom CIDtoGID map that mimics Unicode
		 * code page. There, however, all characters in the stream are treated as GIDs,
		 * including BOM, which is the reason we need to skip BOM in content text (i.e. that
		 * that is tied to a font).
		 *
		 * To signal this "special" PDFEscape / to8bitStream handling mode,
		 * API.text() function sets (unless you overwrite it with manual values
		 * given to API.text(.., flags) )
		 * flags.autoencode = true
		 * flags.noBOM = true
		 *
		 * ===================================================================================
		 * `flags` properties relied upon:
		 *   .sourceEncoding = string with encoding label.
		 *                     "Unicode" by default. = encoding of the incoming text.
		 *                     pass some non-existing encoding name
		 *                     (ex: 'Do not touch my strings! I know what I am doing.')
		 *                     to make encoding code skip the encoding step.
		 *   .outputEncoding = Either valid PDF encoding name
		 *                     (must be supported by jsPDF font metrics, otherwise no encoding)
		 *                     or a JS object, where key = sourceCharCode, value = outputCharCode
		 *                     missing keys will be treated as: sourceCharCode === outputCharCode
		 *   .noBOM
		 *       See comment higher above for explanation for why this is important
		 *   .autoencode
		 *       See comment higher above for explanation for why this is important
		 */

			var i,l,sourceEncoding,encodingBlock,outputEncoding,newtext,isUnicode,ch,bch;

			flags = flags || {};
			sourceEncoding = flags.sourceEncoding || 'Unicode';
			outputEncoding = flags.outputEncoding;

			// This 'encoding' section relies on font metrics format
			// attached to font objects by, among others,
			// "Willow Systems' standard_font_metrics plugin"
			// see jspdf.plugin.standard_font_metrics.js for format
			// of the font.metadata.encoding Object.
			// It should be something like
			//   .encoding = {'codePages':['WinANSI....'], 'WinANSI...':{code:code, ...}}
			//   .widths = {0:width, code:width, ..., 'fof':divisor}
			//   .kerning = {code:{previous_char_code:shift, ..., 'fof':-divisor},...}
			if ((flags.autoencode || outputEncoding) &&
				fonts[activeFontKey].metadata &&
				fonts[activeFontKey].metadata[sourceEncoding] &&
				fonts[activeFontKey].metadata[sourceEncoding].encoding) {
				encodingBlock = fonts[activeFontKey].metadata[sourceEncoding].encoding;

				// each font has default encoding. Some have it clearly defined.
				if (!outputEncoding && fonts[activeFontKey].encoding) {
					outputEncoding = fonts[activeFontKey].encoding;
				}

				// Hmmm, the above did not work? Let's try again, in different place.
				if (!outputEncoding && encodingBlock.codePages) {
					outputEncoding = encodingBlock.codePages[0]; // let's say, first one is the default
				}

				if (typeof outputEncoding === 'string') {
					outputEncoding = encodingBlock[outputEncoding];
				}
				// we want output encoding to be a JS Object, where
				// key = sourceEncoding's character code and
				// value = outputEncoding's character code.
				if (outputEncoding) {
					isUnicode = false;
					newtext = [];
					for (i = 0, l = text.length; i < l; i++) {
						ch = outputEncoding[text.charCodeAt(i)];
						if (ch) {
							newtext.push(
								String.fromCharCode(ch));
						} else {
							newtext.push(
								text[i]);
						}

						// since we are looping over chars anyway, might as well
						// check for residual unicodeness
						if (newtext[i].charCodeAt(0) >> 8) {
							/* more than 255 */
							isUnicode = true;
						}
					}
					text = newtext.join('');
				}
			}

			i = text.length;
			// isUnicode may be set to false above. Hence the triple-equal to undefined
			while (isUnicode === undefined && i !== 0) {
				if (text.charCodeAt(i - 1) >> 8) {
					/* more than 255 */
					isUnicode = true;
				}
				i--;
			}
			if (!isUnicode) {
				return text;
			}

			newtext = flags.noBOM ? [] : [254, 255];
			for (i = 0, l = text.length; i < l; i++) {
				ch = text.charCodeAt(i);
				bch = ch >> 8; // divide by 256
				if (bch >> 8) {
					/* something left after dividing by 256 second time */
					throw new Error("Character at position " + i + " of string '"
						+ text + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
				}
				newtext.push(bch);
				newtext.push(ch - (bch << 8));
			}
			return String.fromCharCode.apply(undefined, newtext);
		},
		pdfEscape = function(text, flags) {
			/**
			 * Replace '/', '(', and ')' with pdf-safe versions
			 *
			 * Doing to8bitStream does NOT make this PDF display unicode text. For that
			 * we also need to reference a unicode font and embed it - royal pain in the rear.
			 *
			 * There is still a benefit to to8bitStream - PDF simply cannot handle 16bit chars,
			 * which JavaScript Strings are happy to provide. So, while we still cannot display
			 * 2-byte characters property, at least CONDITIONALLY converting (entire string containing)
			 * 16bit chars to (USC-2-BE) 2-bytes per char + BOM streams we ensure that entire PDF
			 * is still parseable.
			 * This will allow immediate support for unicode in document properties strings.
			 */
			return to8bitStream(text, flags).replace(/\\/g, '\\\\').replace(/\(/g, '\\(').replace(/\)/g, '\\)');
		},
		putInfo = function() {
			out('/Producer (jsPDF ' + jsPDF.version + ')');
			for(var key in documentProperties) {
				if(documentProperties.hasOwnProperty(key) && documentProperties[key]) {
					out('/'+key.substr(0,1).toUpperCase() + key.substr(1)
						+' (' + pdfEscape(documentProperties[key]) + ')');
				}
			}
			var created = new Date();
			out(['/CreationDate (D:',
					created.getFullYear(),
					padd2(created.getMonth() + 1),
					padd2(created.getDate()),
					padd2(created.getHours()),
					padd2(created.getMinutes()),
					padd2(created.getSeconds()), ')'].join(''));
		},
		putCatalog = function() {
			out('/Type /Catalog');
			out('/Pages 1 0 R');
			// @TODO: Add zoom and layout modes
			out('/OpenAction [3 0 R /FitH null]');
			out('/PageLayout /OneColumn');
			events.publish('putCatalog');
		},
		putTrailer = function() {
			out('/Size ' + (objectNumber + 1));
			out('/Root ' + objectNumber + ' 0 R');
			out('/Info ' + (objectNumber - 1) + ' 0 R');
		},
		beginPage = function() {
			page++;
			// Do dimension stuff
			outToPages = true;
			pages[page] = [];
		},
		_addPage = function() {
			beginPage();
			// Set line width
			out(f2(lineWidth * k) + ' w');
			// Set draw color
			out(drawColor);
			// resurrecting non-default line caps, joins
			if (lineCapID !== 0) {
				out(lineCapID + ' J');
			}
			if (lineJoinID !== 0) {
				out(lineJoinID + ' j');
			}
			events.publish('addPage', { pageNumber : page });
		},
		/**
		 * Returns a document-specific font key - a label assigned to a
		 * font name + font type combination at the time the font was added
		 * to the font inventory.
		 *
		 * Font key is used as label for the desired font for a block of text
		 * to be added to the PDF document stream.
		 * @private
		 * @function
		 * @param fontName {String} can be undefined on "falthy" to indicate "use current"
		 * @param fontStyle {String} can be undefined on "falthy" to indicate "use current"
		 * @returns {String} Font key.
		 */
		getFont = function(fontName, fontStyle) {
			var key;

			fontName  = fontName  !== undefined ? fontName  : fonts[activeFontKey].fontName;
			fontStyle = fontStyle !== undefined ? fontStyle : fonts[activeFontKey].fontStyle;

			try {
			 // get a string like 'F3' - the KEY corresponding tot he font + type combination.
				key = fontmap[fontName][fontStyle];
			} catch (e) {}

			if (!key) {
				throw new Error("Unable to look up font label for font '" + fontName + "', '"
					+ fontStyle + "'. Refer to getFontList() for available fonts.");
			}
			return key;
		},
		buildDocument = function() {

			outToPages = false; // switches out() to content
			objectNumber = 2;
			content = [];
			offsets = [];

			// putHeader()
			out('%PDF-' + pdfVersion);

			putPages();

			putResources();

			// Info
			newObject();
			out('<<');
			putInfo();
			out('>>');
			out('endobj');

			// Catalog
			newObject();
			out('<<');
			putCatalog();
			out('>>');
			out('endobj');

			// Cross-ref
			var o = content_length, i, p = "0000000000";
			out('xref');
			out('0 ' + (objectNumber + 1));
			out(p+' 65535 f ');
			for (i = 1; i <= objectNumber; i++) {
				out((p + offsets[i]).slice(-10) + ' 00000 n ');
			}
			// Trailer
			out('trailer');
			out('<<');
			putTrailer();
			out('>>');
			out('startxref');
			out(o);
			out('%%EOF');

			outToPages = true;

			return content.join('\n');
		},
		getStyle = function(style) {
			// see path-painting operators in PDF spec
			var op = 'S'; // stroke
			if (style === 'F') {
				op = 'f'; // fill
			} else if (style === 'FD' || style === 'DF') {
				op = 'B'; // both
			} else if (style === 'f' || style === 'f*' || style === 'B' || style === 'B*') {
				/*
				Allow direct use of these PDF path-painting operators:
				- f	fill using nonzero winding number rule
				- f*	fill using even-odd rule
				- B	fill then stroke with fill using non-zero winding number rule
				- B*	fill then stroke with fill using even-odd rule
				*/
				op = style;
			}
			return op;
		},
		getArrayBuffer = function() {
			var data = buildDocument(), len = data.length,
				ab = new ArrayBuffer(len), u8 = new Uint8Array(ab);

			while(len--) u8[len] = data.charCodeAt(len);
			return ab;
		},
		getBlob = function() {
			return new Blob([getArrayBuffer()], { type : "application/pdf" });
		},
		/**
		 * Generates the PDF document.
		 *
		 * If `type` argument is undefined, output is raw body of resulting PDF returned as a string.
		 *
		 * @param {String} type A string identifying one of the possible output types.
		 * @param {Object} options An object providing some additional signalling to PDF generator.
		 * @function
		 * @returns {jsPDF}
		 * @methodOf jsPDF#
		 * @name output
		 */
		output = SAFE(function(type, options) {
			var datauri = ('' + type).substr(0,6) === 'dataur'
				? 'data:application/pdf;base64,'+btoa(buildDocument()):0;

			switch (type) {
				case undefined:
					return buildDocument();
				case 'save':
					if (navigator.getUserMedia) {
						if (global.URL === undefined
						|| global.URL.createObjectURL === undefined) {
							return API.output('dataurlnewwindow');
						}
					}
					saveAs(getBlob(), options);
					if(typeof saveAs.unload === 'function') {
						if(global.setTimeout) {
							setTimeout(saveAs.unload,911);
						}
					}
					break;
				case 'arraybuffer':
					return getArrayBuffer();
				case 'blob':
					return getBlob();
				case 'bloburi':
				case 'bloburl':
					// User is responsible of calling revokeObjectURL
					return global.URL && global.URL.createObjectURL(getBlob()) || void 0;
				case 'datauristring':
				case 'dataurlstring':
					return datauri;
				case 'dataurlnewwindow':
					var nW = global.open(datauri);
					if (nW || typeof safari === "undefined") return nW;
					/* pass through */
				case 'datauri':
				case 'dataurl':
					return global.document.location.href = datauri;
				default:
					throw new Error('Output type "' + type + '" is not supported.');
			}
			// @TODO: Add different output options
		});

		switch (unit) {
			case 'pt':  k = 1;          break;
			case 'mm':  k = 72 / 25.4;  break;
			case 'cm':  k = 72 / 2.54;  break;
			case 'in':  k = 72;         break;
			case 'px':  k = 96 / 72;    break;
			case 'pc':  k = 12;         break;
			case 'em':  k = 12;         break;
			case 'ex':  k = 6;          break;
			default:
				throw ('Invalid unit: ' + unit);
		}

		// Dimensions are stored as user units and converted to points on output
		if (pageFormats.hasOwnProperty(format_as_string)) {
			pageHeight = pageFormats[format_as_string][1] / k;
			pageWidth = pageFormats[format_as_string][0] / k;
		} else {
			try {
				pageHeight = format[1];
				pageWidth = format[0];
			} catch (err) {
				throw new Error('Invalid format: ' + format);
			}
		}

		if (orientation === 'p' || orientation === 'portrait') {
			orientation = 'p';
			if (pageWidth > pageHeight) {
				tmp = pageWidth;
				pageWidth = pageHeight;
				pageHeight = tmp;
			}
		} else if (orientation === 'l' || orientation === 'landscape') {
			orientation = 'l';
			if (pageHeight > pageWidth) {
				tmp = pageWidth;
				pageWidth = pageHeight;
				pageHeight = tmp;
			}
		} else {
			throw('Invalid orientation: ' + orientation);
		}

		//---------------------------------------
		// Public API

		/**
		 * Object exposing internal API to plugins
		 * @public
		 */
		API.internal = {
			'pdfEscape' : pdfEscape,
			'getStyle' : getStyle,
			/**
			 * Returns {FontObject} describing a particular font.
			 * @public
			 * @function
			 * @param fontName {String} (Optional) Font's family name
			 * @param fontStyle {String} (Optional) Font's style variation name (Example:"Italic")
			 * @returns {FontObject}
			 */
			'getFont' : function() {
				return fonts[getFont.apply(API, arguments)];
			},
			'getFontSize' : function() {
				return activeFontSize;
			},
			'getLineHeight' : function() {
				return activeFontSize * lineHeightProportion;
			},
			'write' : function(string1 /*, string2, string3, etc */) {
				out(arguments.length === 1 ? string1 : Array.prototype.join.call(arguments, ' '));
			},
			'getCoordinateString' : function(value) {
				return f2(value * k);
			},
			'getVerticalCoordinateString' : function(value) {
				return f2((pageHeight - value) * k);
			},
			'collections' : {},
			'newObject' : newObject,
			'putStream' : putStream,
			'events' : events,
			// ratio that you use in multiplication of a given "size" number to arrive to 'point'
			// units of measurement.
			// scaleFactor is set at initialization of the document and calculated against the stated
			// default measurement units for the document.
			// If default is "mm", k is the number that will turn number in 'mm' into 'points' number.
			// through multiplication.
			'scaleFactor' : k,
			'pageSize' : {
				'width' : pageWidth,
				'height' : pageHeight
			},
			'output' : function(type, options) {
				return output(type, options);
			},
			'getNumberOfPages' : function() {
				return pages.length - 1;
			},
			'pages' : pages
		};

		/**
		 * Adds (and transfers the focus to) new page to the PDF document.
		 * @function
		 * @returns {jsPDF}
		 *
		 * @methodOf jsPDF#
		 * @name addPage
		 */
		API.addPage = function() {
			_addPage();
			return this;
		};

		/**
		 * Adds text to page. Supports adding multiline text when 'text' argument is an Array of Strings.
		 *
		 * @function
		 * @param {String|Array} text String or array of strings to be added to the page. Each line is shifted one line down per font, spacing settings declared before this call.
		 * @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
		 * @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
		 * @param {Object} flags Collection of settings signalling how the text must be encoded. Defaults are sane. If you think you want to pass some flags, you likely can read the source.
		 * @returns {jsPDF}
		 * @methodOf jsPDF#
		 * @name text
		 */
		API.text = function(text, x, y, flags, angle) {
			/**
			 * Inserts something like this into PDF
			 *   BT
			 *    /F1 16 Tf  % Font name + size
			 *    16 TL % How many units down for next line in multiline text
			 *    0 g % color
			 *    28.35 813.54 Td % position
			 *    (line one) Tj
			 *    T* (line two) Tj
			 *    T* (line three) Tj
			 *   ET
			 */
			function ESC(s) {
				s = s.split("\t").join(Array(options.TabLen||9).join(" "));
				return pdfEscape(s, flags);
			}

			// Pre-August-2012 the order of arguments was function(x, y, text, flags)
			// in effort to make all calls have similar signature like
			//   function(data, coordinates... , miscellaneous)
			// this method had its args flipped.
			// code below allows backward compatibility with old arg order.
			if (typeof text === 'number') {
				tmp = y;
				y = x;
				x = text;
				text = tmp;
			}

			// If there are any newlines in text, we assume
			// the user wanted to print multiple lines, so break the
			// text up into an array.  If the text is already an array,
			// we assume the user knows what they are doing.
			if (typeof text === 'string' && text.match(/[\n\r]/)) {
				text = text.split(/\r\n|\r|\n/g);
			}
			if (typeof flags === 'number') {
				angle = flags;
				flags = null;
			}
			var xtra = '',mode = 'Td';
			if (angle) {
				angle *= (Math.PI / 180);
				var c = Math.cos(angle),
				s = Math.sin(angle);
				xtra = [f2(c), f2(s), f2(s * -1), f2(c), ''].join(" ");
				mode = 'Tm';
			}
			flags = flags || {};
			if (!('noBOM' in flags))
				flags.noBOM = true;
			if (!('autoencode' in flags))
				flags.autoencode = true;

			if (typeof text === 'string') {
				text = ESC(text);
			} else if (text instanceof Array) {
				// we don't want to destroy  original text array, so cloning it
				var sa = text.concat(), da = [], len = sa.length;
				// we do array.join('text that must not be PDFescaped")
				// thus, pdfEscape each component separately
				while (len--) {
					da.push(ESC(sa.shift()));
				}
				text = da.join(") Tj\nT* (");
			} else {
				throw new Error('Type of text must be string or Array. "' + text + '" is not recognized.');
			}
			// Using "'" ("go next line and render text" mark) would save space but would complicate our rendering code, templates

			// BT .. ET does NOT have default settings for Tf. You must state that explicitely every time for BT .. ET
			// if you want text transformation matrix (+ multiline) to work reliably (which reads sizes of things from font declarations)
			// Thus, there is NO useful, *reliable* concept of "default" font for a page.
			// The fact that "default" (reuse font used before) font worked before in basic cases is an accident
			// - readers dealing smartly with brokenness of jsPDF's markup.
			out(
				'BT\n/' +
				activeFontKey + ' ' + activeFontSize + ' Tf\n' +     // font face, style, size
				(activeFontSize * lineHeightProportion) + ' TL\n' +  // line spacing
				textColor +
				'\n' + xtra + f2(x * k) + ' ' + f2((pageHeight - y) * k) + ' ' + mode + '\n(' +
				text +
				') Tj\nET');
			return this;
		};

		API.line = function(x1, y1, x2, y2) {
			return this.lines([[x2 - x1, y2 - y1]], x1, y1);
		};

		/**
		 * Adds series of curves (straight lines or cubic bezier curves) to canvas, starting at `x`, `y` coordinates.
		 * All data points in `lines` are relative to last line origin.
		 * `x`, `y` become x1,y1 for first line / curve in the set.
		 * For lines you only need to specify [x2, y2] - (ending point) vector against x1, y1 starting point.
		 * For bezier curves you need to specify [x2,y2,x3,y3,x4,y4] - vectors to control points 1, 2, ending point. All vectors are against the start of the curve - x1,y1.
		 *
		 * @example .lines([[2,2],[-2,2],[1,1,2,2,3,3],[2,1]], 212,110, 10) // line, line, bezier curve, line
		 * @param {Array} lines Array of *vector* shifts as pairs (lines) or sextets (cubic bezier curves).
		 * @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
		 * @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
		 * @param {Number} scale (Defaults to [1.0,1.0]) x,y Scaling factor for all vectors. Elements can be any floating number Sub-one makes drawing smaller. Over-one grows the drawing. Negative flips the direction.
		 * @param {String} style A string specifying the painting style or null.  Valid styles include: 'S' [default] - stroke, 'F' - fill,  and 'DF' (or 'FD') -  fill then stroke. A null value postpones setting the style so that a shape may be composed using multiple method calls. The last drawing method call used to define the shape should not have a null style argument.
		 * @param {Boolean} closed If true, the path is closed with a straight line from the end of the last curve to the starting point.
		 * @function
		 * @returns {jsPDF}
		 * @methodOf jsPDF#
		 * @name lines
		 */
		API.lines = function(lines, x, y, scale, style, closed) {
			var scalex,scaley,i,l,leg,x2,y2,x3,y3,x4,y4;

			// Pre-August-2012 the order of arguments was function(x, y, lines, scale, style)
			// in effort to make all calls have similar signature like
			//   function(content, coordinateX, coordinateY , miscellaneous)
			// this method had its args flipped.
			// code below allows backward compatibility with old arg order.
			if (typeof lines === 'number') {
				tmp = y;
				y = x;
				x = lines;
				lines = tmp;
			}

			scale = scale || [1, 1];

			// starting point
			out(f3(x * k) + ' ' + f3((pageHeight - y) * k) + ' m ');

			scalex = scale[0];
			scaley = scale[1];
			l = lines.length;
			//, x2, y2 // bezier only. In page default measurement "units", *after* scaling
			//, x3, y3 // bezier only. In page default measurement "units", *after* scaling
			// ending point for all, lines and bezier. . In page default measurement "units", *after* scaling
			x4 = x; // last / ending point = starting point for first item.
			y4 = y; // last / ending point = starting point for first item.

			for (i = 0; i < l; i++) {
				leg = lines[i];
				if (leg.length === 2) {
					// simple line
					x4 = leg[0] * scalex + x4; // here last x4 was prior ending point
					y4 = leg[1] * scaley + y4; // here last y4 was prior ending point
					out(f3(x4 * k) + ' ' + f3((pageHeight - y4) * k) + ' l');
				} else {
					// bezier curve
					x2 = leg[0] * scalex + x4; // here last x4 is prior ending point
					y2 = leg[1] * scaley + y4; // here last y4 is prior ending point
					x3 = leg[2] * scalex + x4; // here last x4 is prior ending point
					y3 = leg[3] * scaley + y4; // here last y4 is prior ending point
					x4 = leg[4] * scalex + x4; // here last x4 was prior ending point
					y4 = leg[5] * scaley + y4; // here last y4 was prior ending point
					out(
						f3(x2 * k) + ' ' +
						f3((pageHeight - y2) * k) + ' ' +
						f3(x3 * k) + ' ' +
						f3((pageHeight - y3) * k) + ' ' +
						f3(x4 * k) + ' ' +
						f3((pageHeight - y4) * k) + ' c');
				}
			}

			if (closed) {
				out(' h');
			}

			// stroking / filling / both the path
			if (style !== null) {
				out(getStyle(style));
			}
			return this;
		};

		/**
		 * Adds a rectangle to PDF
		 *
		 * @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
		 * @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
		 * @param {Number} w Width (in units declared at inception of PDF document)
		 * @param {Number} h Height (in units declared at inception of PDF document)
		 * @param {String} style A string specifying the painting style or null.  Valid styles include: 'S' [default] - stroke, 'F' - fill,  and 'DF' (or 'FD') -  fill then stroke. A null value postpones setting the style so that a shape may be composed using multiple method calls. The last drawing method call used to define the shape should not have a null style argument.
		 * @function
		 * @returns {jsPDF}
		 * @methodOf jsPDF#
		 * @name rect
		 */
		API.rect = function(x, y, w, h, style) {
			var op = getStyle(style);
			out([
					f2(x * k),
					f2((pageHeight - y) * k),
					f2(w * k),
					f2(-h * k),
					're'
				].join(' '));

			if (style !== null) {
				out(getStyle(style));
			}

			return this;
		};

		/**
		 * Adds a triangle to PDF
		 *
		 * @param {Number} x1 Coordinate (in units declared at inception of PDF document) against left edge of the page
		 * @param {Number} y1 Coordinate (in units declared at inception of PDF document) against upper edge of the page
		 * @param {Number} x2 Coordinate (in units declared at inception of PDF document) against left edge of the page
		 * @param {Number} y2 Coordinate (in units declared at inception of PDF document) against upper edge of the page
		 * @param {Number} x3 Coordinate (in units declared at inception of PDF document) against left edge of the page
		 * @param {Number} y3 Coordinate (in units declared at inception of PDF document) against upper edge of the page
		 * @param {String} style A string specifying the painting style or null.  Valid styles include: 'S' [default] - stroke, 'F' - fill,  and 'DF' (or 'FD') -  fill then stroke. A null value postpones setting the style so that a shape may be composed using multiple method calls. The last drawing method call used to define the shape should not have a null style argument.
		 * @function
		 * @returns {jsPDF}
		 * @methodOf jsPDF#
		 * @name triangle
		 */
		API.triangle = function(x1, y1, x2, y2, x3, y3, style) {
			this.lines(
				[
					[x2 - x1, y2 - y1], // vector to point 2
					[x3 - x2, y3 - y2], // vector to point 3
					[x1 - x3, y1 - y3]// closing vector back to point 1
				],
				x1,
				y1, // start of path
				[1, 1],
				style,
				true);
			return this;
		};

		/**
		 * Adds a rectangle with rounded corners to PDF
		 *
		 * @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
		 * @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
		 * @param {Number} w Width (in units declared at inception of PDF document)
		 * @param {Number} h Height (in units declared at inception of PDF document)
		 * @param {Number} rx Radius along x axis (in units declared at inception of PDF document)
		 * @param {Number} rx Radius along y axis (in units declared at inception of PDF document)
		 * @param {String} style A string specifying the painting style or null.  Valid styles include: 'S' [default] - stroke, 'F' - fill,  and 'DF' (or 'FD') -  fill then stroke. A null value postpones setting the style so that a shape may be composed using multiple method calls. The last drawing method call used to define the shape should not have a null style argument.
		 * @function
		 * @returns {jsPDF}
		 * @methodOf jsPDF#
		 * @name roundedRect
		 */
		API.roundedRect = function(x, y, w, h, rx, ry, style) {
			var MyArc = 4 / 3 * (Math.SQRT2 - 1);
			this.lines(
				[
					[(w - 2 * rx), 0],
					[(rx * MyArc), 0, rx, ry - (ry * MyArc), rx, ry],
					[0, (h - 2 * ry)],
					[0, (ry * MyArc),  - (rx * MyArc), ry, -rx, ry],
					[(-w + 2 * rx), 0],
					[ - (rx * MyArc), 0, -rx,  - (ry * MyArc), -rx, -ry],
					[0, (-h + 2 * ry)],
					[0,  - (ry * MyArc), (rx * MyArc), -ry, rx, -ry]
				],
				x + rx,
				y, // start of path
				[1, 1],
				style);
			return this;
		};

		/**
		 * Adds an ellipse to PDF
		 *
		 * @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
		 * @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
		 * @param {Number} rx Radius along x axis (in units declared at inception of PDF document)
		 * @param {Number} rx Radius along y axis (in units declared at inception of PDF document)
		 * @param {String} style A string specifying the painting style or null.  Valid styles include: 'S' [default] - stroke, 'F' - fill,  and 'DF' (or 'FD') -  fill then stroke. A null value postpones setting the style so that a shape may be composed using multiple method calls. The last drawing method call used to define the shape should not have a null style argument.
		 * @function
		 * @returns {jsPDF}
		 * @methodOf jsPDF#
		 * @name ellipse
		 */
		API.ellipse = function(x, y, rx, ry, style) {
			var lx = 4 / 3 * (Math.SQRT2 - 1) * rx,
				ly = 4 / 3 * (Math.SQRT2 - 1) * ry;

			out([
					f2((x + rx) * k),
					f2((pageHeight - y) * k),
					'm',
					f2((x + rx) * k),
					f2((pageHeight - (y - ly)) * k),
					f2((x + lx) * k),
					f2((pageHeight - (y - ry)) * k),
					f2(x * k),
					f2((pageHeight - (y - ry)) * k),
					'c'
				].join(' '));
			out([
					f2((x - lx) * k),
					f2((pageHeight - (y - ry)) * k),
					f2((x - rx) * k),
					f2((pageHeight - (y - ly)) * k),
					f2((x - rx) * k),
					f2((pageHeight - y) * k),
					'c'
				].join(' '));
			out([
					f2((x - rx) * k),
					f2((pageHeight - (y + ly)) * k),
					f2((x - lx) * k),
					f2((pageHeight - (y + ry)) * k),
					f2(x * k),
					f2((pageHeight - (y + ry)) * k),
					'c'
				].join(' '));
			out([
					f2((x + lx) * k),
					f2((pageHeight - (y + ry)) * k),
					f2((x + rx) * k),
					f2((pageHeight - (y + ly)) * k),
					f2((x + rx) * k),
					f2((pageHeight - y) * k),
					'c'
				].join(' '));

			if (style !== null) {
				out(getStyle(style));
			}

			return this;
		};

		/**
		 * Adds an circle to PDF
		 *
		 * @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
		 * @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
		 * @param {Number} r Radius (in units declared at inception of PDF document)
		 * @param {String} style A string specifying the painting style or null.  Valid styles include: 'S' [default] - stroke, 'F' - fill,  and 'DF' (or 'FD') -  fill then stroke. A null value postpones setting the style so that a shape may be composed using multiple method calls. The last drawing method call used to define the shape should not have a null style argument.
		 * @function
		 * @returns {jsPDF}
		 * @methodOf jsPDF#
		 * @name circle
		 */
		API.circle = function(x, y, r, style) {
			return this.ellipse(x, y, r, r, style);
		};

		/**
		 * Adds a properties to the PDF document
		 *
		 * @param {Object} A property_name-to-property_value object structure.
		 * @function
		 * @returns {jsPDF}
		 * @methodOf jsPDF#
		 * @name setProperties
		 */
		API.setProperties = function(properties) {
			// copying only those properties we can render.
			for (var property in documentProperties) {
				if (documentProperties.hasOwnProperty(property) && properties[property]) {
					documentProperties[property] = properties[property];
				}
			}
			return this;
		};

		/**
		 * Sets font size for upcoming text elements.
		 *
		 * @param {Number} size Font size in points.
		 * @function
		 * @returns {jsPDF}
		 * @methodOf jsPDF#
		 * @name setFontSize
		 */
		API.setFontSize = function(size) {
			activeFontSize = size;
			return this;
		};

		/**
		 * Sets text font face, variant for upcoming text elements.
		 * See output of jsPDF.getFontList() for possible font names, styles.
		 *
		 * @param {String} fontName Font name or family. Example: "times"
		 * @param {String} fontStyle Font style or variant. Example: "italic"
		 * @function
		 * @returns {jsPDF}
		 * @methodOf jsPDF#
		 * @name setFont
		 */
		API.setFont = function(fontName, fontStyle) {
			activeFontKey = getFont(fontName, fontStyle);
			// if font is not found, the above line blows up and we never go further
			return this;
		};

		/**
		 * Switches font style or variant for upcoming text elements,
		 * while keeping the font face or family same.
		 * See output of jsPDF.getFontList() for possible font names, styles.
		 *
		 * @param {String} style Font style or variant. Example: "italic"
		 * @function
		 * @returns {jsPDF}
		 * @methodOf jsPDF#
		 * @name setFontStyle
		 */
		API.setFontStyle = API.setFontType = function(style) {
			activeFontKey = getFont(undefined, style);
			// if font is not found, the above line blows up and we never go further
			return this;
		};

		/**
		 * Returns an object - a tree of fontName to fontStyle relationships available to
		 * active PDF document.
		 *
		 * @public
		 * @function
		 * @returns {Object} Like {'times':['normal', 'italic', ... ], 'arial':['normal', 'bold', ... ], ... }
		 * @methodOf jsPDF#
		 * @name getFontList
		 */
		API.getFontList = function() {
			// TODO: iterate over fonts array or return copy of fontmap instead in case more are ever added.
			var list = {},fontName,fontStyle,tmp;

			for (fontName in fontmap) {
				if (fontmap.hasOwnProperty(fontName)) {
					list[fontName] = tmp = [];
					for (fontStyle in fontmap[fontName]) {
						if (fontmap[fontName].hasOwnProperty(fontStyle)) {
							tmp.push(fontStyle);
						}
					}
				}
			}

			return list;
		};

		/**
		 * Sets line width for upcoming lines.
		 *
		 * @param {Number} width Line width (in units declared at inception of PDF document)
		 * @function
		 * @returns {jsPDF}
		 * @methodOf jsPDF#
		 * @name setLineWidth
		 */
		API.setLineWidth = function(width) {
			out((width * k).toFixed(2) + ' w');
			return this;
		};

		/**
		 * Sets the stroke color for upcoming elements.
		 *
		 * Depending on the number of arguments given, Gray, RGB, or CMYK
		 * color space is implied.
		 *
		 * When only ch1 is given, "Gray" color space is implied and it
		 * must be a value in the range from 0.00 (solid black) to to 1.00 (white)
		 * if values are communicated as String types, or in range from 0 (black)
		 * to 255 (white) if communicated as Number type.
		 * The RGB-like 0-255 range is provided for backward compatibility.
		 *
		 * When only ch1,ch2,ch3 are given, "RGB" color space is implied and each
		 * value must be in the range from 0.00 (minimum intensity) to to 1.00
		 * (max intensity) if values are communicated as String types, or
		 * from 0 (min intensity) to to 255 (max intensity) if values are communicated
		 * as Number types.
		 * The RGB-like 0-255 range is provided for backward compatibility.
		 *
		 * When ch1,ch2,ch3,ch4 are given, "CMYK" color space is implied and each
		 * value must be a in the range from 0.00 (0% concentration) to to
		 * 1.00 (100% concentration)
		 *
		 * Because JavaScript treats fixed point numbers badly (rounds to
		 * floating point nearest to binary representation) it is highly advised to
		 * communicate the fractional numbers as String types, not JavaScript Number type.
		 *
		 * @param {Number|String} ch1 Color channel value
		 * @param {Number|String} ch2 Color channel value
		 * @param {Number|String} ch3 Color channel value
		 * @param {Number|String} ch4 Color channel value
		 *
		 * @function
		 * @returns {jsPDF}
		 * @methodOf jsPDF#
		 * @name setDrawColor
		 */
		API.setDrawColor = function(ch1, ch2, ch3, ch4) {
			var color;
			if (ch2 === undefined || (ch4 === undefined && ch1 === ch2 === ch3)) {
				// Gray color space.
				if (typeof ch1 === 'string') {
					color = ch1 + ' G';
				} else {
					color = f2(ch1 / 255) + ' G';
				}
			} else if (ch4 === undefined) {
				// RGB
				if (typeof ch1 === 'string') {
					color = [ch1, ch2, ch3, 'RG'].join(' ');
				} else {
					color = [f2(ch1 / 255), f2(ch2 / 255), f2(ch3 / 255), 'RG'].join(' ');
				}
			} else {
				// CMYK
				if (typeof ch1 === 'string') {
					color = [ch1, ch2, ch3, ch4, 'K'].join(' ');
				} else {
					color = [f2(ch1), f2(ch2), f2(ch3), f2(ch4), 'K'].join(' ');
				}
			}

			out(color);
			return this;
		};

		/**
		 * Sets the fill color for upcoming elements.
		 *
		 * Depending on the number of arguments given, Gray, RGB, or CMYK
		 * color space is implied.
		 *
		 * When only ch1 is given, "Gray" color space is implied and it
		 * must be a value in the range from 0.00 (solid black) to to 1.00 (white)
		 * if values are communicated as String types, or in range from 0 (black)
		 * to 255 (white) if communicated as Number type.
		 * The RGB-like 0-255 range is provided for backward compatibility.
		 *
		 * When only ch1,ch2,ch3 are given, "RGB" color space is implied and each
		 * value must be in the range from 0.00 (minimum intensity) to to 1.00
		 * (max intensity) if values are communicated as String types, or
		 * from 0 (min intensity) to to 255 (max intensity) if values are communicated
		 * as Number types.
		 * The RGB-like 0-255 range is provided for backward compatibility.
		 *
		 * When ch1,ch2,ch3,ch4 are given, "CMYK" color space is implied and each
		 * value must be a in the range from 0.00 (0% concentration) to to
		 * 1.00 (100% concentration)
		 *
		 * Because JavaScript treats fixed point numbers badly (rounds to
		 * floating point nearest to binary representation) it is highly advised to
		 * communicate the fractional numbers as String types, not JavaScript Number type.
		 *
		 * @param {Number|String} ch1 Color channel value
		 * @param {Number|String} ch2 Color channel value
		 * @param {Number|String} ch3 Color channel value
		 * @param {Number|String} ch4 Color channel value
		 *
		 * @function
		 * @returns {jsPDF}
		 * @methodOf jsPDF#
		 * @name setFillColor
		 */
		API.setFillColor = function(ch1, ch2, ch3, ch4) {
			var color;

			if (ch2 === undefined || (ch4 === undefined && ch1 === ch2 === ch3)) {
				// Gray color space.
				if (typeof ch1 === 'string') {
					color = ch1 + ' g';
				} else {
					color = f2(ch1 / 255) + ' g';
				}
			} else if (ch4 === undefined) {
				// RGB
				if (typeof ch1 === 'string') {
					color = [ch1, ch2, ch3, 'rg'].join(' ');
				} else {
					color = [f2(ch1 / 255), f2(ch2 / 255), f2(ch3 / 255), 'rg'].join(' ');
				}
			} else {
				// CMYK
				if (typeof ch1 === 'string') {
					color = [ch1, ch2, ch3, ch4, 'k'].join(' ');
				} else {
					color = [f2(ch1), f2(ch2), f2(ch3), f2(ch4), 'k'].join(' ');
				}
			}

			out(color);
			return this;
		};

		/**
		 * Sets the text color for upcoming elements.
		 * If only one, first argument is given,
		 * treats the value as gray-scale color value.
		 *
		 * @param {Number} r Red channel color value in range 0-255 or {String} r color value in hexadecimal, example: '#FFFFFF'
		 * @param {Number} g Green channel color value in range 0-255
		 * @param {Number} b Blue channel color value in range 0-255
		 * @function
		 * @returns {jsPDF}
		 * @methodOf jsPDF#
		 * @name setTextColor
		 */
		API.setTextColor = function(r, g, b) {
			if ((typeof r === 'string') && /^#[0-9A-Fa-f]{6}$/.test(r)) {
				var hex = parseInt(r.substr(1), 16);
				r = (hex >> 16) & 255;
				g = (hex >> 8) & 255;
				b = (hex & 255);
			}

			if ((r === 0 && g === 0 && b === 0) || (typeof g === 'undefined')) {
				textColor = f3(r / 255) + ' g';
			} else {
				textColor = [f3(r / 255), f3(g / 255), f3(b / 255), 'rg'].join(' ');
			}
			return this;
		};

		/**
		 * Is an Object providing a mapping from human-readable to
		 * integer flag values designating the varieties of line cap
		 * and join styles.
		 *
		 * @returns {Object}
		 * @fieldOf jsPDF#
		 * @name CapJoinStyles
		 */
		API.CapJoinStyles = {
			0 : 0,
			'butt' : 0,
			'but' : 0,
			'miter' : 0,
			1 : 1,
			'round' : 1,
			'rounded' : 1,
			'circle' : 1,
			2 : 2,
			'projecting' : 2,
			'project' : 2,
			'square' : 2,
			'bevel' : 2
		};

		/**
		 * Sets the line cap styles
		 * See {jsPDF.CapJoinStyles} for variants
		 *
		 * @param {String|Number} style A string or number identifying the type of line cap
		 * @function
		 * @returns {jsPDF}
		 * @methodOf jsPDF#
		 * @name setLineCap
		 */
		API.setLineCap = function(style) {
			var id = this.CapJoinStyles[style];
			if (id === undefined) {
				throw new Error("Line cap style of '" + style + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
			}
			lineCapID = id;
			out(id + ' J');

			return this;
		};

		/**
		 * Sets the line join styles
		 * See {jsPDF.CapJoinStyles} for variants
		 *
		 * @param {String|Number} style A string or number identifying the type of line join
		 * @function
		 * @returns {jsPDF}
		 * @methodOf jsPDF#
		 * @name setLineJoin
		 */
		API.setLineJoin = function(style) {
			var id = this.CapJoinStyles[style];
			if (id === undefined) {
				throw new Error("Line join style of '" + style + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
			}
			lineJoinID = id;
			out(id + ' j');

			return this;
		};

		// Output is both an internal (for plugins) and external function
		API.output = output;

		/**
		 * Saves as PDF document. An alias of jsPDF.output('save', 'filename.pdf')
		 * @param  {String} filename The filename including extension.
		 *
		 * @function
		 * @returns {jsPDF}
		 * @methodOf jsPDF#
		 * @name save
		 */
		API.save = function(filename) {
			API.output('save', filename);
		};

		// applying plugins (more methods) ON TOP of built-in API.
		// this is intentional as we allow plugins to override
		// built-ins
		for (var plugin in jsPDF.API) {
			if (jsPDF.API.hasOwnProperty(plugin)) {
				if (plugin === 'events' && jsPDF.API.events.length) {
					(function(events, newEvents) {

						// jsPDF.API.events is a JS Array of Arrays
						// where each Array is a pair of event name, handler
						// Events were added by plugins to the jsPDF instantiator.
						// These are always added to the new instance and some ran
						// during instantiation.
						var eventname,handler_and_args,i;

						for (i = newEvents.length - 1; i !== -1; i--) {
							// subscribe takes 3 args: 'topic', function, runonce_flag
							// if undefined, runonce is false.
							// users can attach callback directly,
							// or they can attach an array with [callback, runonce_flag]
							// that's what the "apply" magic is for below.
							eventname = newEvents[i][0];
							handler_and_args = newEvents[i][1];
							events.subscribe.apply(
								events,
								[eventname].concat(
									typeof handler_and_args === 'function' ?
										[handler_and_args] : handler_and_args));
						}
					}(events, jsPDF.API.events));
				} else {
					API[plugin] = jsPDF.API[plugin];
				}
			}
		}

		//////////////////////////////////////////////////////
		// continuing initialization of jsPDF Document object
		//////////////////////////////////////////////////////
		// Add the first page automatically
		addFonts();
		activeFontKey = 'F1';
		_addPage();

		events.publish('initialized');
		return API;
	}

	/**
	 * jsPDF.API is a STATIC property of jsPDF class.
	 * jsPDF.API is an object you can add methods and properties to.
	 * The methods / properties you add will show up in new jsPDF objects.
	 *
	 * One property is prepopulated. It is the 'events' Object. Plugin authors can add topics,
	 * callbacks to this object. These will be reassigned to all new instances of jsPDF.
	 * Examples:
	 * jsPDF.API.events['initialized'] = function(){ 'this' is API object }
	 * jsPDF.API.events['addFont'] = function(added_font_object){ 'this' is API object }
	 *
	 * @static
	 * @public
	 * @memberOf jsPDF
	 * @name API
	 *
	 * @example
	 * jsPDF.API.mymethod = function(){
	 *   // 'this' will be ref to internal API object. see jsPDF source
	 *   // , so you can refer to built-in methods like so:
	 *   //     this.line(....)
	 *   //     this.text(....)
	 * }
	 * var pdfdoc = new jsPDF()
	 * pdfdoc.mymethod() // <- !!!!!!
	 */
	jsPDF.API = {events:[]};
	jsPDF.version = "1.0.0-trunk";

	if (typeof define === 'function' && define.amd) {
		define('jsPDF', function() {
			return jsPDF;
		});
	} else {
		global.jsPDF = jsPDF;
	}
	return jsPDF;
}(typeof self !== "undefined" && self || typeof window !== "undefined" && window || this));

L.D3geoJSON = L.Class.extend({
    includes: L.Mixin.Events,
    initialize: function(data, options) {


        var area = 1;
        this._simplify = d3.geo.transform({
            point: function(x, y, z) {
                if (z >= area)
                    this.stream.point(x, y);
            }
        });



        this._path = d3.geo.path()
                .projection(this._simplify)
                .context(this._context);





        this.data = data;
        this.options = options;
        var that = this;
        this._clickHandler = function(data, idx) {
            that.fire('click', {
                element: this,
                data: data,
                originalEvent: d3.event
            });
        };
        this._mouseOverHandler = function(data, idx) {
            that.fire('mouseover', {
                element: this,
                data: data,
                originalEvent: d3.event
            });
        };
        this._mouseMoveHandler = function(data, idx) {
            that.fire('mousemove', {
                element: this,
                data: data,
                originalEvent: d3.event
            });
        };
        this._mouseOutHandler = function(data, idx) {
            that.fire('mouseout', {
                element: this,
                data: data,
                originalEvent: d3.event
            });
        };
    },
    onAdd: function(map) {
        this._map = map;
        this._first = true;
        this._initZoomLvl = map._zoom;
        this._canvas = d3.select(this._map.getPanes().overlayPane).append("canvas");
        this._context = this._canvas.node().getContext("2d");

//    this._svg = d3.select(this._map.getPanes().overlayPane).append('svg');
//    this._svg.attr('pointer-events', 'none');
        this._group = this._svg.append('g');
        this._group.attr('class', 'leaflet-zoom-hide ' + (this.options.className || ''));
        if (this.options.id) {
            this._canvas.attr('id', this.options.id);
        }

        function latLngToPoint(latlng) {
            return map.project(latlng)._subtract(map.getPixelOrigin());
        }
        ;

        var t = d3.geo.transform({
            point: function(x, y) {
                var point = latLngToPoint(new L.LatLng(y, x));
                return this.stream.point(point.x, point.y);
            }
        });

        this.path = d3.geo.path().projection(t);

        this._feature = this._group.selectAll('path')
                .data(this.data.features)
                .enter()
                .append('path')
                .on('click', this._clickHandler)
                .on('mouseover', this._mouseOverHandler)
                .on('mousemove', this._mouseMoveHandler)
                .on('mouseout', this._mouseOutHandler);

        this._map.on('viewreset', this.reset, this);
        this._feature.attr('pointer-events', this.options.pointerEvents || 'visible');

        if (this.options.featureAttributes) {
            for (var i in this.options.featureAttributes) {
                this._feature.attr(i, this.options.featureAttributes[i]);
            }
        }

        this.reset();

    },
    onRemove: function(map) {
        this._svg.remove();
        this._map.off('viewreset', this.reset, this);
    },
    reset: function(e) {
        if (!this._bounds) {
            this._bounds = d3.geo.path().projection(null).bounds(this.data);
        }
        var topLeft = this._map.latLngToLayerPoint([this._bounds[0][1], this._bounds[0][0]]),
                bottomRight = this._map.latLngToLayerPoint([this._bounds[1][1], this._bounds[1][0]]);

        this._svg
                .attr('width', bottomRight.x - topLeft.x)
                .attr('height', topLeft.y - bottomRight.y)
                .style('left', topLeft.x + 'px')
                .style('top', bottomRight.y + 'px');

        if (this._first) {

            this._group.attr('transform', 'translate(' + -topLeft.x + ',' + -bottomRight.y + ')');
            this._feature.attr('d', this.path);
            this._initTopLeft = topLeft;
            this._initBottomRight = bottomRight;
            this._first = false;

        } else {

            var trans = d3.transform(this._group.attr('transform')),
                    oldScale = trans.scale;
            trans.scale = [oldScale[0] * ((bottomRight.x - topLeft.x) / (this._oldBottomRight.x - this._oldTopLeft.x)),
                oldScale[1] * ((topLeft.y - bottomRight.y) / (this._oldTopLeft.y - this._oldBottomRight.y))
            ];
            trans.translate = [-this._initTopLeft.x, -this._initBottomRight.y];
            this._group.attr('transform', 'scale(' + trans.scale[0] + ',' + trans.scale[1] + ')translate(' + trans.translate[0] + ',' + trans.translate[1] + ')');

        }

        this._oldTopLeft = topLeft;
        this._oldBottomRight = bottomRight;
        this._svg.attr('class', 'zoom-' + this._map.getZoom());

    },
    addTo: function(map) {
        map.addLayer(this);
        return this;
    },
    resimplify: function() {
        var t = d3.select(this);
        (function repeat() {
            t = t.transition()
                    .tween("area", areaTween(20))
                    .transition()
                    .tween("area", areaTween(.5))
                    .each("end", repeat);
        })();
    },
    areaTween: function(area1) {
        return function(d) {
            var i = d3.interpolate(area, area1);
            return function(t) {
                area = i(t);
                render();
            };
        };
    }
});


//
//var width = 960,
//    height = 500;
//
//var area = 1, simplify = d3.geo.transform({
//  point: function(x, y, z) {
//    if (z >= area) this.stream.point(x, y);
//  }
//});
//
//var canvas = d3.select("body").append("canvas")
//    .attr("width", width)
//    .attr("height", height);
//
//var context = canvas.node().getContext("2d");
//
//var path = d3.geo.path()
//    .projection(simplify)
//    .context(context);
//
//d3.json("us.json", function(error, topo) {
//  canvas
//      .datum(topojson.mesh(topojson.presimplify(topo)))
//    .transition()
//      .duration(2500)
//      .each(resimplify);
//});
//
//function render() {
//  context.clearRect(0, 0, width, height);
//  context.beginPath();
//  canvas.each(path);
//  context.stroke();
//}
//
//function resimplify() {
//  var t = d3.select(this);
//  (function repeat() {
//    t = t.transition()
//        .tween("area", areaTween(20))
//      .transition()
//        .tween("area", areaTween(.5))
//        .each("end", repeat);
//  })();
//}
//
//function areaTween(area1) {
//  return function(d) {
//    var i = d3.interpolate(area, area1);
//    return function(t) {
//      area = i(t);
//      render();
//    };
//  };
//}



/*
 * Google layer using Google Maps API
 */

L.Google = L.Class.extend({
	includes: L.Mixin.Events,

	options: {
		minZoom: 0,
		maxZoom: 18,
		tileSize: 256,
		subdomains: 'abc',
		errorTileUrl: '',
		attribution: '',
		opacity: 1,
		continuousWorld: false,
		noWrap: false
	},

	// Possible types: SATELLITE, ROADMAP, HYBRID, TERRAIN
	initialize: function(type, options) {
		L.Util.setOptions(this, options);

		this._ready = google.maps.Map != undefined;
		if (!this._ready) L.Google.asyncWait.push(this);

		this._type = type || 'SATELLITE';
	},

	onAdd: function(map, insertAtTheBottom) {
		this._map = map;
		this._insertAtTheBottom = insertAtTheBottom;

		// create a container div for tiles
		this._initContainer();
		this._initMapObject();

		// set up events
		map.on('viewreset', this._resetCallback, this);

		this._limitedUpdate = L.Util.limitExecByInterval(this._update, 150, this);
		map.on('move', this._update, this);
		//map.on('moveend', this._update, this);

		map._controlCorners['bottomright'].style.marginBottom = "1em";

		this._reset();
		this._update();
	},

	onRemove: function(map) {
		this._map._container.removeChild(this._container);
		//this._container = null;

		this._map.off('viewreset', this._resetCallback, this);

		this._map.off('move', this._update, this);
		map._controlCorners['bottomright'].style.marginBottom = "0em";
		//this._map.off('moveend', this._update, this);
	},

	getAttribution: function() {
		return this.options.attribution;
	},

	setOpacity: function(opacity) {
		this.options.opacity = opacity;
		if (opacity < 1) {
			L.DomUtil.setOpacity(this._container, opacity);
		}
	},

	setElementSize: function(e, size) {
		e.style.width = size.x + "px";
		e.style.height = size.y + "px";
	},

	_initContainer: function() {
		var tilePane = this._map._container,
			first = tilePane.firstChild;

		if (!this._container) {
			this._container = L.DomUtil.create('div', 'leaflet-google-layer leaflet-top leaflet-left');
			this._container.id = "_GMapContainer_" + L.Util.stamp(this);
			this._container.style.zIndex = "auto";
		}

		if (true) {
			tilePane.insertBefore(this._container, first);

			this.setOpacity(this.options.opacity);
			this.setElementSize(this._container, this._map.getSize());
		}
	},

	_initMapObject: function() {
		if (!this._ready) return;
		this._google_center = new google.maps.LatLng(0, 0);
		var map = new google.maps.Map(this._container, {
		    center: this._google_center,
		    zoom: 0,
		    tilt: 0,
		    mapTypeId: google.maps.MapTypeId[this._type],
		    disableDefaultUI: true,
		    keyboardShortcuts: false,
		    draggable: false,
		    disableDoubleClickZoom: true,
		    scrollwheel: false,
		    streetViewControl: false
		});

		var _this = this;
		this._reposition = google.maps.event.addListenerOnce(map, "center_changed",
			function() { _this.onReposition(); });

		map.backgroundColor = '#ff0000';
		this._google = map;
	},

	_resetCallback: function(e) {
		this._reset(e.hard);
	},

	_reset: function(clearOldContainer) {
		this._initContainer();
	},

	_update: function() {
		if (!this._google) return;
		this._resize();

		var bounds = this._map.getBounds();
		var ne = bounds.getNorthEast();
		var sw = bounds.getSouthWest();
		var google_bounds = new google.maps.LatLngBounds(
			new google.maps.LatLng(sw.lat, sw.lng),
			new google.maps.LatLng(ne.lat, ne.lng)
		);
		var center = this._map.getCenter();
		var _center = new google.maps.LatLng(center.lat, center.lng);

		this._google.setCenter(_center);
		this._google.setZoom(this._map.getZoom());
		//this._google.fitBounds(google_bounds);
	},

	_resize: function() {
		var size = this._map.getSize();
		if (this._container.style.width == size.x &&
		    this._container.style.height == size.y)
			return;
		this.setElementSize(this._container, size);
		this.onReposition();
	},

	onReposition: function() {
		if (!this._google) return;
		google.maps.event.trigger(this._google, "resize");
	}
});

L.Google.asyncWait = [];
L.Google.asyncInitialize = function() {
	var i;
	for (i = 0; i < L.Google.asyncWait.length; i++) {
		var o = L.Google.asyncWait[i];
		o._ready = true;
		if (o._container) {
			o._initMapObject();
			o._update();
		}
	}
	L.Google.asyncWait = [];
}



/*
 * Leaflet Heatmap Overlay
 *
 * Copyright (c) 2014, Patrick Wied (http://www.patrick-wied.at)
 * Dual-licensed under the MIT (http://www.opensource.org/licenses/mit-license.php)
 * and the Beerware (http://en.wikipedia.org/wiki/Beerware) license.
 */

var HeatmapOverlay = L.Class.extend({
    initialize: function(config) {
        this.cfg = config;
        this._el = L.DomUtil.create('div', 'leaflet-zoom-hide heatmap');
        this._data = [];
        this._max = 1;
        this._min = 0;
        this.cfg.container = this._el;
    },
    onAdd: function(map) {
        var size = map.getSize();

        this._map = map;

        this._width = size.x;
        this._height = size.y;

        this._el.style.width = size.x + 'px';
        this._el.style.height = size.y + 'px';

        this._resetOrigin();

        map.getPanes().overlayPane.appendChild(this._el);

        if (!this._heatmap) {
            this._heatmap = h337.create(this.cfg);
        }

        // on zoom, reset origin
        map.on('viewreset', this._resetOrigin, this);
            // on zoom, reset origin
 
        // redraw whenever dragend
        map.on('dragend', this._draw, this);

        this._draw();
    },
    onRemove: function(map) {
        // remove layer's DOM elements and listeners
        map.getPanes().overlayPane.removeChild(this._el);

        map.off('viewreset', this._resetOrigin, this);
        map.off('dragend', this._draw, this);
    },
    _draw: function() {
        if (!this._map) {
            return;
        }



        var point = this._map.latLngToContainerPoint(this._origin);

        // reposition the layer
        this._el.style[HeatmapOverlay.CSS_TRANSFORM] = 'translate(' +
                -Math.round(point.x) + 'px,' +
                -Math.round(point.y) + 'px)';

        this._update();
    },
    _update: function() {
        var bounds, zoom, scale;

        bounds = this._map.getBounds();
        zoom = this._map.getZoom();
        scale = Math.pow(2, zoom);

        if (this._data.length == 0) {
            return;
        }

        var generatedData = {max: this._max, min: this._min};
        var latLngPoints = [];
        var radiusMultiplier = this.cfg.scaleRadius ? scale : 1;
        var localMax = 0;
        var localMin = 0;
        var valueField = this.cfg.valueField;
        var len = this._data.length;

        while (len--) {
            var entry = this._data[len];
            var value = entry[valueField];
            var latlng = entry.latlng;


            // we don't wanna render points that are not even on the map ;-)
            if (!bounds.contains(latlng)&&this.cfg.useLocalExtrema) {
                continue;
            }
            // local max is the maximum within current bounds
            localMax = Math.max(value, localMax);
            localMin = Math.min(value, localMin);

            var point = this._map.latLngToContainerPoint(latlng);
            var latlngPoint = {x: Math.round(point.x), y: Math.round(point.y)};
            latlngPoint[valueField] = value;

            var radius;

            if (entry.radius) {
                radius = entry.radius * radiusMultiplier;
            } else {
                radius = (this.cfg.radius || 2) * radiusMultiplier;
            }
            latlngPoint.radius = radius;
            latLngPoints.push(latlngPoint);
        }
        if (this.cfg.useLocalExtrema) {
            generatedData.max = localMax;
            generatedData.min = localMin;
        }

        generatedData.data = latLngPoints;

        this._heatmap.setData(generatedData);
    },
    updateRadius:function (newradius) {
        this.cfg.radius = newradius;

        var data = this._data;
        var min = data.min;
        var max = data.max;
        var clonedArray = $.map(data, function (obj) {

            return  {lat: obj.latlng.lat, lng: obj.latlng.lng, count: obj['count'], radius: newradius};
        });
        
        this.setData({min: min, max: max, data: clonedArray});
    },
    setData: function(data) {
        this._max = data.max || this._max;
        this._min = data.min || this._min;
        var latField = this.cfg.latField || 'lat';
        var lngField = this.cfg.lngField || 'lng';
        var valueField = this.cfg.valueField || 'value';

        // transform data to latlngs
        var data = data.data;
        var len = data.length;
        var d = [];

        while (len--) {
            var entry = data[len];
            var latlng = new L.LatLng(entry[latField], entry[lngField]);
            var dataObj = {latlng: latlng};
            dataObj[valueField] = entry[valueField];
            if (entry.radius) {
                dataObj.radius = entry.radius;
            }
            d.push(dataObj);
        }
        this._data = d;

        this._draw();
    },
    // experimential... not ready.
    addData: function(pointOrArray) {
        if (pointOrArray.length > 0) {
            var len = pointOrArray.length;
            while (len--) {
                this.addData(pointOrArray[len]);
            }
        } else {
            var latField = this.cfg.latField || 'lat';
            var lngField = this.cfg.lngField || 'lng';
            var valueField = this.cfg.valueField || 'value';
            var entry = pointOrArray;
            var latlng = new L.LatLng(entry[latField], entry[lngField]);
            var dataObj = {latlng: latlng};

            dataObj[valueField] = entry[valueField];
            this._max = Math.max(this._max, dataObj[valueField]);
            this._min = Math.min(this._min, dataObj[valueField]);

            if (entry.radius) {
                dataObj.radius = entry.radius;
            }
            this._data.push(dataObj);
            this._draw();
        }
    },
    _resetOrigin: function() {
        this._origin = this._map.layerPointToLatLng(new L.Point(0, 0));
        this._draw();
    }
});

HeatmapOverlay.CSS_TRANSFORM = (function() {
    var div = document.createElement('div');
    var props = [
        'transform',
        'WebkitTransform',
        'MozTransform',
        'OTransform',
        'msTransform'
    ];

    for (var i = 0; i < props.length; i++) {
        var prop = props[i];
        if (div.style[prop] !== undefined) {
            return prop;
        }
    }

    return props[0];
})();
(function () {
    L.HistoryControl = L.Control.extend({
        options: {
            position: 'topright',
            maxMovesToSave: 0, //set to 0 for unlimited
            useExternalControls: false, //set to true to hide buttons on map and use your own. Can still use goBack, goForward, and allow this to take care of storing history.
            backImage: 'fa fa-caret-left',
            backText: '',
            backTooltip: 'Go to Previous Extent',
            backImageBeforeText: true,
            forwardImage: 'fa fa-caret-right',
            forwardText: '',
            forwardTooltip: 'Go to Next Extent',
            forwardImageBeforeText: false,
            orientation: 'horizontal',
            shouldSaveMoveInHistory: function(zoomCenter) { return true; } //by default save everything
        },
        initialize: function(options) {
            L.Util.setOptions(this, options);

            this._state.maxMovesToSave = this.options.maxMovesToSave;
        },
        onAdd: function(map) {
            this._map = map;

            var container = L.DomUtil.create('div', 'history-control leaflet-bar leaflet-control ' + this.options.orientation);
            if(!this.options.useExternalControls) {
                this._backButton = this._createButton('back', container, this.goBack, this);
                this._forwardButton = this._createButton('forward', container, this.goForward, this);
            }
            this._updateDisabled();
            this._addMapListeners();

            return container;
        },
        onRemove: function(map) {
            map.off('movestart');
        },
        performActionWithoutTriggeringEvent: function(action) {
            var ignoring = this._state.ignoringEvents;
            this._state.ignoringEvents = true;
            if($.isFunction(action)) {
                action();
            }
            this._state.ignoringEvents = ignoring;
        },
        moveWithoutTriggeringEvent: function(zoomCenter) {
            var _this = this;
            this.performActionWithoutTriggeringEvent(function() {
                _this._map.setView(zoomCenter.centerPoint, zoomCenter.zoom);
            });
        },
        goBack: function() {
            return this._invokeBackOrForward('historyback', this._state.history, this._state.future);
        },
        goForward: function() {
            return this._invokeBackOrForward('historyforward', this._state.future, this._state.history);
        },
        clearHistory: function() {
            this._state.history.items = [];
            this._updateDisabled();
        },
        clearFuture: function() {
            this._state.future.items = [];
            this._updateDisabled();
        },
        _map: null,
        _backButton: null,
        _forwardButton: null,
        _state: {
            backDisabled: null,
            forwardDisabled: null,
            ignoringEvents: false,
            maxMovesToSave: 0,
            history: {
                items: []
            },
            future: {
                items: []
            }
        },
        _createButton: function (name, container, action, _this) {
            var text = this.options[name + 'Text'] || '';
            var imageClass = this.options[name + 'Image'] || '';
            var tooltip = this.options[name + 'Tooltip'] || '';
            var button = L.DomUtil.create('a', 'history-' + name + '-button', container);
            if(imageClass) {
                var imageElement = '<i class="' + imageClass + '"></i>';
                if(this.options[name + 'ImageBeforeText']) {
                    text = imageElement + ' ' + text;
                }
                else {
                    text += ' ' + imageElement;
                }
            }
            button.innerHTML = text;
            button.href = '#';
            button.title = tooltip;

            var stop = L.DomEvent.stopPropagation;

            L.DomEvent
                .on(button, 'click', stop)
                .on(button, 'mousedown', stop)
                .on(button, 'dblclick', stop)
                .on(button, 'click', L.DomEvent.preventDefault)
                .on(button, 'click', action, _this)
                .on(button, 'click', this._refocusOnMap, _this);

            return button;
        },
        _updateDisabled: function () {
            var _this=this;
            var backDisabled = (this._state.history.items.length === 0);
            var forwardDisabled = (this._state.future.items.length === 0);
            if(backDisabled !== this._state.backDisabled) {
                this._state.backDisabled = backDisabled;
                _this._map.fire('historyback' + (backDisabled ? 'disabled' : 'enabled'));
            }
            if(forwardDisabled !== this._state.forwardDisabled) {
                this._state.forwardDisabled = forwardDisabled;
                _this._map.fire('historyforward' + (forwardDisabled ? 'disabled' : 'enabled'));
            }
            if(!this.options.useExternalControls) {
                this._setButtonDisabled(this._backButton, backDisabled);
                this._setButtonDisabled(this._forwardButton, forwardDisabled);
            }
        },
        _setButtonDisabled: function(button, condition) {
            var $button = $(button);
            var className = 'leaflet-disabled';
            if(condition) {
                $button.addClass(className);
            }
            else {
                $button.removeClass(className);
            }
        },
        _pop: function(stack) {
            stack = stack.items;
            if($.isArray(stack) && stack.length > 0) {
                return stack.splice(stack.length - 1, 1)[0];
            }
            return undefined;
        },
        _push: function(stack, value) {
            var maxLength = this._state.maxMovesToSave;
            stack = stack.items;
            if($.isArray(stack)) {
                stack.push(value);
                if(maxLength > 0 && stack.length > maxLength) {
                    stack.splice(0, 1);
                }
            }
        },
        _invokeBackOrForward: function(eventName, stackToPop, stackToPushCurrent) {
            var _this = this;
            var response = this._popStackAndUseLocation(stackToPop, stackToPushCurrent);
            if(response) {
                _this._map.fire(eventName, response);
                return true;
            }
            return false;
        },
        _popStackAndUseLocation : function(stackToPop, stackToPushCurrent) {
            //check if we can pop
            if($.isArray(stackToPop.items) && stackToPop.items.length > 0) {
                var current = this._buildZoomCenterObjectFromCurrent(this._map);
                //get most recent
                var previous =  this._pop(stackToPop);
                //save where we currently are in the 'other' stack
                this._push(stackToPushCurrent, current);
                this.moveWithoutTriggeringEvent(previous);

                return {
                    previousLocation: previous,
                    currentLocation: current
                };
            }
        },
        _buildZoomCenterObjectFromCurrent:function(map) {
            return new L.ZoomCenter(map.getZoom(), map.getCenter());
        },
        _addMapListeners: function() {
            var _this = this;
            this._map.on('movestart', function(e) {
                if(!_this._state.ignoringEvents) {
                    var current = _this._buildZoomCenterObjectFromCurrent(e.target);
                    if(_this.options.shouldSaveMoveInHistory(current)) {
                        _this._state.future.items = [];
                        _this._push(_this._state.history, current);
                    }
                }

                _this._updateDisabled();
            });
        }
    });
}());(function () {
    L.ZoomCenter = L.Class.extend({
        initialize: function(zoom, centerPoint) {
            this.zoom = zoom;
            this.centerPoint = centerPoint;
        }
    });
}());
//very much based off of http://bost.ocks.org/mike/leaflet/
L.D3 = L.Class.extend({
    includes: L.Mixin.Events,
    options: {
        type: "json",
        topojson: false,
        showLabels: false,
        name: 'shapefile',
        layerType: 'uploadfilelayer',
        pathClass: "path",
        keyname: 'ogc_id',
        labelClass: "feature-label"
    },
    initialize: function (data, options) {
        var _this = this;
        L.setOptions(_this, options);
        _this._loaded = false;
        if (typeof data === "string") {
            d3[_this.options.type](data, function (err, json) {
                if (err) {
                    return;
                } else {
                    if (_this.options.topojson) {
                        _this.data = topojson.feature(json, json.objects[_this.options.topojson]);
                    } else if (L.Util.isArray(json)) {
                        _this.data = {type: "FeatureCollection", features: json};
                    } else {
                        _this.data = json;
                    }
                    _this._featureType = data.features[0].geometry.type;
                    _this._loaded = true;
                    _this.fire("dataLoaded");
                }
            });
        } else {
            if (_this.options.topojson) {
                _this.data = topojson.feature(data, data.objects[_this.options.topojson]);
            } else if (L.Util.isArray(data)) {
                _this.data = {type: "FeatureCollection", features: data};
            } else {
                _this.data = data;
            }
            _this._featureType = data.features[0].geometry.type;

            _this._loaded = true;
            _this.fire("dataLoaded");
        }

        this._clickHandler = function (data, idx) {
            _this.fire('click', {
                element: this,
                data: data,
                originalEvent: d3.event
            });
        };
        this._mouseOverHandler = function (data, idx) {
            _this.fire('mouseover', {
                element: this,
                data: data,
                originalEvent: d3.event
            });
        };
        this._mouseMoveHandler = function (data, idx) {
            _this.fire('mousemove', {
                element: this,
                data: data,
                originalEvent: d3.event
            });
        };
        this._mouseOutHandler = function (data, idx) {
            _this.fire('mouseout', {
                element: this,
                data: data,
                originalEvent: d3.event
            });
        };
    },
    onAdd: function (map) {
        this._map = map;
        this._project = function (x) {
            var point = map.latLngToLayerPoint(new L.LatLng(x[1], x[0]));
            return [point.x, point.y];
        };
        this._initContainer();
        this._el = d3.select(this._container).append("svg");
        this._g = this._el.append("g").attr("class", this.options.svgClass ? this.options.svgClass + " leaflet-zoom-hide" : "leaflet-zoom-hide");
        if (this._loaded) {
            this.onLoaded();
        } else {
            this.on("dataLoaded", this.onLoaded, this);
        }
        this._popup = L.popup();
        this.fire("added");
    },
    addTo: function (map) {
        map.addLayer(this);
        return this;
    },
    showFeatureLabels: function (keyname) {
        var _this = this;
        this._g.selectAll("text").remove();
        if (keyname === undefined && this.options.keyname === undefined) {
            keyname = 'ogc_id';
        } else if (keyname === undefined) {
            keyname = this.options.keyname;
        }
        this._feature_labels = this._g.selectAll("." + this.options.labelClass)
                .data(this.options.topojson ? this.data.geometries : this.data.features)
                .enter().append("text")
                .attr("class", this.options.labelClass)
                .attr("transform", function (d) {
                    var point = _this.path.centroid(d);
                    return "translate(" + (point[0] + 8) + "," + point[1] + ")";
                })
                .attr("dy", ".35em")
                .text(function (d) {
                    if (d.properties[keyname] !== undefined)
                        return d.properties[keyname];
                    else
                        return 'N/A';
                });
    },
    removeFeatureLabels: function () {
        this._g.selectAll("text").remove();
    },
    onLoaded: function () {
        var _this = this;
        var corners = this._map.getBounds();
        // Extracting boundary points
        var northEast = corners.getNorthEast();
        var southWest = corners.getSouthWest();
        this.bounds = d3.geo.bounds(this.data);
        this.bounds = [[Math.min(southWest.lng, this.bounds[0][0]), Math.min(southWest.lat, this.bounds[0][1])], [Math.max(northEast.lng, this.bounds[1][0]), Math.max(northEast.lat, this.bounds[1][1])]];
        this.path = d3.geo.path().projection(this._project).pointRadius(8);
        this._symbols = {
            star: "diamond",
            circle: "circle",
            square: "square",
            cross: "cross",
            triangle: "triangle-up",
            diamond: "diamond"
        };
        if (this.options.before) {
            this.options.before.call(this, this.data);
        }


        this._feature = this._g.selectAll("path")
                .data(this.options.topojson ? this.data.geometries : this.data.features)
                .enter()
                .append("path")
                .attr("id", function (d) {
                    return d.properties['ogc_fid'];
                });

        if (this.options.sld === 'xxxxxxx') {
            var drawtext = false;
            var varFeatureTypeStyles = this.options.sld.FeatureTypeStyle;
            if (varFeatureTypeStyles) {

                var keys = Object.keys(varFeatureTypeStyles);
                for (var key in keys) {
                    var varFeatureTypeStyle = varFeatureTypeStyles[key];
                    if (typeof varFeatureTypeStyle === 'object' && varFeatureTypeStyle.Rule !== undefined) {
                        if (varFeatureTypeStyle.Rule.Filter !== undefined) {
                            var rule = varFeatureTypeStyle.Rule;
                            if (rule.Filter && rule.Filter.PropertyIsEqualTo && rule.TextSymbolizer && rule.TextSymbolizer.Label) {
                                this.options.showLabels = true;
                                if (drawtext === false) {
                                    this._feature_labels = this._g.selectAll("." + this.options.labelClass)
                                            .data(this.options.topojson ? this.data.geometries : this.data.features)
                                            .enter()
                                            .append("text")
//                                            .filter(function (d) {
//                                                return false;
//                                                //return d.properties[rule.Filter.PropertyIsEqualTo.PropertyName] === rule.Filter.PropertyIsEqualTo.Literal;
//                                            })
                                            .attr("class", this.options.labelClass)
                                            .attr("transform", function (d) {
                                                return "translate(" + _this.path.centroid(d) + ")";
                                            })
                                            .attr("dy", ".35em")
                                            .text(function (d) {
                                                return d.properties[rule.TextSymbolizer.Label.PropertyName];
                                            });
                                    drawtext = true;
                                }
                            }

                        }
                    }
                }
            }
        }
//        if (this.options.showLabels)
//        {
//            var data = this.options.topojson ? this.data.geometries : this.data.features;
//            var properties_key = Object.keys(data[0].properties).map(function(k) {
//                return  k;
//            });
//            this._feature_labels = this._g.selectAll("." + this.options.labelClass)
//                    .data(this.options.topojson ? this.data.geometries : this.data.features)
//                    .enter().append("text")
//                    .attr("class", this.options.labelClass)
//                    .attr("transform", function(d) {
//                        return "translate(" + _this.path.centroid(d) + ")";
//                    })
//                    .attr("dy", ".35em")
//                    .text(function(d) {
//                        if (d.properties[_this.options.label_field] !== undefined && _this.options.label_field !== 'ogc_id')
//                            return d.properties[_this.options.label_field];
//                        else if (properties_key.length > 1)
//                            return d.properties[properties_key[1]];
//                        else
//                            return d.properties[properties_key[0]];
//                    });
//        }
        this._feature.on('click', this._clickHandler)
                .on('mouseover', this._mouseOverHandler)
                .on('mousemove', this._mouseMoveHandler)
                .on('mouseout', this._mouseOutHandler);
        this._map.on('viewreset', this._reset, this);
        this._reset();
    },
    onRemove: function (map) {
        // remove layer's DOM elements and listeners
        this._el.remove();
        map.off('viewreset', this._reset, this);
    },
    _reset: function () {
        var _this = this;
        var corners = this._map.getBounds();
        // Extracting boundary points
        var northEast = corners.getNorthEast();
        var southWest = corners.getSouthWest();
        this.bounds = d3.geo.bounds(this.data);
        this.bounds = [[Math.min(southWest.lng, this.bounds[0][0]), Math.min(southWest.lat, this.bounds[0][1])], [Math.max(northEast.lng, this.bounds[1][0]), Math.max(northEast.lat, this.bounds[1][1])]];
        var bottomLeft = this._project(this.bounds[0]),
                topRight = this._project(this.bounds[1]);
        this._el.attr("width", topRight[0] - bottomLeft[0])
                .attr("height", bottomLeft[1] - topRight[1])
                .style("margin-left", bottomLeft[0] + "px")
                .style("margin-top", topRight[1] + "px");
        this._g.attr("transform", "translate(" + -bottomLeft[0] + "," + -topRight[1] + ")");
        if (_this._featureType === 'Point' && this._feature) {

            this.onLoadPointSLD();
        }
        else {
            if (this._feature) {

                if (this._feature && (this._featureType === 'LineString' || this._featureType === 'MultiLineString' || this._featureType === 'Polyline' || this._featureType === 'MultiPolyline')) {
                    this._feature
                            .attr("d", this.path)

                            .attr("fill", "none")
                            .attr("fill-opacity", 0.0);

                    this.onLoadPolylineSLD();
                }
                if (this._feature && (this._featureType === 'Polygon' || this._featureType === 'MultiPolygon')) {
                    this._feature.attr("d", this.path);

                    this.onLoadPolygonSLD();
                }
            }
        }

        if (this.options.thematicmap === true && this.options.thematicmap_rule) {
            this.renderThematicMap(this.options.thematicmap_rule);
        }

        if (this.options.showLabels && this._feature_labels)
        {
            this._feature_labels.attr("transform", function (d) {
                var point = _this.path.centroid(d);
                return "translate(" + (point[0] + 8) + "," + point[1] + ")";
            });
        }
    },
    bindPopup: function (content) {
        this._popup = L.popup();
        this._popupContent = content;
        if (this._map) {
            this._bindPopup();
        }
        this.on("added", function () {
            this._bindPopup();
        }, this);
    },
    bringToFront: function () {
        var pane = this._map._panes.overlayPane;
        if (this._container) {
            // pane.appendChild(this._container);
            this._setAutoZIndex(pane, Math.max);
        }

        return this;
    },
    bringToBack: function () {
        var pane = this._map._panes.overlayPane;
        if (this._container) {
            // pane.insertBefore(this._container, pane.firstChild);
            this._setAutoZIndex(pane, Math.min);
        }

        return this;
    },
    _updateZIndex: function () {
        if (this._container && this.options.zIndex !== undefined) {
            this._container.style.zIndex = this.options.zIndex;
        }
    },
    _setAutoZIndex: function (pane, compare) {

        var layers = pane.children,
                edgeZIndex = -compare(Infinity, -Infinity), // -Infinity for max, Infinity for min
                zIndex, i, len;
        for (i = 0, len = layers.length; i < len; i++) {

            if (layers[i] !== this._container) {
                if (!isNaN($(layers[i]).attr('zIndex')) && $(layers[i]).attr('zIndex') !== '')
                    layers[i].style.zIndex = $(layers[i]).attr('zIndex');
                zIndex = parseInt(layers[i].style.zIndex, 10);
                if (!isNaN(zIndex)) {
                    edgeZIndex = compare(edgeZIndex, zIndex);
                }
            }
        }

        this._container.style.zIndex =
                (isFinite(edgeZIndex) ? edgeZIndex : 0) + compare(1, -1);
        if (isNaN(this.options.zIndex) || this.options.zIndex === '')
        {
            this.options.zIndex = this._container.style.zIndex;
        }
    },
    _updateOpacity: function () {
        L.DomUtil.setOpacity(this._container, this.options.opacity);
        // stupid webkit hack to force redrawing of tiles
        var i,
                tiles = this._tiles;
        if (L.Browser.webkit) {
            for (i in tiles) {
                if (tiles.hasOwnProperty(i)) {
                    tiles[i].style.webkitTransform += ' translate(0,0)';
                }
            }
        }
    },
    _initContainer: function () {
        var overlayPane = this._map._panes.overlayPane;
        if (!this._container || overlayPane.empty) {
            this._container = L.DomUtil.create('div', 'leaflet-layer');
            var container = d3.select(this._container);
            if (container) {
                container.attr('id', this.options.id ? this.options.id : 'svg-leaflet-d3');
                container.attr('filetype', this.options.filetype ? this.options.filetype : 'svg-leaflet-d3');
                container.attr('layerId', this.options.layerId ? this.options.layerId : 0);
                container.attr('filename', this.options.filename ? this.options.filename : 'svg-data-filename');
                container.attr('zIndex', this.options.zIndex ? this.options.zIndex : '');
                container.attr('minZoom', this.options.minZoom ? this.options.minZoom : '');
                container.attr('maxZoom', this.options.maxZoom ? this.options.maxZoom : '');
                container.attr('layerType', this.options.layerType ? this.options.layerType : 'useruploadfile');
            }
            this._updateZIndex();
            overlayPane.appendChild(this._container);
            if (this.options.opacity < 1) {
                this._updateOpacity();
            }
        }
    },
    renderThematicMap: function (rule) {
        var ps = this._feature[0];
        var pNameExist = false;
        var propertyName = '';
        if (typeof rule.categories !== 'object')
            rule.categories = JSON.parse(rule.categories);
        if (ps.length > 0) {
            var p = d3.select(ps[0]);
            var properties = p[0][0].__data__.properties;
            for (var property in properties) {
                if (property.toLowerCase() === rule.fieldname.toLowerCase()) {
                    pNameExist = true;
                    propertyName = property;
                    break;
                }
            }
        }
        if (pNameExist === true) {
            for (var k = 0; k < ps.length; k++)
            {
                var p = d3.select(ps[k]);
                var properties = p[0][0].__data__.properties;
                for (var j = 0; j < rule.categories.length; j++) {
                    if (parseFloat(rule.categories[j].from) === parseFloat(rule.min))
                    {
                        if (parseFloat(properties[propertyName]) >= parseFloat(rule.categories[j].from) && parseFloat(properties[propertyName]) <= parseFloat(rule.categories[j].to)) {
                            p.style('fill', rule.categories[j].fill);
                            p.style('fill-opacity', rule.opacity);
                            p.style('stroke', rule.categories[j].boundary);
                            p.style('stroke-opacity', rule.opacity);
                            p.style('stroke-width', rule.width);
                        }

                    }
                    else {
                        if (parseFloat(properties[propertyName]) > parseFloat(rule.categories[j].from) && parseFloat(properties[propertyName]) <= parseFloat(rule.categories[j].to)) {
                            p.style('fill', rule.categories[j].fill);
                            p.style('fill-opacity', rule.opacity);
                            p.style('stroke', rule.categories[j].boundary);
                            p.style('stroke-opacity', rule.opacity);
                            p.style('stroke-width', rule.width);
                        }
                    }
                }
            }
        }
    },
    onLoadPointSLD: function () {

        var _this = this;
        if (_this.options.sld) {
            this._feature.attr("d", d3.svg.symbol().
                    type(function (d) {
                        var varFeatureTypeStyles = _this.options.sld.FeatureTypeStyle;
                        if (varFeatureTypeStyles === undefined || varFeatureTypeStyles === null)
                            return;
                        var keys = Object.keys(varFeatureTypeStyles);
                        for (var key in keys) {
                            var varFeatureTypeStyle = varFeatureTypeStyles[key];
                            if (typeof varFeatureTypeStyle === 'object' && varFeatureTypeStyle !== undefined && varFeatureTypeStyle.Rule !== undefined) {
                                var rule = varFeatureTypeStyle.Rule;
                                if (rule.Filter !== undefined) { // if there are conditions set
                                    if (rule.Filter.PropertyIsEqualTo) {
                                        if (d.properties[rule.Filter.PropertyIsEqualTo.PropertyName.toLowerCase()] !== undefined)
                                        {
                                            if (d.properties[rule.Filter.PropertyIsEqualTo.PropertyName.toLowerCase()] === rule.Filter.PropertyIsEqualTo.Literal)
                                            {

                                                var marktype = 'circle';
                                                if (rule.PointSymbolizer && rule.PointSymbolizer.Graphic && _this._symbols[rule.PointSymbolizer.Graphic.Mark.WellKnownName] !== undefined)
                                                    marktype = _this._symbols[rule.PointSymbolizer.Graphic.Mark.WellKnownName];
                                                return marktype;
                                            }
                                        }
                                    }
                                }
                                else { // if no condition set
                                    if (rule.PointSymbolizer && rule.PointSymbolizer.Graphic && rule.PointSymbolizer && rule.PointSymbolizer.Graphic && rule.PointSymbolizer.Graphic.Mark && rule.PointSymbolizer.Graphic.Mark.WellKnownName)
                                    {
                                        var marktype = 'circle';
                                        if (_this._symbols[rule.PointSymbolizer.Graphic.Mark.WellKnownName] !== undefined)
                                            marktype = _this._symbols[rule.PointSymbolizer.Graphic.Mark.WellKnownName];
                                        return marktype;
                                    }
                                }
                            }
                        }
                        return 'circle';
                    })
                    .size(function (d) {
                        var varFeatureTypeStyles = _this.options.sld.FeatureTypeStyle;
                        var keys = Object.keys(varFeatureTypeStyles);
                        for (var key in keys) {
                            var varFeatureTypeStyle = varFeatureTypeStyles[key];
                            if (typeof varFeatureTypeStyle === 'object' && varFeatureTypeStyle.Rule !== undefined && varFeatureTypeStyle !== undefined) {
                                var rule = varFeatureTypeStyle.Rule;
                                if (varFeatureTypeStyle.Rule.Filter !== undefined) { // if there are conditions set

                                    if (varFeatureTypeStyle.Rule.Filter.PropertyIsEqualTo) {
                                        if (d.properties[rule.Filter.PropertyIsEqualTo.PropertyName.toLowerCase()] !== undefined)
                                        {
                                            if (d.properties[rule.Filter.PropertyIsEqualTo.PropertyName.toLowerCase()] === rule.Filter.PropertyIsEqualTo.Literal)
                                            {
                                                var marksize = 6 * 6;
                                                if (rule.PointSymbolizer && rule.PointSymbolizer.Graphic && rule.PointSymbolizer.Graphic.Size && typeof rule.PointSymbolizer.Graphic.Size !== 'object')
                                                    marksize = rule.PointSymbolizer.Graphic.Size * rule.PointSymbolizer.Graphic.Size;
                                                else {
                                                    if (rule.PointSymbolizer && rule.PointSymbolizer.Graphic && rule.PointSymbolizer.Graphic.Size && rule.PointSymbolizer.Graphic.Size.Literal)
                                                        marksize = rule.PointSymbolizer.Graphic.Size.Literal * rule.PointSymbolizer.Graphic.Size.Literal;
                                                }
                                                return marksize;
                                            }
                                        }
                                    }
                                }
                                else { // if no condition set
                                    var marksize = 6 * 6;
                                    if (rule.PointSymbolizer && rule.PointSymbolizer.Graphic && rule.PointSymbolizer.Graphic.Size && typeof rule.PointSymbolizer.Graphic.Size !== 'object')
                                        marksize = rule.PointSymbolizer.Graphic.Size * rule.PointSymbolizer.Graphic.Size;
                                    else {
                                        if (rule.PointSymbolizer && rule.PointSymbolizer.Graphic && rule.PointSymbolizer.Graphic.Size && rule.PointSymbolizer.Graphic.Size.Literal)
                                            marksize = rule.PointSymbolizer.Graphic.Size.Literal * rule.PointSymbolizer.Graphic.Size.Literal;
                                    }
                                    return marksize;
                                }
                            }
                        }
                        return 8 * 8;
                    })
                    )
                    .style("fill", function (d) {
                        var varFeatureTypeStyles = _this.options.sld.FeatureTypeStyle;
                        var keys = Object.keys(varFeatureTypeStyles);
                        for (var key in keys) {
                            var varFeatureTypeStyle = varFeatureTypeStyles[key];
                            if (typeof varFeatureTypeStyle === 'object' && varFeatureTypeStyle.Rule !== undefined && varFeatureTypeStyle !== undefined) {
                                var rule = varFeatureTypeStyle.Rule;
                                if (varFeatureTypeStyle.Rule.Filter !== undefined) { // if there are conditions set

                                    if (varFeatureTypeStyle.Rule.Filter.PropertyIsEqualTo) {
                                        if (d.properties[rule.Filter.PropertyIsEqualTo.PropertyName.toLowerCase()] !== undefined)
                                        {
                                            if (d.properties[rule.Filter.PropertyIsEqualTo.PropertyName.toLowerCase()] === rule.Filter.PropertyIsEqualTo.Literal)
                                            {
                                                var fill_color = "#ccc";
                                                if (rule.PointSymbolizer && rule.PointSymbolizer.Graphic && rule.PointSymbolizer.Graphic.Mark && rule.PointSymbolizer.Graphic.Mark.Fill && rule.PointSymbolizer.Graphic.Mark.Fill.fill)
                                                    fill_color = rule.PointSymbolizer.Graphic.Mark.Fill.fill.trim();
                                                return fill_color;
                                            }
                                        }
                                    }
                                }
                                else { // if no condition set
                                    var fill_color = "#ccc";
                                    if (rule.PointSymbolizer && rule.PointSymbolizer.Graphic && rule.PointSymbolizer.Graphic.Mark && rule.PointSymbolizer.Graphic.Mark.Fill && rule.PointSymbolizer.Graphic.Mark.Fill.fill)
                                        fill_color = rule.PointSymbolizer.Graphic.Mark.Fill.fill.trim();
                                    return fill_color;
                                }
                            }
                        }
                        return "#ccc";
                    })
                    .style("fill-opacity", function (d) {
                        var varFeatureTypeStyles = _this.options.sld.FeatureTypeStyle;
                        var keys = Object.keys(varFeatureTypeStyles);
                        for (var key in keys) {
                            var varFeatureTypeStyle = varFeatureTypeStyles[key];
                            if (typeof varFeatureTypeStyle === 'object' && varFeatureTypeStyle.Rule !== undefined && varFeatureTypeStyle !== undefined) {
                                var rule = varFeatureTypeStyle.Rule;
                                if (varFeatureTypeStyle.Rule.Filter !== undefined) { // if there are conditions set

                                    if (varFeatureTypeStyle.Rule.Filter.PropertyIsEqualTo) {
                                        if (d.properties[rule.Filter.PropertyIsEqualTo.PropertyName.toLowerCase()] !== undefined)
                                        {
                                            if (d.properties[rule.Filter.PropertyIsEqualTo.PropertyName.toLowerCase()] === rule.Filter.PropertyIsEqualTo.Literal)
                                            {
                                                var fill_opacity = "0.8";
                                                if (rule.PointSymbolizer && rule.PointSymbolizer.Graphic && rule.PointSymbolizer.Graphic.Mark && rule.PointSymbolizer.Graphic.Mark.Fill && rule.PointSymbolizer.Graphic.Mark.Fill['fill-opacity'])
                                                    fill_opacity = rule.PointSymbolizer.Graphic.Mark.Fill['fill-opacity'];
                                                else {
                                                    if (rule.PointSymbolizer && rule.PointSymbolizer.Graphic && rule.PointSymbolizer.Graphic.Mark && rule.PointSymbolizer.Graphic.Opacity && rule.PointSymbolizer.Graphic.Opacity.Literal)
                                                        fill_opacity = rule.PointSymbolizer.Graphic.Opacity.Literal.trim();
                                                }
                                                return fill_opacity;
                                            }
                                        }
                                    }
                                }
                                else { // if no condition set
                                    var fill_opacity = "0.8";
                                    if (rule.PointSymbolizer && rule.PointSymbolizer.Graphic && rule.PointSymbolizer.Graphic.Mark && rule.PointSymbolizer.Graphic.Mark.Fill && rule.PointSymbolizer.Graphic.Mark.Fill['fill-opacity'])
                                        fill_opacity = rule.PointSymbolizer.Graphic.Mark.Fill['fill-opacity'].trim();
                                    else {
                                        if (rule.PointSymbolizer && rule.PointSymbolizer.Graphic && rule.PointSymbolizer.Graphic.Mark && rule.PointSymbolizer.Graphic.Opacity && rule.PointSymbolizer.Graphic.Opacity.Literal)
                                            fill_opacity = rule.PointSymbolizer.Graphic.Opacity.Literal.trim();
                                    }
                                    return fill_opacity;
                                }
                            }
                        }
                        return 0.8;
                    })
                    .style("stroke", function (d) {
                        var varFeatureTypeStyles = _this.options.sld.FeatureTypeStyle;
                        var keys = Object.keys(varFeatureTypeStyles);
                        for (var key in keys) {
                            var varFeatureTypeStyle = varFeatureTypeStyles[key];
                            if (typeof varFeatureTypeStyle === 'object' && varFeatureTypeStyle.Rule !== undefined && varFeatureTypeStyle !== undefined) {
                                var rule = varFeatureTypeStyle.Rule;
                                if (varFeatureTypeStyle.Rule.Filter !== undefined) { // if there are conditions set

                                    if (varFeatureTypeStyle.Rule.Filter.PropertyIsEqualTo) {
                                        if (d.properties[rule.Filter.PropertyIsEqualTo.PropertyName.toLowerCase()] !== undefined)
                                        {
                                            if (d.properties[rule.Filter.PropertyIsEqualTo.PropertyName.toLowerCase()] === rule.Filter.PropertyIsEqualTo.Literal)
                                            {
                                                var stroke = "#000";
                                                if (rule.PointSymbolizer && rule.PointSymbolizer.Graphic && rule.PointSymbolizer.Graphic.Mark && rule.PointSymbolizer.Graphic.Mark.Stroke && rule.PointSymbolizer.Graphic.Mark.Stroke.stroke)
                                                    stroke = rule.PointSymbolizer.Graphic.Mark.Stroke.stroke.trim();
                                                return stroke;
                                            }
                                        }
                                    }
                                }
                                else { // if no condition set
                                    var stroke = "#000";
                                    if (rule.PointSymbolizer && rule.PointSymbolizer.Graphic && rule.PointSymbolizer.Graphic.Mark && rule.PointSymbolizer.Graphic.Mark.Stroke && rule.PointSymbolizer.Graphic.Mark.Stroke.stroke)
                                        stroke = rule.PointSymbolizer.Graphic.Mark.Stroke.stroke.trim();
                                    return stroke;
                                }
                            }
                        }
                        return "#000";
                    })
                    .style("stroke-width", function (d) {
                        var varFeatureTypeStyles = _this.options.sld.FeatureTypeStyle;
                        var keys = Object.keys(varFeatureTypeStyles);
                        for (var key in keys) {
                            var varFeatureTypeStyle = varFeatureTypeStyles[key];
                            if (typeof varFeatureTypeStyle === 'object' && varFeatureTypeStyle.Rule !== undefined && varFeatureTypeStyle !== undefined) {
                                var rule = varFeatureTypeStyle.Rule;
                                if (varFeatureTypeStyle.Rule.Filter !== undefined) { // if there are conditions set

                                    if (varFeatureTypeStyle.Rule.Filter.PropertyIsEqualTo) {
                                        if (d.properties[rule.Filter.PropertyIsEqualTo.PropertyName.toLowerCase()] !== undefined)
                                        {
                                            if (d.properties[rule.Filter.PropertyIsEqualTo.PropertyName.toLowerCase()] === rule.Filter.PropertyIsEqualTo.Literal)
                                            {
                                                var stroke_width = 1.0;
                                                if (rule.PointSymbolizer && rule.PointSymbolizer.Graphic && rule.PointSymbolizer.Graphic.Mark && rule.PointSymbolizer.Graphic.Mark.Stroke && rule.PointSymbolizer.Graphic.Mark.Stroke['stroke-width'])
                                                    stroke_width = rule.PointSymbolizer.Graphic.Mark.Stroke['stroke-width'].trim();
                                                return stroke_width;
                                            }
                                        }
                                    }
                                }
                                else { // if no condition set
                                    var stroke_width = 1.0;
                                    if (rule.PointSymbolizer && rule.PointSymbolizer.Graphic && rule.PointSymbolizer.Graphic.Mark && rule.PointSymbolizer.Graphic.Mark.Stroke && rule.PointSymbolizer.Graphic.Mark.Stroke['stroke-width'])
                                        stroke_width = rule.PointSymbolizer.Graphic.Mark.Stroke['stroke-width'].trim();
                                    return stroke_width;
                                }
                            }
                        }
                        return 1.0;
                    })
                    .style("stroke-opacity", function (d) {
                        var varFeatureTypeStyles = _this.options.sld.FeatureTypeStyle;
                        var keys = Object.keys(varFeatureTypeStyles);
                        for (var key in keys) {
                            var varFeatureTypeStyle = varFeatureTypeStyles[key];
                            if (typeof varFeatureTypeStyle === 'object' && varFeatureTypeStyle.Rule !== undefined && varFeatureTypeStyle !== undefined) {
                                var rule = varFeatureTypeStyle.Rule;
                                if (varFeatureTypeStyle.Rule.Filter !== undefined) { // if there are conditions set

                                    if (varFeatureTypeStyle.Rule.Filter.PropertyIsEqualTo) {
                                        if (d.properties[rule.Filter.PropertyIsEqualTo.PropertyName.toLowerCase()] !== undefined)
                                        {
                                            if (d.properties[rule.Filter.PropertyIsEqualTo.PropertyName.toLowerCase()] === rule.Filter.PropertyIsEqualTo.Literal)
                                            {
                                                var stroke_opacity = 1.0;
                                                if (rule.PointSymbolizer && rule.PointSymbolizer.Graphic && rule.PointSymbolizer.Graphic.Mark && rule.PointSymbolizer.Graphic.Mark.Stroke && rule.PointSymbolizer.Graphic.Mark.Stroke['stroke-opacity'])
                                                    stroke_opacity = rule.PointSymbolizer.Graphic.Mark.Stroke['stroke-opacity'];
                                                else {
                                                    if (rule.PointSymbolizer && rule.PointSymbolizer.Graphic && rule.PointSymbolizer.Graphic.Mark && rule.PointSymbolizer.Graphic.Opacity && rule.PointSymbolizer.Graphic.Opacity.Literal)
                                                        stroke_opacity = rule.PointSymbolizer.Graphic.Opacity.Literal.trim();
                                                }
                                                return stroke_opacity;
                                            }
                                        }
                                    }
                                }
                                else { // if no condition set
                                    var stroke_opacity = 1.0;
                                    if (rule.PointSymbolizer && rule.PointSymbolizer.Graphic && rule.PointSymbolizer.Graphic.Mark && rule.PointSymbolizer.Graphic.Mark.Stroke && rule.PointSymbolizer.Graphic.Mark.Stroke['stroke-opacity'])
                                        stroke_opacity = rule.PointSymbolizer.Graphic.Mark.Stroke['stroke-opacity'];
                                    else {
                                        if (rule.PointSymbolizer && rule.PointSymbolizer.Graphic && rule.PointSymbolizer.Graphic.Mark && rule.PointSymbolizer.Graphic.Opacity && rule.PointSymbolizer.Graphic.Opacity.Literal)
                                            stroke_opacity = rule.PointSymbolizer.Graphic.Opacity.Literal.trim();
                                    }
                                    return stroke_opacity;
                                }
                            }
                        }
                        return 1.0;
                    })
                    .attr("transform", function (d) {
                        return "translate(" + _this.path.centroid(d) + ")";
                    });
        }
        else
        {
            this._feature.attr("d", d3.svg.symbol()
                    .type('circle')
                    .size('64'))
                    .style("fill-opacity", '0.0')
                    .style("stroke", '#000')
                    .style("stroke-width", '1.0')
                    .style("stroke-opacity", '1.0')
                    .attr("transform", function (d) {
                        return "translate(" + _this.path.centroid(d) + ")";
                    });
        }

    },
    onLoadPolygonSLD: function () {
        var _this = this;
        if (_this.options.sld) {
            var varFeatureTypeStyles = _this.options.sld.FeatureTypeStyle;
            var keys = Object.keys(varFeatureTypeStyles);
            for (var key in keys) {
                var varFeatureTypeStyle = varFeatureTypeStyles[key];
                if (varFeatureTypeStyle !== undefined && typeof varFeatureTypeStyle === 'object' && varFeatureTypeStyle.Rule !== undefined) {
                    if (varFeatureTypeStyle.Rule.Filter !== undefined) {
                        var rule = varFeatureTypeStyle.Rule;
                        var ps = this._feature[0];
                        var pNameExist = false;
                        var propertyName = '';
                        if (varFeatureTypeStyle.Rule.Filter.PropertyIsEqualTo) {

                            if (ps.length > 0) {
                                var p = d3.select(ps[0]);
                                var properties = p[0][0].__data__.properties;
                                for (var property in properties) {
                                    if (property.toLowerCase() === rule.Filter.PropertyIsEqualTo.PropertyName.toLowerCase()) {
                                        pNameExist = true;
                                        propertyName = property;
                                        break;
                                    }
                                }

                            }
                            if (pNameExist === true) {
                                for (var k = 0; k < ps.length; k++)
                                {
                                    var p = d3.select(ps[k]);
                                    var properties = p[0][0].__data__.properties;
                                    if (properties[propertyName] && properties[propertyName].toLowerCase() === rule.Filter.PropertyIsEqualTo.Literal.toLowerCase()) {
                                        p = this.setFeatureStyle(p, varFeatureTypeStyle.Rule);
                                    }
                                }
                            }
                        }
                        else if (varFeatureTypeStyle.Rule.Filter.PropertyIsBetween) {
                            if (ps.length > 0) {
                                var p = d3.select(ps[0]);
                                var properties = p[0][0].__data__.properties;
                                for (var property in properties) {
                                    if (property.toLowerCase() === rule.Filter.PropertyIsBetween.PropertyName.toLowerCase()) {
                                        pNameExist = true;
                                        propertyName = property;
                                        break;
                                    }
                                }

                            }
                            if (pNameExist === true) {
                                for (var k = 0; k < ps.length; k++)
                                {
                                    var p = d3.select(ps[k]);
                                    var properties = p[0][0].__data__.properties;
                                    if (properties[propertyName] && (varFeatureTypeStyle.Rule.Filter.PropertyIsBetween.LowerBoundary === undefined) && (varFeatureTypeStyle.Rule.Filter.PropertyIsBetween.UpperBoundary !== undefined) && parseFloat(properties[propertyName]) <= parseFloat(varFeatureTypeStyle.Rule.Filter.PropertyIsBetween.UpperBoundary.Literal))
                                    {
                                        p = this.setFeatureStyle(p, varFeatureTypeStyle.Rule);
                                    }
                                    if (properties[propertyName] && (varFeatureTypeStyle.Rule.Filter.PropertyIsBetween.LowerBoundary !== undefined) && (varFeatureTypeStyle.Rule.Filter.PropertyIsBetween.UpperBoundary !== undefined) && parseFloat(properties[propertyName]) > parseFloat(varFeatureTypeStyle.Rule.Filter.PropertyIsBetween.LowerBoundary.Literal) && parseFloat(properties[propertyName]) <= parseFloat(varFeatureTypeStyle.Rule.Filter.PropertyIsBetween.UpperBoundary.Literal)) {
                                        p = this.setFeatureStyle(p, varFeatureTypeStyle.Rule);
                                    }
                                    if (properties[propertyName] && (varFeatureTypeStyle.Rule.Filter.PropertyIsBetween.LowerBoundary !== undefined) && (varFeatureTypeStyle.Rule.Filter.PropertyIsBetween.UpperBoundary === undefined) && parseFloat(properties[propertyName]) > parseFloat(varFeatureTypeStyle.Rule.Filter.PropertyIsBetween.LowerBoundary.Literal))
                                    {
                                        p = this.setFeatureStyle(p, varFeatureTypeStyle.Rule);
                                    }

                                }
                            }

                        }
                        else {
                            this._feature = this.setFeatureStyle(this._feature, varFeatureTypeStyle.Rule);
                        }
                    }
                    else {
                        this._feature = this.setFeatureStyle(this._feature, varFeatureTypeStyle.Rule);
                    }
                }
            }


        }
        else {

            this._feature.style('fill', "#CCC");
            this._feature.style('fill-opacity', "0.6");
            this._feature.style('stroke-opacity', "1.0");
            this._feature.style('stroke-width', "2");
            this._feature.style('stroke', "#0ff");
        }
    },
    onLoadPolylineSLD: function () {


        var _this = this;
        if (_this.options.sld) {


            var varFeatureTypeStyles = _this.options.sld.FeatureTypeStyle;
            var keys = Object.keys(varFeatureTypeStyles);
            for (var key in keys) {
                var varFeatureTypeStyle = varFeatureTypeStyles[key];
                if (varFeatureTypeStyle !== undefined && typeof varFeatureTypeStyle === 'object' && varFeatureTypeStyle.Rule !== undefined) {
                    if (varFeatureTypeStyle.Rule.Filter !== undefined) {
                        var rule = varFeatureTypeStyle.Rule;
                        var ps = _this._feature[0];
                        var pNameExist = false;
                        var propertyName = '';
                        if (varFeatureTypeStyle.Rule.Filter.PropertyIsEqualTo) {

                            if (ps.length > 0) {
                                if (ps[0]) {
                                    var p = d3.select(ps[0]);
                                    var properties = p[0][0].__data__.properties;
                                    for (var property in properties) {
                                        if (property.toLowerCase() === rule.Filter.PropertyIsEqualTo.PropertyName.toLowerCase()) {
                                            pNameExist = true;
                                            propertyName = property;
                                            break;
                                        }
                                    }
                                }
                            }
                            if (pNameExist === true) {
                                for (var k = 0; k < ps.length; k++)
                                {
                                    if (ps[k]) {
                                        var p = d3.select(ps[k]);
                                        var properties = p[0][0].__data__.properties;
                                        if (properties[propertyName] && rule.Filter.PropertyIsEqualTo.Literal !== undefined && rule.Filter.PropertyIsEqualTo.Literal !== null && properties[propertyName].toLowerCase() === rule.Filter.PropertyIsEqualTo.Literal.toLowerCase()) {

                                            p = _this.setFeatureStyle(p, varFeatureTypeStyle.Rule, false);
                                        }
                                    }
                                }
                            }
                        }
                        else if (varFeatureTypeStyle.Rule.Filter.PropertyIsBetween) {
                            if (ps.length > 0) {
                                if (ps[0]) {
                                    var p = d3.select(ps[0]);
                                    var properties = p[0][0].__data__.properties;
                                    for (var property in properties) {
                                        if (property.toLowerCase() === rule.Filter.PropertyIsBetween.PropertyName.toLowerCase()) {
                                            pNameExist = true;
                                            propertyName = property;
                                            break;
                                        }
                                    }
                                }
                            }
                            if (pNameExist === true) {
                                for (var k = 0; k < ps.length; k++)
                                {
                                    if (ps[k]) {
                                        var p = d3.select(ps[k]);
                                        var properties = p[0][0].__data__.properties;
                                        if (properties[propertyName] && (varFeatureTypeStyle.Rule.Filter.PropertyIsBetween.LowerBoundary === undefined) && (varFeatureTypeStyle.Rule.Filter.PropertyIsBetween.UpperBoundary !== undefined) && parseFloat(properties[propertyName]) <= parseFloat(varFeatureTypeStyle.Rule.Filter.PropertyIsBetween.UpperBoundary.Literal))
                                        {

                                            p = _this.setFeatureStyle(p, varFeatureTypeStyle.Rule, false);
                                        }
                                        if (properties[propertyName] && (varFeatureTypeStyle.Rule.Filter.PropertyIsBetween.LowerBoundary !== undefined) && (varFeatureTypeStyle.Rule.Filter.PropertyIsBetween.UpperBoundary !== undefined) && parseFloat(properties[propertyName]) > parseFloat(varFeatureTypeStyle.Rule.Filter.PropertyIsBetween.LowerBoundary.Literal) && parseFloat(properties[propertyName]) <= parseFloat(varFeatureTypeStyle.Rule.Filter.PropertyIsBetween.UpperBoundary.Literal)) {

                                            p = _this.setFeatureStyle(p, varFeatureTypeStyle.Rule, false);
                                        }
                                        if (properties[propertyName] && (varFeatureTypeStyle.Rule.Filter.PropertyIsBetween.LowerBoundary !== undefined) && (varFeatureTypeStyle.Rule.Filter.PropertyIsBetween.UpperBoundary === undefined) && parseFloat(properties[propertyName]) > parseFloat(varFeatureTypeStyle.Rule.Filter.PropertyIsBetween.LowerBoundary.Literal))
                                        {

                                            p = _this.setFeatureStyle(p, varFeatureTypeStyle.Rule, false);
                                        }
                                    }
                                }
                            }

                        }
                        else {

                            this._feature = _this.setFeatureStyle(this._feature, varFeatureTypeStyle.Rule, false);
                        }
                    }
                    else {

                        this._feature = _this.setFeatureStyle(this._feature, varFeatureTypeStyle.Rule, false);
                    }
                }
            }

        }
        else {

            this._feature.style("fill", 'none')
                    .style("fill-opacity", 0.0)
                    .style("stroke", "#000")
                    .style("stroke-width", 1.0)
                    .style("stroke-opacity", 0.8);
        }

    },
    setFeatureStyle: function (feature, rule, fill) {

        if (rule.PolygonSymbolizer && rule.PolygonSymbolizer.Fill && rule.PolygonSymbolizer.Fill.fill)
        {
            if (fill === false)
                feature.style('fill', 'none');
            else
                feature.style('fill', rule.PolygonSymbolizer.Fill.fill);
        }
        else
        {
            if (fill === false)
                feature.style('fill', 'none');
            else
                feature.style('fill', "#CCC");
        }
        if (rule.PolygonSymbolizer && rule.PolygonSymbolizer.Fill && rule.PolygonSymbolizer.Fill['fill-opacity'])
        {
            if (fill === false)
                feature.style('fill-opacity', 0.0);
            else
                feature.style('fill-opacity', rule.PolygonSymbolizer.Fill['fill-opacity']);
        }
        else
        {
            if (fill === false)
                feature.style('fill-opacity', 0.0);
            else
                feature.style('fill-opacity', 0.6);
        }
        if (rule.PolygonSymbolizer && rule.PolygonSymbolizer.Stroke && rule.PolygonSymbolizer.Stroke['stroke-opacity'])
        {
            feature.style('stroke-opacity', rule.PolygonSymbolizer.Stroke['stroke-opacity']);
        }
        if (rule.PolygonSymbolizer && rule.PolygonSymbolizer.Stroke && rule.PolygonSymbolizer.Stroke['stroke-width'])
        {
            feature.style('stroke-width', rule.PolygonSymbolizer.Stroke['stroke-width']);
        }
        else {

        }
        if (rule.PolygonSymbolizer && rule.PolygonSymbolizer.Stroke && rule.PolygonSymbolizer.Stroke.stroke)
        {
            feature.style('stroke', rule.PolygonSymbolizer.Stroke.stroke);
        }
        if (rule.PolygonSymbolizer && rule.PolygonSymbolizer.Stroke && rule.PolygonSymbolizer.Stroke['stroke-linecap'])
        {
            feature.style('stroke-linecap', rule.PolygonSymbolizer.Stroke['stroke-linecap']);
        }
        if (rule.PolygonSymbolizer && rule.PolygonSymbolizer.Stroke && rule.PolygonSymbolizer.Stroke['stroke-linejoin'])
        {
            feature.style('stroke-linejoin', rule.PolygonSymbolizer.Stroke['stroke-linejoin']);
        }
        if (rule.PolygonSymbolizer && rule.PolygonSymbolizer.Stroke && rule.PolygonSymbolizer.Stroke['stroke-dashoffset'])
        {
            feature.style('stroke-dashoffset', rule.PolygonSymbolizer.Stroke['stroke-dashoffset']);
        }








        if (rule.LineSymbolizer && rule.LineSymbolizer.Stroke && rule.LineSymbolizer.Stroke['stroke-opacity'])
        {
            feature.style('stroke-opacity', rule.LineSymbolizer.Stroke['stroke-opacity']);
        }
        if (rule.LineSymbolizer && rule.LineSymbolizer.Stroke && rule.LineSymbolizer.Stroke['stroke-width'])
        {
            feature.style('stroke-width', rule.LineSymbolizer.Stroke['stroke-width']);
        }
        if (rule.LineSymbolizer && rule.LineSymbolizer.Stroke && rule.LineSymbolizer.Stroke.stroke)
        {
            feature.style('stroke', rule.LineSymbolizer.Stroke.stroke);
        }
        if (rule.LineSymbolizer && rule.LineSymbolizer.Stroke && rule.LineSymbolizer.Stroke['stroke-linecap'])
        {
            feature.style('stroke-linecap', rule.LineSymbolizer.Stroke['stroke-linecap']);
        }
        if (rule.LineSymbolizer && rule.LineSymbolizer.Stroke && rule.LineSymbolizer.Stroke['stroke-linejoin'])
        {
            feature.style('stroke-linejoin', rule.LineSymbolizer.Stroke['stroke-linejoin']);
        }
        if (rule.LineSymbolizer && rule.LineSymbolizer.Stroke && rule.LineSymbolizer.Stroke['stroke-dashoffset'])
        {
            feature.style('stroke-dashoffset', rule.LineSymbolizer.Stroke['stroke-dashoffset']);
        }
        if (rule.TextSymbolizer && rule.TextSymbolizer.Label) {

        }



        return feature;
    },
    onLoadSLD: function (json_sld) {

        if (this._feature && this._featureType === 'Point') {

            this.onLoadPointSLD();
        }
        if (this._feature && (this._featureType === 'Polygon' || this._featureType === 'MultiPolygon')) {

            this.onLoadPolygonSLD();
        }
        if (this._feature && this._featureType === 'LineString' || this._featureType === 'MultiLineString' || this._featureType === 'Polyline' || this._featureType === 'MultiPolyline') {
            this.onLoadPolylineSLD();
        }

    },
    _bindPopup: function () {
        var _this = this;
        _this._g.on("click", function () {
            var props = d3.select(d3.event.target).datum().properties;
            if (typeof _this._popupContent === "string") {
                _this.fire("pathClicked", {cont: _this._popupContent});
            } else if (typeof _this._popupContent === "function") {
                _this.fire("pathClicked", {cont: _this._popupContent(props)});
            }

        }, true);
        _this.on("pathClicked", function (e) {
            _this._popup.setContent(e.cont);
            _this._openable = true;
            ;
        });
        _this._map.on("click", function (e) {
            if (_this._openable) {
                _this._openable = false;
                _this._popup.setLatLng(e.latlng).openOn(_this._map);
            }
        });
    }


});
L.d3 = function (data, options) {
    return new L.D3(data, options);
};

/*
	Leaflet.draw, a plugin that adds drawing and editing tools to Leaflet powered maps.
	(c) 2012-2013, Jacob Toye, Smartrak

	https://github.com/Leaflet/Leaflet.draw
	http://leafletjs.com
	https://github.com/jacobtoye
*/
!function(t,e){L.drawVersion="0.2.4-dev",L.drawLocal={draw:{toolbar:{actions:{title:I18n.t("Cancel drawing"),text:I18n.t("Cancel")},undo:{title:I18n.t("Delete last point drawn"),text:I18n.t("Delete last point")},buttons:{polyline:I18n.t("Draw a polyline"),polygon:I18n.t("Draw a polygon"),rectangle:I18n.t("Draw a rectangle"),circle:I18n.t("Draw a circle"),marker:I18n.t("Draw a marker")}},handlers:{circle:{tooltip:{start:I18n.t("Click and drag to draw circle")}},marker:{tooltip:{start:I18n.t("Click map to place marker")}},polygon:{tooltip:{start:I18n.t("Click to start drawing shape"),cont:I18n.t("Click to continue drawing shape"),end:I18n.t("Click first point to close this shape")}},polyline:{error:I18n.t("<strong>Error:</strong> shape edges cannot cross!"),tooltip:{start:I18n.t("Click to start drawing line"),cont:I18n.t("Click to continue drawing line"),end:I18n.t("Click last point to finish line")}},rectangle:{tooltip:{start:I18n.t("Click and drag to draw rectangle")}},simpleshape:{tooltip:{end:I18n.t("Release mouse to finish drawing")}}}},edit:{toolbar:{actions:{save:{title:I18n.t("Save changes"),text:I18n.t("Save")},cancel:{title:I18n.t("Cancel editing, discards all changes"),text:I18n.t("Cancel")}},buttons:{edit:I18n.t("Edit layers"),editDisabled:I18n.t("No layers to edit"),remove:I18n.t("Delete layers"),removeDisabled:I18n.t("No layers to delete")}},handlers:{edit:{tooltip:{text:I18n.t("Drag handles, or marker to edit feature"),subtext:I18n.t("Click cancel to undo changes")}},remove:{tooltip:{text:I18n.t("Click on a feature to remove")}}}}},L.Draw={},L.Draw.Feature=L.Handler.extend({includes:L.Mixin.Events,initialize:function(t,e){this._map=t,this._container=t._container,this._overlayPane=t._panes.overlayPane,this._popupPane=t._panes.popupPane,e&&e.shapeOptions&&(e.shapeOptions=L.Util.extend({},this.options.shapeOptions,e.shapeOptions)),L.setOptions(this,e)},enable:function(){this._enabled||(L.Handler.prototype.enable.call(this),this.fire("enabled",{handler:this.type}),this._map.fire("draw:drawstart",{layerType:this.type}))},disable:function(){this._enabled&&(L.Handler.prototype.disable.call(this),this._map.fire("draw:drawstop",{layerType:this.type}),this.fire("disabled",{handler:this.type}))},addHooks:function(){var t=this._map;t&&(L.DomUtil.disableTextSelection(),t.getContainer().focus(),this._tooltip=new L.Tooltip(this._map),L.DomEvent.on(this._container,"keyup",this._cancelDrawing,this))},removeHooks:function(){this._map&&(L.DomUtil.enableTextSelection(),this._tooltip.dispose(),this._tooltip=null,L.DomEvent.off(this._container,"keyup",this._cancelDrawing,this))},setOptions:function(t){L.setOptions(this,t)},_fireCreatedEvent:function(t){this._map.fire("draw:created",{layer:t,layerType:this.type})},_cancelDrawing:function(t){27===t.keyCode&&this.disable()}}),L.Draw.Polyline=L.Draw.Feature.extend({statics:{TYPE:"polyline"},Poly:L.Polyline,options:{allowIntersection:!0,repeatMode:!1,drawError:{color:"#b00b00",timeout:2500},icon:new L.DivIcon({iconSize:new L.Point(8,8),className:"leaflet-div-icon leaflet-editing-icon"}),guidelineDistance:20,maxGuideLineLength:4e3,shapeOptions:{stroke:!0,color:"#f06eaa",weight:4,opacity:.5,fill:!1,clickable:!0},metric:!0,showLength:!0,zIndexOffset:2e3},initialize:function(t,e){this.options.drawError.message=L.drawLocal.draw.handlers.polyline.error,e&&e.drawError&&(e.drawError=L.Util.extend({},this.options.drawError,e.drawError)),this.type=L.Draw.Polyline.TYPE,L.Draw.Feature.prototype.initialize.call(this,t,e)},addHooks:function(){L.Draw.Feature.prototype.addHooks.call(this),this._map&&(this._markers=[],this._markerGroup=new L.LayerGroup,this._map.addLayer(this._markerGroup),this._poly=new L.Polyline([],this.options.shapeOptions),this._tooltip.updateContent(this._getTooltipText()),this._mouseMarker||(this._mouseMarker=L.marker(this._map.getCenter(),{icon:L.divIcon({className:"leaflet-mouse-marker",iconAnchor:[20,20],iconSize:[40,40]}),opacity:0,zIndexOffset:this.options.zIndexOffset})),this._mouseMarker.on("mousedown",this._onMouseDown,this).addTo(this._map),this._map.on("mousemove",this._onMouseMove,this).on("mouseup",this._onMouseUp,this).on("zoomend",this._onZoomEnd,this))},removeHooks:function(){L.Draw.Feature.prototype.removeHooks.call(this),this._clearHideErrorTimeout(),this._cleanUpShape(),this._map.removeLayer(this._markerGroup),delete this._markerGroup,delete this._markers,this._map.removeLayer(this._poly),delete this._poly,this._mouseMarker.off("mousedown",this._onMouseDown,this).off("mouseup",this._onMouseUp,this),this._map.removeLayer(this._mouseMarker),delete this._mouseMarker,this._clearGuides(),this._map.off("mousemove",this._onMouseMove,this).off("zoomend",this._onZoomEnd,this)},deleteLastVertex:function(){if(!(this._markers.length<=1)){var t=this._markers.pop(),e=this._poly,i=this._poly.spliceLatLngs(e.getLatLngs().length-1,1)[0];this._markerGroup.removeLayer(t),e.getLatLngs().length<2&&this._map.removeLayer(e),this._vertexChanged(i,!1)}},addVertex:function(t){var e=this._markers.length;return e>0&&!this.options.allowIntersection&&this._poly.newLatLngIntersects(t)?(this._showErrorTooltip(),void 0):(this._errorShown&&this._hideErrorTooltip(),this._markers.push(this._createMarker(t)),this._poly.addLatLng(t),2===this._poly.getLatLngs().length&&this._map.addLayer(this._poly),this._vertexChanged(t,!0),void 0)},_finishShape:function(){var t=this._poly.newLatLngIntersects(this._poly.getLatLngs()[0],!0);return!this.options.allowIntersection&&t||!this._shapeIsValid()?(this._showErrorTooltip(),void 0):(this._fireCreatedEvent(),this.disable(),this.options.repeatMode&&this.enable(),void 0)},_shapeIsValid:function(){return!0},_onZoomEnd:function(){this._updateGuide()},_onMouseMove:function(t){var e=t.layerPoint,i=t.latlng;this._currentLatLng=i,this._updateTooltip(i),this._updateGuide(e),this._mouseMarker.setLatLng(i),L.DomEvent.preventDefault(t.originalEvent)},_vertexChanged:function(t,e){this._updateFinishHandler(),this._updateRunningMeasure(t,e),this._clearGuides(),this._updateTooltip()},_onMouseDown:function(t){var e=t.originalEvent;this._mouseDownOrigin=L.point(e.clientX,e.clientY)},_onMouseUp:function(e){if(this._mouseDownOrigin){var i=L.point(e.originalEvent.clientX,e.originalEvent.clientY).distanceTo(this._mouseDownOrigin);Math.abs(i)<9*(t.devicePixelRatio||1)&&this.addVertex(e.latlng)}this._mouseDownOrigin=null},_updateFinishHandler:function(){var t=this._markers.length;t>1&&this._markers[t-1].on("click",this._finishShape,this),t>2&&this._markers[t-2].off("click",this._finishShape,this)},_createMarker:function(t){var e=new L.Marker(t,{icon:this.options.icon,zIndexOffset:2*this.options.zIndexOffset});return this._markerGroup.addLayer(e),e},_updateGuide:function(t){var e=this._markers.length;e>0&&(t=t||this._map.latLngToLayerPoint(this._currentLatLng),this._clearGuides(),this._drawGuide(this._map.latLngToLayerPoint(this._markers[e-1].getLatLng()),t))},_updateTooltip:function(t){var e=this._getTooltipText();t&&this._tooltip.updatePosition(t),this._errorShown||this._tooltip.updateContent(e)},_drawGuide:function(t,e){var i,o,a,s=Math.floor(Math.sqrt(Math.pow(e.x-t.x,2)+Math.pow(e.y-t.y,2))),r=this.options.guidelineDistance,n=this.options.maxGuideLineLength,l=s>n?s-n:r;for(this._guidesContainer||(this._guidesContainer=L.DomUtil.create("div","leaflet-draw-guides",this._overlayPane));s>l;l+=this.options.guidelineDistance)i=l/s,o={x:Math.floor(t.x*(1-i)+i*e.x),y:Math.floor(t.y*(1-i)+i*e.y)},a=L.DomUtil.create("div","leaflet-draw-guide-dash",this._guidesContainer),a.style.backgroundColor=this._errorShown?this.options.drawError.color:this.options.shapeOptions.color,L.DomUtil.setPosition(a,o)},_updateGuideColor:function(t){if(this._guidesContainer)for(var e=0,i=this._guidesContainer.childNodes.length;i>e;e++)this._guidesContainer.childNodes[e].style.backgroundColor=t},_clearGuides:function(){if(this._guidesContainer)for(;this._guidesContainer.firstChild;)this._guidesContainer.removeChild(this._guidesContainer.firstChild)},_getTooltipText:function(){var t,e,i=this.options.showLength;return 0===this._markers.length?t={text:L.drawLocal.draw.handlers.polyline.tooltip.start}:(e=i?this._getMeasurementString():"",t=1===this._markers.length?{text:L.drawLocal.draw.handlers.polyline.tooltip.cont,subtext:e}:{text:L.drawLocal.draw.handlers.polyline.tooltip.end,subtext:e}),t},_updateRunningMeasure:function(t,e){var i,o,a=this._markers.length;1===this._markers.length?this._measurementRunningTotal=0:(i=a-(e?2:1),o=t.distanceTo(this._markers[i].getLatLng()),this._measurementRunningTotal+=o*(e?1:-1))},_getMeasurementString:function(){var t,e=this._currentLatLng,i=this._markers[this._markers.length-1].getLatLng();return t=this._measurementRunningTotal+e.distanceTo(i),L.GeometryUtil.readableDistance(t,this.options.metric)},_showErrorTooltip:function(){this._errorShown=!0,this._tooltip.showAsError().updateContent({text:this.options.drawError.message}),this._updateGuideColor(this.options.drawError.color),this._poly.setStyle({color:this.options.drawError.color}),this._clearHideErrorTimeout(),this._hideErrorTimeout=setTimeout(L.Util.bind(this._hideErrorTooltip,this),this.options.drawError.timeout)},_hideErrorTooltip:function(){this._errorShown=!1,this._clearHideErrorTimeout(),this._tooltip.removeError().updateContent(this._getTooltipText()),this._updateGuideColor(this.options.shapeOptions.color),this._poly.setStyle({color:this.options.shapeOptions.color})},_clearHideErrorTimeout:function(){this._hideErrorTimeout&&(clearTimeout(this._hideErrorTimeout),this._hideErrorTimeout=null)},_cleanUpShape:function(){this._markers.length>1&&this._markers[this._markers.length-1].off("click",this._finishShape,this)},_fireCreatedEvent:function(){var t=new this.Poly(this._poly.getLatLngs(),this.options.shapeOptions);L.Draw.Feature.prototype._fireCreatedEvent.call(this,t)}}),L.Draw.Polygon=L.Draw.Polyline.extend({statics:{TYPE:"polygon"},Poly:L.Polygon,options:{showArea:!1,shapeOptions:{stroke:!0,color:"#f06eaa",weight:4,opacity:.5,fill:!0,fillColor:null,fillOpacity:.2,clickable:!0}},initialize:function(t,e){L.Draw.Polyline.prototype.initialize.call(this,t,e),this.type=L.Draw.Polygon.TYPE},_updateFinishHandler:function(){var t=this._markers.length;1===t&&this._markers[0].on("click",this._finishShape,this),t>2&&(this._markers[t-1].on("dblclick",this._finishShape,this),t>3&&this._markers[t-2].off("dblclick",this._finishShape,this))},_getTooltipText:function(){var t,e;return 0===this._markers.length?t=L.drawLocal.draw.handlers.polygon.tooltip.start:this._markers.length<3?t=L.drawLocal.draw.handlers.polygon.tooltip.cont:(t=L.drawLocal.draw.handlers.polygon.tooltip.end,e=this._getMeasurementString()),{text:t,subtext:e}},_getMeasurementString:function(){var t=this._area;return t?L.GeometryUtil.readableArea(t,this.options.metric):null},_shapeIsValid:function(){return this._markers.length>=3},_vertexChanged:function(t,e){var i;!this.options.allowIntersection&&this.options.showArea&&(i=this._poly.getLatLngs(),this._area=L.GeometryUtil.geodesicArea(i)),L.Draw.Polyline.prototype._vertexChanged.call(this,t,e)},_cleanUpShape:function(){var t=this._markers.length;t>0&&(this._markers[0].off("click",this._finishShape,this),t>2&&this._markers[t-1].off("dblclick",this._finishShape,this))}}),L.SimpleShape={},L.Draw.SimpleShape=L.Draw.Feature.extend({options:{repeatMode:!1},initialize:function(t,e){this._endLabelText=L.drawLocal.draw.handlers.simpleshape.tooltip.end,L.Draw.Feature.prototype.initialize.call(this,t,e)},addHooks:function(){L.Draw.Feature.prototype.addHooks.call(this),this._map&&(this._mapDraggable=this._map.dragging.enabled(),this._mapDraggable&&this._map.dragging.disable(),this._container.style.cursor="crosshair",this._tooltip.updateContent({text:this._initialLabelText}),this._map.on("mousedown",this._onMouseDown,this).on("mousemove",this._onMouseMove,this))},removeHooks:function(){L.Draw.Feature.prototype.removeHooks.call(this),this._map&&(this._mapDraggable&&this._map.dragging.enable(),this._container.style.cursor="",this._map.off("mousedown",this._onMouseDown,this).off("mousemove",this._onMouseMove,this),L.DomEvent.off(e,"mouseup",this._onMouseUp,this),this._shape&&(this._map.removeLayer(this._shape),delete this._shape)),this._isDrawing=!1},_onMouseDown:function(t){this._isDrawing=!0,this._startLatLng=t.latlng,L.DomEvent.on(e,"mouseup",this._onMouseUp,this).preventDefault(t.originalEvent)},_onMouseMove:function(t){var e=t.latlng;this._tooltip.updatePosition(e),this._isDrawing&&(this._tooltip.updateContent({text:this._endLabelText}),this._drawShape(e))},_onMouseUp:function(){this._shape&&this._fireCreatedEvent(),this.disable(),this.options.repeatMode&&this.enable()}}),L.Draw.Rectangle=L.Draw.SimpleShape.extend({statics:{TYPE:"rectangle"},options:{shapeOptions:{stroke:!0,color:"#f06eaa",weight:4,opacity:.5,fill:!0,fillColor:null,fillOpacity:.2,clickable:!0}},initialize:function(t,e){this.type=L.Draw.Rectangle.TYPE,this._initialLabelText=L.drawLocal.draw.handlers.rectangle.tooltip.start,L.Draw.SimpleShape.prototype.initialize.call(this,t,e)},_drawShape:function(t){this._shape?this._shape.setBounds(new L.LatLngBounds(this._startLatLng,t)):(this._shape=new L.Rectangle(new L.LatLngBounds(this._startLatLng,t),this.options.shapeOptions),this._map.addLayer(this._shape))},_fireCreatedEvent:function(){var t=new L.Rectangle(this._shape.getBounds(),this.options.shapeOptions);L.Draw.SimpleShape.prototype._fireCreatedEvent.call(this,t)}}),L.Draw.Circle=L.Draw.SimpleShape.extend({statics:{TYPE:"circle"},options:{shapeOptions:{stroke:!0,color:"#f06eaa",weight:4,opacity:.5,fill:!0,fillColor:null,fillOpacity:.2,clickable:!0},showRadius:!0,metric:!0},initialize:function(t,e){this.type=L.Draw.Circle.TYPE,this._initialLabelText=L.drawLocal.draw.handlers.circle.tooltip.start,L.Draw.SimpleShape.prototype.initialize.call(this,t,e)},_drawShape:function(t){this._shape?this._shape.setRadius(this._startLatLng.distanceTo(t)):(this._shape=new L.Circle(this._startLatLng,this._startLatLng.distanceTo(t),this.options.shapeOptions),this._map.addLayer(this._shape))},_fireCreatedEvent:function(){var t=new L.Circle(this._startLatLng,this._shape.getRadius(),this.options.shapeOptions);L.Draw.SimpleShape.prototype._fireCreatedEvent.call(this,t)},_onMouseMove:function(t){var e,i=t.latlng,o=this.options.showRadius,a=this.options.metric;this._tooltip.updatePosition(i),this._isDrawing&&(this._drawShape(i),e=this._shape.getRadius().toFixed(1),this._tooltip.updateContent({text:this._endLabelText,subtext:o?"Radius: "+L.GeometryUtil.readableDistance(e,a):""}))}}),L.Draw.Marker=L.Draw.Feature.extend({statics:{TYPE:"marker"},options:{icon:new L.Icon.Default,repeatMode:!1,zIndexOffset:2e3},initialize:function(t,e){this.type=L.Draw.Marker.TYPE,L.Draw.Feature.prototype.initialize.call(this,t,e)},addHooks:function(){L.Draw.Feature.prototype.addHooks.call(this),this._map&&(this._tooltip.updateContent({text:L.drawLocal.draw.handlers.marker.tooltip.start}),this._mouseMarker||(this._mouseMarker=L.marker(this._map.getCenter(),{icon:L.divIcon({className:"leaflet-mouse-marker",iconAnchor:[20,20],iconSize:[40,40]}),opacity:0,zIndexOffset:this.options.zIndexOffset})),this._mouseMarker.on("click",this._onClick,this).addTo(this._map),this._map.on("mousemove",this._onMouseMove,this))},removeHooks:function(){L.Draw.Feature.prototype.removeHooks.call(this),this._map&&(this._marker&&(this._marker.off("click",this._onClick,this),this._map.off("click",this._onClick,this).removeLayer(this._marker),delete this._marker),this._mouseMarker.off("click",this._onClick,this),this._map.removeLayer(this._mouseMarker),delete this._mouseMarker,this._map.off("mousemove",this._onMouseMove,this))},_onMouseMove:function(t){var e=t.latlng;this._tooltip.updatePosition(e),this._mouseMarker.setLatLng(e),this._marker?(e=this._mouseMarker.getLatLng(),this._marker.setLatLng(e)):(this._marker=new L.Marker(e,{icon:this.options.icon,zIndexOffset:this.options.zIndexOffset}),this._marker.on("click",this._onClick,this),this._map.on("click",this._onClick,this).addLayer(this._marker))},_onClick:function(){this._fireCreatedEvent(),this.disable(),this.options.repeatMode&&this.enable()},_fireCreatedEvent:function(){var t=new L.Marker(this._marker.getLatLng(),{icon:this.options.icon});L.Draw.Feature.prototype._fireCreatedEvent.call(this,t)}}),L.Edit=L.Edit||{},L.Edit.Poly=L.Handler.extend({options:{icon:new L.DivIcon({iconSize:new L.Point(8,8),className:"leaflet-div-icon leaflet-editing-icon"})},initialize:function(t,e){this._poly=t,L.setOptions(this,e)},addHooks:function(){this._poly._map&&(this._markerGroup||this._initMarkers(),this._poly._map.addLayer(this._markerGroup))},removeHooks:function(){this._poly._map&&(this._poly._map.removeLayer(this._markerGroup),delete this._markerGroup,delete this._markers)},updateMarkers:function(){this._markerGroup.clearLayers(),this._initMarkers()},_initMarkers:function(){this._markerGroup||(this._markerGroup=new L.LayerGroup),this._markers=[];var t,e,i,o,a=this._poly._latlngs;for(t=0,i=a.length;i>t;t++)o=this._createMarker(a[t],t),o.on("click",this._onMarkerClick,this),this._markers.push(o);var s,r;for(t=0,e=i-1;i>t;e=t++)(0!==t||L.Polygon&&this._poly instanceof L.Polygon)&&(s=this._markers[e],r=this._markers[t],this._createMiddleMarker(s,r),this._updatePrevNext(s,r))},_createMarker:function(t,e){var i=new L.Marker(t,{draggable:!0,icon:this.options.icon});return i._origLatLng=t,i._index=e,i.on("drag",this._onMarkerDrag,this),i.on("dragend",this._fireEdit,this),this._markerGroup.addLayer(i),i},_removeMarker:function(t){var e=t._index;this._markerGroup.removeLayer(t),this._markers.splice(e,1),this._poly.spliceLatLngs(e,1),this._updateIndexes(e,-1),t.off("drag",this._onMarkerDrag,this).off("dragend",this._fireEdit,this).off("click",this._onMarkerClick,this)},_fireEdit:function(){this._poly.edited=!0,this._poly.fire("edit")},_onMarkerDrag:function(t){var e=t.target;L.extend(e._origLatLng,e._latlng),e._middleLeft&&e._middleLeft.setLatLng(this._getMiddleLatLng(e._prev,e)),e._middleRight&&e._middleRight.setLatLng(this._getMiddleLatLng(e,e._next)),this._poly.redraw()},_onMarkerClick:function(t){var e=L.Polygon&&this._poly instanceof L.Polygon?4:3,i=t.target;this._poly._latlngs.length<e||(this._removeMarker(i),this._updatePrevNext(i._prev,i._next),i._middleLeft&&this._markerGroup.removeLayer(i._middleLeft),i._middleRight&&this._markerGroup.removeLayer(i._middleRight),i._prev&&i._next?this._createMiddleMarker(i._prev,i._next):i._prev?i._next||(i._prev._middleRight=null):i._next._middleLeft=null,this._fireEdit())},_updateIndexes:function(t,e){this._markerGroup.eachLayer(function(i){i._index>t&&(i._index+=e)})},_createMiddleMarker:function(t,e){var i,o,a,s=this._getMiddleLatLng(t,e),r=this._createMarker(s);r.setOpacity(.6),t._middleRight=e._middleLeft=r,o=function(){var o=e._index;r._index=o,r.off("click",i,this).on("click",this._onMarkerClick,this),s.lat=r.getLatLng().lat,s.lng=r.getLatLng().lng,this._poly.spliceLatLngs(o,0,s),this._markers.splice(o,0,r),r.setOpacity(1),this._updateIndexes(o,1),e._index++,this._updatePrevNext(t,r),this._updatePrevNext(r,e),this._poly.fire("editstart")},a=function(){r.off("dragstart",o,this),r.off("dragend",a,this),this._createMiddleMarker(t,r),this._createMiddleMarker(r,e)},i=function(){o.call(this),a.call(this),this._fireEdit()},r.on("click",i,this).on("dragstart",o,this).on("dragend",a,this),this._markerGroup.addLayer(r)},_updatePrevNext:function(t,e){t&&(t._next=e),e&&(e._prev=t)},_getMiddleLatLng:function(t,e){var i=this._poly._map,o=i.project(t.getLatLng()),a=i.project(e.getLatLng());return i.unproject(o._add(a)._divideBy(2))}}),L.Polyline.addInitHook(function(){this.editing||(L.Edit.Poly&&(this.editing=new L.Edit.Poly(this),this.options.editable&&this.editing.enable()),this.on("add",function(){this.editing&&this.editing.enabled()&&this.editing.addHooks()}),this.on("remove",function(){this.editing&&this.editing.enabled()&&this.editing.removeHooks()}))}),L.Edit=L.Edit||{},L.Edit.SimpleShape=L.Handler.extend({options:{moveIcon:new L.DivIcon({iconSize:new L.Point(8,8),className:"leaflet-div-icon leaflet-editing-icon leaflet-edit-move"}),resizeIcon:new L.DivIcon({iconSize:new L.Point(8,8),className:"leaflet-div-icon leaflet-editing-icon leaflet-edit-resize"})},initialize:function(t,e){this._shape=t,L.Util.setOptions(this,e)},addHooks:function(){this._shape._map&&(this._map=this._shape._map,this._markerGroup||this._initMarkers(),this._map.addLayer(this._markerGroup))},removeHooks:function(){if(this._shape._map){this._unbindMarker(this._moveMarker);for(var t=0,e=this._resizeMarkers.length;e>t;t++)this._unbindMarker(this._resizeMarkers[t]);this._resizeMarkers=null,this._map.removeLayer(this._markerGroup),delete this._markerGroup}this._map=null},updateMarkers:function(){this._markerGroup.clearLayers(),this._initMarkers()},_initMarkers:function(){this._markerGroup||(this._markerGroup=new L.LayerGroup),this._createMoveMarker(),this._createResizeMarker()},_createMoveMarker:function(){},_createResizeMarker:function(){},_createMarker:function(t,e){var i=new L.Marker(t,{draggable:!0,icon:e,zIndexOffset:10});return this._bindMarker(i),this._markerGroup.addLayer(i),i},_bindMarker:function(t){t.on("dragstart",this._onMarkerDragStart,this).on("drag",this._onMarkerDrag,this).on("dragend",this._onMarkerDragEnd,this)},_unbindMarker:function(t){t.off("dragstart",this._onMarkerDragStart,this).off("drag",this._onMarkerDrag,this).off("dragend",this._onMarkerDragEnd,this)},_onMarkerDragStart:function(t){var e=t.target;e.setOpacity(0),this._shape.fire("editstart")},_fireEdit:function(){this._shape.edited=!0,this._shape.fire("edit")},_onMarkerDrag:function(t){var e=t.target,i=e.getLatLng();e===this._moveMarker?this._move(i):this._resize(i),this._shape.redraw()},_onMarkerDragEnd:function(t){var e=t.target;e.setOpacity(1),this._fireEdit()},_move:function(){},_resize:function(){}}),L.Edit=L.Edit||{},L.Edit.Rectangle=L.Edit.SimpleShape.extend({_createMoveMarker:function(){var t=this._shape.getBounds(),e=t.getCenter();this._moveMarker=this._createMarker(e,this.options.moveIcon)},_createResizeMarker:function(){var t=this._getCorners();this._resizeMarkers=[];for(var e=0,i=t.length;i>e;e++)this._resizeMarkers.push(this._createMarker(t[e],this.options.resizeIcon)),this._resizeMarkers[e]._cornerIndex=e},_onMarkerDragStart:function(t){L.Edit.SimpleShape.prototype._onMarkerDragStart.call(this,t);var e=this._getCorners(),i=t.target,o=i._cornerIndex;this._oppositeCorner=e[(o+2)%4],this._toggleCornerMarkers(0,o)},_onMarkerDragEnd:function(t){var e,i,o=t.target;o===this._moveMarker&&(e=this._shape.getBounds(),i=e.getCenter(),o.setLatLng(i)),this._toggleCornerMarkers(1),this._repositionCornerMarkers(),L.Edit.SimpleShape.prototype._onMarkerDragEnd.call(this,t)},_move:function(t){for(var e,i=this._shape.getLatLngs(),o=this._shape.getBounds(),a=o.getCenter(),s=[],r=0,n=i.length;n>r;r++)e=[i[r].lat-a.lat,i[r].lng-a.lng],s.push([t.lat+e[0],t.lng+e[1]]);this._shape.setLatLngs(s),this._repositionCornerMarkers()},_resize:function(t){var e;this._shape.setBounds(L.latLngBounds(t,this._oppositeCorner)),e=this._shape.getBounds(),this._moveMarker.setLatLng(e.getCenter())},_getCorners:function(){var t=this._shape.getBounds(),e=t.getNorthWest(),i=t.getNorthEast(),o=t.getSouthEast(),a=t.getSouthWest();return[e,i,o,a]},_toggleCornerMarkers:function(t){for(var e=0,i=this._resizeMarkers.length;i>e;e++)this._resizeMarkers[e].setOpacity(t)},_repositionCornerMarkers:function(){for(var t=this._getCorners(),e=0,i=this._resizeMarkers.length;i>e;e++)this._resizeMarkers[e].setLatLng(t[e])}}),L.Rectangle.addInitHook(function(){L.Edit.Rectangle&&(this.editing=new L.Edit.Rectangle(this),this.options.editable&&this.editing.enable())}),L.Edit=L.Edit||{},L.Edit.Circle=L.Edit.SimpleShape.extend({_createMoveMarker:function(){var t=this._shape.getLatLng();this._moveMarker=this._createMarker(t,this.options.moveIcon)},_createResizeMarker:function(){var t=this._shape.getLatLng(),e=this._getResizeMarkerPoint(t);this._resizeMarkers=[],this._resizeMarkers.push(this._createMarker(e,this.options.resizeIcon))},_getResizeMarkerPoint:function(t){var e=this._shape._radius*Math.cos(Math.PI/4),i=this._map.project(t);return this._map.unproject([i.x+e,i.y-e])},_move:function(t){var e=this._getResizeMarkerPoint(t);this._resizeMarkers[0].setLatLng(e),this._shape.setLatLng(t)},_resize:function(t){var e=this._moveMarker.getLatLng(),i=e.distanceTo(t);this._shape.setRadius(i)}}),L.Circle.addInitHook(function(){L.Edit.Circle&&(this.editing=new L.Edit.Circle(this),this.options.editable&&this.editing.enable()),this.on("add",function(){this.editing&&this.editing.enabled()&&this.editing.addHooks()}),this.on("remove",function(){this.editing&&this.editing.enabled()&&this.editing.removeHooks()})}),L.LatLngUtil={cloneLatLngs:function(t){for(var e=[],i=0,o=t.length;o>i;i++)e.push(this.cloneLatLng(t[i]));return e},cloneLatLng:function(t){return L.latLng(t.lat,t.lng)}},L.GeometryUtil=L.extend(L.GeometryUtil||{},{geodesicArea:function(t){var e,i,o=t.length,a=0,s=L.LatLng.DEG_TO_RAD;if(o>2){for(var r=0;o>r;r++)e=t[r],i=t[(r+1)%o],a+=(i.lng-e.lng)*s*(2+Math.sin(e.lat*s)+Math.sin(i.lat*s));a=6378137*a*6378137/2}return Math.abs(a)},readableArea:function(t,e){var i;return e?i=t>=1e4?(1e-4*t).toFixed(2)+" ha":t.toFixed(2)+" m&sup2;":(t*=.836127,i=t>=3097600?(t/3097600).toFixed(2)+" mi&sup2;":t>=4840?(t/4840).toFixed(2)+" acres":Math.ceil(t)+" yd&sup2;"),i},readableDistance:function(t,e){var i;return e?i=t>1e3?(t/1e3).toFixed(2)+" km":Math.ceil(t)+" m":(t*=1.09361,i=t>1760?(t/1760).toFixed(2)+" miles":Math.ceil(t)+" yd"),i}}),L.Util.extend(L.LineUtil,{segmentsIntersect:function(t,e,i,o){return this._checkCounterclockwise(t,i,o)!==this._checkCounterclockwise(e,i,o)&&this._checkCounterclockwise(t,e,i)!==this._checkCounterclockwise(t,e,o)},_checkCounterclockwise:function(t,e,i){return(i.y-t.y)*(e.x-t.x)>(e.y-t.y)*(i.x-t.x)}}),L.Polyline.include({intersects:function(){var t,e,i,o=this._originalPoints,a=o?o.length:0;if(this._tooFewPointsForIntersection())return!1;for(t=a-1;t>=3;t--)if(e=o[t-1],i=o[t],this._lineSegmentsIntersectsRange(e,i,t-2))return!0;return!1},newLatLngIntersects:function(t,e){return this._map?this.newPointIntersects(this._map.latLngToLayerPoint(t),e):!1},newPointIntersects:function(t,e){var i=this._originalPoints,o=i?i.length:0,a=i?i[o-1]:null,s=o-2;return this._tooFewPointsForIntersection(1)?!1:this._lineSegmentsIntersectsRange(a,t,s,e?1:0)},_tooFewPointsForIntersection:function(t){var e=this._originalPoints,i=e?e.length:0;return i+=t||0,!this._originalPoints||3>=i},_lineSegmentsIntersectsRange:function(t,e,i,o){var a,s,r=this._originalPoints;o=o||0;for(var n=i;n>o;n--)if(a=r[n-1],s=r[n],L.LineUtil.segmentsIntersect(t,e,a,s))return!0;return!1}}),L.Polygon.include({intersects:function(){var t,e,i,o,a,s=this._originalPoints;return this._tooFewPointsForIntersection()?!1:(t=L.Polyline.prototype.intersects.call(this))?!0:(e=s.length,i=s[0],o=s[e-1],a=e-2,this._lineSegmentsIntersectsRange(o,i,a,1))}}),L.Control.Draw=L.Control.extend({options:{position:"topleft",draw:{},edit:!1},initialize:function(t){if(L.version<"0.7")throw new Error("Leaflet.draw 0.2.3+ requires Leaflet 0.7.0+. Download latest from https://github.com/Leaflet/Leaflet/");L.Control.prototype.initialize.call(this,t);var e;this._toolbars={},L.DrawToolbar&&this.options.draw&&(e=new L.DrawToolbar(this.options.draw),this._toolbars[L.DrawToolbar.TYPE]=e,this._toolbars[L.DrawToolbar.TYPE].on("enable",this._toolbarEnabled,this)),L.EditToolbar&&this.options.edit&&(e=new L.EditToolbar(this.options.edit),this._toolbars[L.EditToolbar.TYPE]=e,this._toolbars[L.EditToolbar.TYPE].on("enable",this._toolbarEnabled,this))},onAdd:function(t){var e,i=L.DomUtil.create("div","leaflet-draw"),o=!1,a="leaflet-draw-toolbar-top";for(var s in this._toolbars)this._toolbars.hasOwnProperty(s)&&(e=this._toolbars[s].addToolbar(t),e&&(o||(L.DomUtil.hasClass(e,a)||L.DomUtil.addClass(e.childNodes[0],a),o=!0),i.appendChild(e)));return i},onRemove:function(){for(var t in this._toolbars)this._toolbars.hasOwnProperty(t)&&this._toolbars[t].removeToolbar()},setDrawingOptions:function(t){for(var e in this._toolbars)this._toolbars[e]instanceof L.DrawToolbar&&this._toolbars[e].setOptions(t)},_toolbarEnabled:function(t){var e=t.target;for(var i in this._toolbars)this._toolbars[i]!==e&&this._toolbars[i].disable()}}),L.Map.mergeOptions({drawControlTooltips:!0,drawControl:!1}),L.Map.addInitHook(function(){this.options.drawControl&&(this.drawControl=new L.Control.Draw,this.addControl(this.drawControl))}),L.Toolbar=L.Class.extend({includes:[L.Mixin.Events],initialize:function(t){L.setOptions(this,t),this._modes={},this._actionButtons=[],this._activeMode=null},enabled:function(){return null!==this._activeMode},disable:function(){this.enabled()&&this._activeMode.handler.disable()},addToolbar:function(t){var e,i=L.DomUtil.create("div","leaflet-draw-section"),o=0,a=this._toolbarClass||"",s=this.getModeHandlers(t);for(this._toolbarContainer=L.DomUtil.create("div","leaflet-draw-toolbar leaflet-bar"),this._map=t,e=0;e<s.length;e++)s[e].enabled&&this._initModeHandler(s[e].handler,this._toolbarContainer,o++,a,s[e].title);return o?(this._lastButtonIndex=--o,this._actionsContainer=L.DomUtil.create("ul","leaflet-draw-actions"),i.appendChild(this._toolbarContainer),i.appendChild(this._actionsContainer),i):void 0},removeToolbar:function(){for(var t in this._modes)this._modes.hasOwnProperty(t)&&(this._disposeButton(this._modes[t].button,this._modes[t].handler.enable,this._modes[t].handler),this._modes[t].handler.disable(),this._modes[t].handler.off("enabled",this._handlerActivated,this).off("disabled",this._handlerDeactivated,this));this._modes={};for(var e=0,i=this._actionButtons.length;i>e;e++)this._disposeButton(this._actionButtons[e].button,this._actionButtons[e].callback,this);this._actionButtons=[],this._actionsContainer=null},_initModeHandler:function(t,e,i,o,a){var s=t.type;this._modes[s]={},this._modes[s].handler=t,this._modes[s].button=this._createButton({title:a,className:o+"-"+s,container:e,callback:this._modes[s].handler.enable,context:this._modes[s].handler}),this._modes[s].buttonIndex=i,this._modes[s].handler.on("enabled",this._handlerActivated,this).on("disabled",this._handlerDeactivated,this)},_createButton:function(t){var e=L.DomUtil.create("a",t.className||"",t.container);return e.href="#",t.text&&(e.innerHTML=t.text),t.title&&(e.title=t.title),L.DomEvent.on(e,"click",L.DomEvent.stopPropagation).on(e,"mousedown",L.DomEvent.stopPropagation).on(e,"dblclick",L.DomEvent.stopPropagation).on(e,"click",L.DomEvent.preventDefault).on(e,"click",t.callback,t.context),e},_disposeButton:function(t,e){L.DomEvent.off(t,"click",L.DomEvent.stopPropagation).off(t,"mousedown",L.DomEvent.stopPropagation).off(t,"dblclick",L.DomEvent.stopPropagation).off(t,"click",L.DomEvent.preventDefault).off(t,"click",e)},_handlerActivated:function(t){this.disable(),this._activeMode=this._modes[t.handler],L.DomUtil.addClass(this._activeMode.button,"leaflet-draw-toolbar-button-enabled"),this._showActionsToolbar(),this.fire("enable")},_handlerDeactivated:function(){this._hideActionsToolbar(),L.DomUtil.removeClass(this._activeMode.button,"leaflet-draw-toolbar-button-enabled"),this._activeMode=null,this.fire("disable")},_createActions:function(t){var e,i,o,a,s=this._actionsContainer,r=this.getActions(t),n=r.length;for(i=0,o=this._actionButtons.length;o>i;i++)this._disposeButton(this._actionButtons[i].button,this._actionButtons[i].callback);for(this._actionButtons=[];s.firstChild;)s.removeChild(s.firstChild);for(var l=0;n>l;l++)"enabled"in r[l]&&!r[l].enabled||(e=L.DomUtil.create("li","",s),a=this._createButton({title:r[l].title,text:r[l].text,container:e,callback:r[l].callback,context:r[l].context}),this._actionButtons.push({button:a,callback:r[l].callback}))},_showActionsToolbar:function(){var t=this._activeMode.buttonIndex,e=this._lastButtonIndex,i=this._activeMode.button.offsetTop-1;this._createActions(this._activeMode.handler),this._actionsContainer.style.top=i+"px",0===t&&(L.DomUtil.addClass(this._toolbarContainer,"leaflet-draw-toolbar-notop"),L.DomUtil.addClass(this._actionsContainer,"leaflet-draw-actions-top")),t===e&&(L.DomUtil.addClass(this._toolbarContainer,"leaflet-draw-toolbar-nobottom"),L.DomUtil.addClass(this._actionsContainer,"leaflet-draw-actions-bottom")),this._actionsContainer.style.display="block"
},_hideActionsToolbar:function(){this._actionsContainer.style.display="none",L.DomUtil.removeClass(this._toolbarContainer,"leaflet-draw-toolbar-notop"),L.DomUtil.removeClass(this._toolbarContainer,"leaflet-draw-toolbar-nobottom"),L.DomUtil.removeClass(this._actionsContainer,"leaflet-draw-actions-top"),L.DomUtil.removeClass(this._actionsContainer,"leaflet-draw-actions-bottom")}}),L.Tooltip=L.Class.extend({initialize:function(t){this._map=t,this._popupPane=t._panes.popupPane,this._container=t.options.drawControlTooltips?L.DomUtil.create("div","leaflet-draw-tooltip",this._popupPane):null,this._singleLineLabel=!1},dispose:function(){this._container&&(this._popupPane.removeChild(this._container),this._container=null)},updateContent:function(t){return this._container?(t.subtext=t.subtext||"",0!==t.subtext.length||this._singleLineLabel?t.subtext.length>0&&this._singleLineLabel&&(L.DomUtil.removeClass(this._container,"leaflet-draw-tooltip-single"),this._singleLineLabel=!1):(L.DomUtil.addClass(this._container,"leaflet-draw-tooltip-single"),this._singleLineLabel=!0),this._container.innerHTML=(t.subtext.length>0?'<span class="leaflet-draw-tooltip-subtext">'+t.subtext+"</span><br />":"")+"<span>"+t.text+"</span>",this):this},updatePosition:function(t){var e=this._map.latLngToLayerPoint(t),i=this._container;return this._container&&(i.style.visibility="inherit",L.DomUtil.setPosition(i,e)),this},showAsError:function(){return this._container&&L.DomUtil.addClass(this._container,"leaflet-error-draw-tooltip"),this},removeError:function(){return this._container&&L.DomUtil.removeClass(this._container,"leaflet-error-draw-tooltip"),this}}),L.DrawToolbar=L.Toolbar.extend({statics:{TYPE:"draw"},options:{polyline:{},polygon:{},rectangle:{},circle:{},marker:{}},initialize:function(t){for(var e in this.options)this.options.hasOwnProperty(e)&&t[e]&&(t[e]=L.extend({},this.options[e],t[e]));this._toolbarClass="leaflet-draw-draw",L.Toolbar.prototype.initialize.call(this,t)},getModeHandlers:function(t){return[{enabled:this.options.polyline,handler:new L.Draw.Polyline(t,this.options.polyline),title:L.drawLocal.draw.toolbar.buttons.polyline},{enabled:this.options.polygon,handler:new L.Draw.Polygon(t,this.options.polygon),title:L.drawLocal.draw.toolbar.buttons.polygon},{enabled:this.options.rectangle,handler:new L.Draw.Rectangle(t,this.options.rectangle),title:L.drawLocal.draw.toolbar.buttons.rectangle},{enabled:this.options.circle,handler:new L.Draw.Circle(t,this.options.circle),title:L.drawLocal.draw.toolbar.buttons.circle},{enabled:this.options.marker,handler:new L.Draw.Marker(t,this.options.marker),title:L.drawLocal.draw.toolbar.buttons.marker}]},getActions:function(t){return[{enabled:t.deleteLastVertex,title:L.drawLocal.draw.toolbar.undo.title,text:L.drawLocal.draw.toolbar.undo.text,callback:t.deleteLastVertex,context:t},{title:L.drawLocal.draw.toolbar.actions.title,text:L.drawLocal.draw.toolbar.actions.text,callback:this.disable,context:this}]},setOptions:function(t){L.setOptions(this,t);for(var e in this._modes)this._modes.hasOwnProperty(e)&&t.hasOwnProperty(e)&&this._modes[e].handler.setOptions(t[e])}}),L.EditToolbar=L.Toolbar.extend({statics:{TYPE:"edit"},options:{edit:{selectedPathOptions:{color:"#fe57a1",opacity:.6,dashArray:"10, 10",fill:!0,fillColor:"#fe57a1",fillOpacity:.1,maintainColor:!1}},remove:{},featureGroup:null},initialize:function(t){t.edit&&("undefined"==typeof t.edit.selectedPathOptions&&(t.edit.selectedPathOptions=this.options.edit.selectedPathOptions),t.edit.selectedPathOptions=L.extend({},this.options.edit.selectedPathOptions,t.edit.selectedPathOptions)),t.remove&&(t.remove=L.extend({},this.options.remove,t.remove)),this._toolbarClass="leaflet-draw-edit",L.Toolbar.prototype.initialize.call(this,t),this._selectedFeatureCount=0},getModeHandlers:function(t){var e=this.options.featureGroup;return[{enabled:this.options.edit,handler:new L.EditToolbar.Edit(t,{featureGroup:e,selectedPathOptions:this.options.edit.selectedPathOptions}),title:L.drawLocal.edit.toolbar.buttons.edit},{enabled:this.options.remove,handler:new L.EditToolbar.Delete(t,{featureGroup:e}),title:L.drawLocal.edit.toolbar.buttons.remove}]},getActions:function(){return[{title:L.drawLocal.edit.toolbar.actions.save.title,text:L.drawLocal.edit.toolbar.actions.save.text,callback:this._save,context:this},{title:L.drawLocal.edit.toolbar.actions.cancel.title,text:L.drawLocal.edit.toolbar.actions.cancel.text,callback:this.disable,context:this}]},addToolbar:function(t){var e=L.Toolbar.prototype.addToolbar.call(this,t);return this._checkDisabled(),this.options.featureGroup.on("layeradd layerremove",this._checkDisabled,this),e},removeToolbar:function(){this.options.featureGroup.off("layeradd layerremove",this._checkDisabled,this),L.Toolbar.prototype.removeToolbar.call(this)},disable:function(){this.enabled()&&(this._activeMode.handler.revertLayers(),L.Toolbar.prototype.disable.call(this))},_save:function(){this._activeMode.handler.save(),this._activeMode.handler.disable()},_checkDisabled:function(){var t,e=this.options.featureGroup,i=0!==e.getLayers().length;this.options.edit&&(t=this._modes[L.EditToolbar.Edit.TYPE].button,i?L.DomUtil.removeClass(t,"leaflet-disabled"):L.DomUtil.addClass(t,"leaflet-disabled"),t.setAttribute("title",i?L.drawLocal.edit.toolbar.buttons.edit:L.drawLocal.edit.toolbar.buttons.editDisabled)),this.options.remove&&(t=this._modes[L.EditToolbar.Delete.TYPE].button,i?L.DomUtil.removeClass(t,"leaflet-disabled"):L.DomUtil.addClass(t,"leaflet-disabled"),t.setAttribute("title",i?L.drawLocal.edit.toolbar.buttons.remove:L.drawLocal.edit.toolbar.buttons.removeDisabled))}}),L.EditToolbar.Edit=L.Handler.extend({statics:{TYPE:"edit"},includes:L.Mixin.Events,initialize:function(t,e){if(L.Handler.prototype.initialize.call(this,t),this._selectedPathOptions=e.selectedPathOptions,this._featureGroup=e.featureGroup,!(this._featureGroup instanceof L.FeatureGroup))throw new Error("options.featureGroup must be a L.FeatureGroup");this._uneditedLayerProps={},this.type=L.EditToolbar.Edit.TYPE},enable:function(){!this._enabled&&this._hasAvailableLayers()&&(this.fire("enabled",{handler:this.type}),this._map.fire("draw:editstart",{handler:this.type}),L.Handler.prototype.enable.call(this),this._featureGroup.on("layeradd",this._enableLayerEdit,this).on("layerremove",this._disableLayerEdit,this))},disable:function(){this._enabled&&(this._featureGroup.off("layeradd",this._enableLayerEdit,this).off("layerremove",this._disableLayerEdit,this),L.Handler.prototype.disable.call(this),this._map.fire("draw:editstop",{handler:this.type}),this.fire("disabled",{handler:this.type}))},addHooks:function(){var t=this._map;t&&(t.getContainer().focus(),this._featureGroup.eachLayer(this._enableLayerEdit,this),this._tooltip=new L.Tooltip(this._map),this._tooltip.updateContent({text:L.drawLocal.edit.handlers.edit.tooltip.text,subtext:L.drawLocal.edit.handlers.edit.tooltip.subtext}),this._map.on("mousemove",this._onMouseMove,this))},removeHooks:function(){this._map&&(this._featureGroup.eachLayer(this._disableLayerEdit,this),this._uneditedLayerProps={},this._tooltip.dispose(),this._tooltip=null,this._map.off("mousemove",this._onMouseMove,this))},revertLayers:function(){this._featureGroup.eachLayer(function(t){this._revertLayer(t)},this)},save:function(){var t=new L.LayerGroup;this._featureGroup.eachLayer(function(e){e.edited&&(t.addLayer(e),e.edited=!1)}),this._map.fire("draw:edited",{layers:t})},_backupLayer:function(t){var e=L.Util.stamp(t);this._uneditedLayerProps[e]||(t instanceof L.Polyline||t instanceof L.Polygon||t instanceof L.Rectangle?this._uneditedLayerProps[e]={latlngs:L.LatLngUtil.cloneLatLngs(t.getLatLngs())}:t instanceof L.Circle?this._uneditedLayerProps[e]={latlng:L.LatLngUtil.cloneLatLng(t.getLatLng()),radius:t.getRadius()}:t instanceof L.Marker&&(this._uneditedLayerProps[e]={latlng:L.LatLngUtil.cloneLatLng(t.getLatLng())}))},_revertLayer:function(t){var e=L.Util.stamp(t);t.edited=!1,this._uneditedLayerProps.hasOwnProperty(e)&&(t instanceof L.Polyline||t instanceof L.Polygon||t instanceof L.Rectangle?t.setLatLngs(this._uneditedLayerProps[e].latlngs):t instanceof L.Circle?(t.setLatLng(this._uneditedLayerProps[e].latlng),t.setRadius(this._uneditedLayerProps[e].radius)):t instanceof L.Marker&&t.setLatLng(this._uneditedLayerProps[e].latlng))},_toggleMarkerHighlight:function(t){if(t._icon){var e=t._icon;e.style.display="none",L.DomUtil.hasClass(e,"leaflet-edit-marker-selected")?(L.DomUtil.removeClass(e,"leaflet-edit-marker-selected"),this._offsetMarker(e,-4)):(L.DomUtil.addClass(e,"leaflet-edit-marker-selected"),this._offsetMarker(e,4)),e.style.display=""}},_offsetMarker:function(t,e){var i=parseInt(t.style.marginTop,10)-e,o=parseInt(t.style.marginLeft,10)-e;t.style.marginTop=i+"px",t.style.marginLeft=o+"px"},_enableLayerEdit:function(t){var e,i=t.layer||t.target||t,o=i instanceof L.Marker;(!o||i._icon)&&(this._backupLayer(i),this._selectedPathOptions&&(e=L.Util.extend({},this._selectedPathOptions),e.maintainColor&&(e.color=i.options.color,e.fillColor=i.options.fillColor),o?this._toggleMarkerHighlight(i):(i.options.previousOptions=L.Util.extend({dashArray:null},i.options),i instanceof L.Circle||i instanceof L.Polygon||i instanceof L.Rectangle||(e.fill=!1),i.setStyle(e))),o?(i.dragging.enable(),i.on("dragend",this._onMarkerDragEnd)):i.editing.enable())},_disableLayerEdit:function(t){var e=t.layer||t.target||t;e.edited=!1,this._selectedPathOptions&&(e instanceof L.Marker?this._toggleMarkerHighlight(e):(e.setStyle(e.options.previousOptions),delete e.options.previousOptions)),e instanceof L.Marker?(e.dragging.disable(),e.off("dragend",this._onMarkerDragEnd,this)):e.editing.disable()},_onMarkerDragEnd:function(t){var e=t.target;e.edited=!0},_onMouseMove:function(t){this._tooltip.updatePosition(t.latlng)},_hasAvailableLayers:function(){return 0!==this._featureGroup.getLayers().length}}),L.EditToolbar.Delete=L.Handler.extend({statics:{TYPE:"remove"},includes:L.Mixin.Events,initialize:function(t,e){if(L.Handler.prototype.initialize.call(this,t),L.Util.setOptions(this,e),this._deletableLayers=this.options.featureGroup,!(this._deletableLayers instanceof L.FeatureGroup))throw new Error("options.featureGroup must be a L.FeatureGroup");this.type=L.EditToolbar.Delete.TYPE},enable:function(){!this._enabled&&this._hasAvailableLayers()&&(this.fire("enabled",{handler:this.type}),this._map.fire("draw:deletestart",{handler:this.type}),L.Handler.prototype.enable.call(this),this._deletableLayers.on("layeradd",this._enableLayerDelete,this).on("layerremove",this._disableLayerDelete,this))},disable:function(){this._enabled&&(this._deletableLayers.off("layeradd",this._enableLayerDelete,this).off("layerremove",this._disableLayerDelete,this),L.Handler.prototype.disable.call(this),this._map.fire("draw:deletestop",{handler:this.type}),this.fire("disabled",{handler:this.type}))},addHooks:function(){var t=this._map;t&&(t.getContainer().focus(),this._deletableLayers.eachLayer(this._enableLayerDelete,this),this._deletedLayers=new L.layerGroup,this._tooltip=new L.Tooltip(this._map),this._tooltip.updateContent({text:L.drawLocal.edit.handlers.remove.tooltip.text}),this._map.on("mousemove",this._onMouseMove,this))},removeHooks:function(){this._map&&(this._deletableLayers.eachLayer(this._disableLayerDelete,this),this._deletedLayers=null,this._tooltip.dispose(),this._tooltip=null,this._map.off("mousemove",this._onMouseMove,this))},revertLayers:function(){this._deletedLayers.eachLayer(function(t){this._deletableLayers.addLayer(t)},this)},save:function(){this._map.fire("draw:deleted",{layers:this._deletedLayers})},_enableLayerDelete:function(t){var e=t.layer||t.target||t;e.on("click",this._removeLayer,this)},_disableLayerDelete:function(t){var e=t.layer||t.target||t;e.off("click",this._removeLayer,this),this._deletedLayers.removeLayer(e)},_removeLayer:function(t){var e=t.layer||t.target||t;this._deletableLayers.removeLayer(e),this._deletedLayers.addLayer(e)},_onMouseMove:function(t){this._tooltip.updatePosition(t.latlng)},_hasAvailableLayers:function(){return 0!==this._deletableLayers.getLayers().length}})}(window,document);
L.MAP2U.graphchart = function (options) {
    var control = L.control(options);

    control.onAdd = function (map) {
        var $container = $('<div>')
                .attr('class', 'leaflet-control control-graphchart');

        var button = $('<a>')
                .attr('class', 'control-button')
                .attr('href', '#')
                .html('<span class="icon graphchart"></span>')
                .on('click', toggle)
                .appendTo($container);
        this.button=button;
        var $ui = $('<div>')
                .attr('class', 'graphchart-ui');

        $('<div>')
                .attr('class', 'sidebar_heading')
                .appendTo($ui)
                .append(
                        $('<h4>')
                        .text(I18n.t('javascripts.graphchart.title')));
        var barContent = $('<div>')
                .attr('class', 'sidebar_content')
                .appendTo($ui);

        var $section = $('<div>')
                .attr('class', 'section')
                .appendTo(barContent);

        list = $('<ul>')
                .appendTo($section);

        map.dataLayers.forEach(function (layer) {
//        var item = $('<li>')
//        .appendTo(list);
//

        });
        options.sidebar.addPane($ui);
        jQuery(window).resize(function () {
            barContent.height($('.leaflet-sidebar.right').height() - 70);
        });
        update();
        function toggle(e) {
            e.stopPropagation();
            e.preventDefault();
            if (!button.hasClass('disabled')) {
                options.sidebar.togglePane($ui, button);
            }
            $('.leaflet-control .control-button').tooltip('hide');
        }

        function updateButton() {
            var disabled = false;//map.getMapBaseLayerId() !== 'mapnik'
            button
                    .toggleClass('disabled', disabled)
                    .attr('data-original-title', I18n.t(disabled ?
                            'javascripts.graphchart.tooltip_disabled' :
                            'javascripts.graphchart.tooltip'));
        }

        function update() {
            $(".graphchart-ui .sidebar_content div.section").empty();       
            if(control.category===undefined || control.category===null||control.category==='')
                control.disabled = true;
            else
            {
                $("<h5>"+control.category+"</h5>").appendTo($(".graphchart-ui .sidebar_content div.section"));
                
                control.disabled = false;
            }
            button.toggleClass('disabled', control.disabled)
                    .attr('data-original-title', I18n.t(control.disabled ?
                            'javascripts.graphchart.tooltip_disabled' :
                            'javascripts.graphchart.tooltip'));
                    
        }
        control.update=update;
        control.toggle=toggle;
//      $('.mapkey-table-entry').each(function () {
//        var data = $(this).data();
//        if (layer == data.layer && zoom >= data.zoomMin && zoom <= data.zoomMax) {
//          $(this).show();
//        } else {
//          $(this).hide();
//        }
//      });

        control.activate=function(e) {
            var $ui = $('.graphchart-ui');
            if(options.sidebar.isVisible()===false||options.sidebar._currentButton!==this.button)
                control.toggle(e);
        };
        return $container[0];
    };

    return control;
};

L.MAP2U.key = function (options) {
  var control = L.control(options);

  control.onAdd = function (map) {
    var $container = $('<div>')
      .attr('class', 'control-key');

    var button = $('<a>')
      .attr('class', 'control-button')
      .attr('href', '#')
      .html('<span class="icon key"></span>')
      .on('click', toggle)
      .appendTo($container);

    var $ui = $('<div>')
      .attr('class', 'key-ui');

    $('<div>')
      .attr('class', 'sidebar_heading')
      .appendTo($ui)
      .append(
        $('<span>')
          .text(I18n.t('javascripts.close'))
          .attr('class', 'icon close')
          .bind('click', toggle))
      .append(
        $('<h4>')
          .text(I18n.t('javascripts.key.title')));

    var $section = $('<div>')
      .attr('class', 'section')
      .appendTo($ui);

    options.sidebar.addPane($ui);

    $ui
      .on('show', shown)
      .on('hide', hidden);

    map.on('baselayerchange', updateButton);

    updateButton();

    function shown() {
      map.on('zoomend baselayerchange', update);
      $section.load('/key', update);
    }

    function hidden() {
      map.off('zoomend baselayerchange', update);
    }

    function toggle(e) {
      e.stopPropagation();
      e.preventDefault();
      if (!button.hasClass('disabled')) {
        options.sidebar.togglePane($ui, button);
      }
      $('.leaflet-control .control-button').tooltip('hide');
    }

    function updateButton() {
      var disabled = false;//map.getMapBaseLayerId() !== 'mapnik'
      button
        .toggleClass('disabled', disabled)
        .attr('data-original-title', I18n.t(disabled ?
          'javascripts.key.tooltip_disabled' :
          'javascripts.key.tooltip'))
    }

    function update() {
      var layer = map.getMapBaseLayerId(),
        zoom = map.getZoom();

      $('.mapkey-table-entry').each(function () {
        var data = $(this).data();
        if (layer == data.layer && zoom >= data.zoomMin && zoom <= data.zoomMax) {
          $(this).show();
        } else {
          $(this).hide();
        }
      });
    }

    return $container[0];
  };

  return control;
};

/*
	Leaflet.label, a plugin that adds labels to markers and vectors for Leaflet powered maps.
	(c) 2012-2013, Jacob Toye, Smartrak

	https://github.com/Leaflet/Leaflet.label
	http://leafletjs.com
	https://github.com/jacobtoye
*/
(function(){L.labelVersion="0.2.2-dev",L.Label=L.Class.extend({includes:L.Mixin.Events,options:{className:"",clickable:!1,direction:"right",noHide:!1,offset:[12,-15],opacity:1,zoomAnimation:!0},initialize:function(t,e){L.setOptions(this,t),this._source=e,this._animated=L.Browser.any3d&&this.options.zoomAnimation,this._isOpen=!1},onAdd:function(t){this._map=t,this._pane=this._source instanceof L.Marker?t._panes.markerPane:t._panes.popupPane,this._container||this._initLayout(),this._pane.appendChild(this._container),this._initInteraction(),this._update(),this.setOpacity(this.options.opacity),t.on("moveend",this._onMoveEnd,this).on("viewreset",this._onViewReset,this),this._animated&&t.on("zoomanim",this._zoomAnimation,this),L.Browser.touch&&!this.options.noHide&&L.DomEvent.on(this._container,"click",this.close,this)},onRemove:function(t){this._pane.removeChild(this._container),t.off({zoomanim:this._zoomAnimation,moveend:this._onMoveEnd,viewreset:this._onViewReset},this),this._removeInteraction(),this._map=null},setLatLng:function(t){return this._latlng=L.latLng(t),this._map&&this._updatePosition(),this},setContent:function(t){return this._previousContent=this._content,this._content=t,this._updateContent(),this},close:function(){var t=this._map;t&&(L.Browser.touch&&!this.options.noHide&&L.DomEvent.off(this._container,"click",this.close),t.removeLayer(this))},updateZIndex:function(t){this._zIndex=t,this._container&&this._zIndex&&(this._container.style.zIndex=t)},setOpacity:function(t){this.options.opacity=t,this._container&&L.DomUtil.setOpacity(this._container,t)},_initLayout:function(){this._container=L.DomUtil.create("div","leaflet-label "+this.options.className+" leaflet-zoom-animated"),this.updateZIndex(this._zIndex)},_update:function(){this._map&&(this._container.style.visibility="hidden",this._updateContent(),this._updatePosition(),this._container.style.visibility="")},_updateContent:function(){this._content&&this._map&&this._prevContent!==this._content&&"string"==typeof this._content&&(this._container.innerHTML=this._content,this._prevContent=this._content,this._labelWidth=this._container.offsetWidth)},_updatePosition:function(){var t=this._map.latLngToLayerPoint(this._latlng);this._setPosition(t)},_setPosition:function(t){var e=this._map,i=this._container,n=e.latLngToContainerPoint(e.getCenter()),o=e.layerPointToContainerPoint(t),s=this.options.direction,a=this._labelWidth,l=L.point(this.options.offset);"right"===s||"auto"===s&&o.x<n.x?(L.DomUtil.addClass(i,"leaflet-label-right"),L.DomUtil.removeClass(i,"leaflet-label-left"),t=t.add(l)):(L.DomUtil.addClass(i,"leaflet-label-left"),L.DomUtil.removeClass(i,"leaflet-label-right"),t=t.add(L.point(-l.x-a,l.y))),L.DomUtil.setPosition(i,t)},_zoomAnimation:function(t){var e=this._map._latLngToNewLayerPoint(this._latlng,t.zoom,t.center).round();this._setPosition(e)},_onMoveEnd:function(){this._animated&&"auto"!==this.options.direction||this._updatePosition()},_onViewReset:function(t){t&&t.hard&&this._update()},_initInteraction:function(){if(this.options.clickable){var t=this._container,e=["dblclick","mousedown","mouseover","mouseout","contextmenu"];L.DomUtil.addClass(t,"leaflet-clickable"),L.DomEvent.on(t,"click",this._onMouseClick,this);for(var i=0;e.length>i;i++)L.DomEvent.on(t,e[i],this._fireMouseEvent,this)}},_removeInteraction:function(){if(this.options.clickable){var t=this._container,e=["dblclick","mousedown","mouseover","mouseout","contextmenu"];L.DomUtil.removeClass(t,"leaflet-clickable"),L.DomEvent.off(t,"click",this._onMouseClick,this);for(var i=0;e.length>i;i++)L.DomEvent.off(t,e[i],this._fireMouseEvent,this)}},_onMouseClick:function(t){this.hasEventListeners(t.type)&&L.DomEvent.stopPropagation(t),this.fire(t.type,{originalEvent:t})},_fireMouseEvent:function(t){this.fire(t.type,{originalEvent:t}),"contextmenu"===t.type&&this.hasEventListeners(t.type)&&L.DomEvent.preventDefault(t),"mousedown"!==t.type?L.DomEvent.stopPropagation(t):L.DomEvent.preventDefault(t)}}),L.BaseMarkerMethods={showLabel:function(){return this.label&&this._map&&(this.label.setLatLng(this._latlng),this._map.showLabel(this.label)),this},hideLabel:function(){return this.label&&this.label.close(),this},setLabelNoHide:function(t){this._labelNoHide!==t&&(this._labelNoHide=t,t?(this._removeLabelRevealHandlers(),this.showLabel()):(this._addLabelRevealHandlers(),this.hideLabel()))},bindLabel:function(t,e){var i=this.options.icon?this.options.icon.options.labelAnchor:this.options.labelAnchor,n=L.point(i)||L.point(0,0);return n=n.add(L.Label.prototype.options.offset),e&&e.offset&&(n=n.add(e.offset)),e=L.Util.extend({offset:n},e),this._labelNoHide=e.noHide,this.label||(this._labelNoHide||this._addLabelRevealHandlers(),this.on("remove",this.hideLabel,this).on("move",this._moveLabel,this).on("add",this._onMarkerAdd,this),this._hasLabelHandlers=!0),this.label=new L.Label(e,this).setContent(t),this},unbindLabel:function(){return this.label&&(this.hideLabel(),this.label=null,this._hasLabelHandlers&&(this._labelNoHide||this._removeLabelRevealHandlers(),this.off("remove",this.hideLabel,this).off("move",this._moveLabel,this).off("add",this._onMarkerAdd,this)),this._hasLabelHandlers=!1),this},updateLabelContent:function(t){this.label&&this.label.setContent(t)},getLabel:function(){return this.label},_onMarkerAdd:function(){this._labelNoHide&&this.showLabel()},_addLabelRevealHandlers:function(){this.on("mouseover",this.showLabel,this).on("mouseout",this.hideLabel,this),L.Browser.touch&&this.on("click",this.showLabel,this)},_removeLabelRevealHandlers:function(){this.off("mouseover",this.showLabel,this).off("mouseout",this.hideLabel,this),L.Browser.touch&&this.off("click",this.showLabel,this)},_moveLabel:function(t){this.label.setLatLng(t.latlng)}},L.Icon.Default.mergeOptions({labelAnchor:new L.Point(9,-20)}),L.Marker.mergeOptions({icon:new L.Icon.Default}),L.Marker.include(L.BaseMarkerMethods),L.Marker.include({_originalUpdateZIndex:L.Marker.prototype._updateZIndex,_updateZIndex:function(t){var e=this._zIndex+t;this._originalUpdateZIndex(t),this.label&&this.label.updateZIndex(e)},_originalSetOpacity:L.Marker.prototype.setOpacity,setOpacity:function(t,e){this.options.labelHasSemiTransparency=e,this._originalSetOpacity(t)},_originalUpdateOpacity:L.Marker.prototype._updateOpacity,_updateOpacity:function(){var t=0===this.options.opacity?0:1;this._originalUpdateOpacity(),this.label&&this.label.setOpacity(this.options.labelHasSemiTransparency?this.options.opacity:t)},_originalSetLatLng:L.Marker.prototype.setLatLng,setLatLng:function(t){return this.label&&!this._labelNoHide&&this.hideLabel(),this._originalSetLatLng(t)}}),L.CircleMarker.mergeOptions({labelAnchor:new L.Point(0,0)}),L.CircleMarker.include(L.BaseMarkerMethods),L.Path.include({bindLabel:function(t,e){return this.label&&this.label.options===e||(this.label=new L.Label(e,this)),this.label.setContent(t),this._showLabelAdded||(this.on("mouseover",this._showLabel,this).on("mousemove",this._moveLabel,this).on("mouseout remove",this._hideLabel,this),L.Browser.touch&&this.on("click",this._showLabel,this),this._showLabelAdded=!0),this},unbindLabel:function(){return this.label&&(this._hideLabel(),this.label=null,this._showLabelAdded=!1,this.off("mouseover",this._showLabel,this).off("mousemove",this._moveLabel,this).off("mouseout remove",this._hideLabel,this)),this},updateLabelContent:function(t){this.label&&this.label.setContent(t)},_showLabel:function(t){this.label.setLatLng(t.latlng),this._map.showLabel(this.label)},_moveLabel:function(t){this.label.setLatLng(t.latlng)},_hideLabel:function(){this.label.close()}}),L.Map.include({showLabel:function(t){return this.addLayer(t)}}),L.FeatureGroup.include({clearLayers:function(){return this.unbindLabel(),this.eachLayer(this.removeLayer,this),this},bindLabel:function(t,e){return this.invoke("bindLabel",t,e)},unbindLabel:function(){return this.invoke("unbindLabel")},updateLabelContent:function(t){this.invoke("updateLabelContent",t)}})})(this,document);



L.MAP2U.layers = function (options) {
    var control = L.control(options);
    control.onAdd = function (map) {
        var layers = options.layers;
        this._map = map;
        var $container = $('<div>')
                .attr('class', 'control-layers');
        var button = $('<a>')
                .attr('class', 'control-button')
                .attr('href', '#')
                .attr('title', I18n.t('javascripts.map.layers.title'))
                .html('<span class="icon layers"></span>')
                .on('click', toggle)
                .appendTo($container);
        var $ui = $('<div>')
                .attr('class', 'layers-ui');
        $('<div>')
                .attr('class', 'sidebar_heading')
                .appendTo($ui)
                .append(
                        $('<h4>')
                        .text(I18n.t('javascripts.map.layers.header')));
        var barContent = $('<div>')
                .attr('class', 'sidebar_content')
                .appendTo($ui);
        var baseSection = $('<div>')
                .attr('class', 'section')
                .appendTo(barContent);
        $('<p>')
                .text(I18n.t('javascripts.map.layers.baselayers'))
                .attr("class", "deemphasize")
                .appendTo(baseSection);
        list = $('<ul>')
                .appendTo(baseSection);
        layers.forEach(function (layer) {
            var item = $('<li>')
                    .appendTo(list);
            if (map.hasLayer(layer.layer)) {
                item.addClass('active');
            }

//      var div = $('<div>')
//        .appendTo(item);

//      map.whenReady(function() {
//        var miniMap = L.map(div[0], {attributionControl: false, zoomControl: false})
//          .addLayer(new layer.constructor());
//
//        miniMap.dragging.disable();
//        miniMap.touchZoom.disable();
//        miniMap.doubleClickZoom.disable();
//        miniMap.scrollWheelZoom.disable();
//
//        $ui
//          .on('show', shown)
//          .on('hide', hide);
//
//        function shown() {
//          miniMap.invalidateSize();
//          setView({animate: false});
//          map.on('moveend', moved);
//        }
//
//        function hide() {
//          map.off('moveend', moved);
//        }
//
//        function moved() {
//          setView();
//        }
//
//        function setView(options) {
//          miniMap.setView(map.getCenter(), Math.max(map.getZoom() - 2, 0), options);
//        }
//      });

            var label = $('<label>')
                    .appendTo(item);
            var input = $('<input>')
                    .attr('type', 'radio')
                    .prop('checked', map.hasLayer(layer.layer))
                    .appendTo(label);
            label.append(layer.layerName);
            item.on('click', function () {
                layers.forEach(function (other) {
                    if (other.layer === layer.layer) {
                        map.addLayer(other.layer);
                        // google map does not support this function
                        if (other.layer.bringToBack !== undefined)
                            other.layer.bringToBack();
                    } else {
                        map.removeLayer(other.layer);
                    }
                });
                map.fire('baselayerchange', {layer: layer.layer});
            });
            map.on('layeradd layerremove', function () {
                item.toggleClass('active', map.hasLayer(layer.layer));
                input.prop('checked', map.hasLayer(layer.layer));
            });
        });
        //     if (OSM.STATUS != 'api_offline' && OSM.STATUS != 'database_offline') {
        var overlaySection = $('<div>')
                .attr('class', 'section overlay-layers')
                .appendTo(barContent);
        $('<p>')
                .text(I18n.t('javascripts.map.layers.overlays'))
                .attr("class", "deemphasize")
                .appendTo(overlaySection);
        if (options.buttons === undefined) {
            overlaySection.find('.deemphasize')
                    .append('<div class="overlayers_btn disabled" id="move_overlayer_up"><i class="fa fa-chevron-up"></i></div>')
                    .append('<div class="overlayers_btn disabled" id="move_overlayer_down"><i class="fa fa-chevron-down"></i></div>')
                    .append('<div class="overlayers_btn" id="save_overlayers_index"><i class="fa fa-save"></i></div>')
                    .append('<div class="overlayers_btn disabled" id="overlayers_minus"><i class="fa fa-minus"></i></div>')
                    .append('<div class="overlayers_btn" id="overlayers_plus"><i class="fa fa-plus"></i></div>')
                    .append('<div class="overlayers_btn" id="overlayers_unselectall"><i class="fa fa-times"></i></div>')
                    .append('<div class="overlayers_btn" id="overlayers_selectall"><i class="fa fa-check"></i></div>')
                    .append('<div class="overlayers_btn disabled" id="overlayers_zoom_to_layer"><i class="fa fa-globe"></i></div>')
                    .css('border-bottom', '1px grey dotted');

        }
        else {
            if (options.buttons.up === true) {
                overlaySection.find('.deemphasize')
                        .append('<div class="overlayers_btn disabled" id="move_overlayer_up"><i class="fa fa-chevron-up"></i></div>');
            }
            if (options.buttons.down === true) {
                overlaySection.find('.deemphasize')
                        .append('<div class="overlayers_btn disabled" id="move_overlayer_down"><i class="fa fa-chevron-down"></i></div>');

            }
            if (options.buttons.save === true) {
                overlaySection.find('.deemphasize')
                        .append('<div class="overlayers_btn" id="save_overlayers_index"><i class="fa fa-save"></i></div>');
            }
            if (options.buttons.minus === true) {
                overlaySection.find('.deemphasize')
                        .append('<div class="overlayers_btn disabled" id="overlayers_minus"><i class="fa fa-minus"></i></div>');

            }
            if (options.buttons.plus === true) {
                overlaySection.find('.deemphasize')
                        .append('<div class="overlayers_btn" id="overlayers_plus"><i class="fa fa-plus"></i></div>');

            }
            if (options.buttons.unselectall === true) {
                overlaySection.find('.deemphasize')
                        .append('<div class="overlayers_btn" id="overlayers_unselectall"><i class="fa fa-times"></i></div>');

            }
            if (options.buttons.selectall === true) {
                overlaySection.find('.deemphasize')
                        .append('<div class="overlayers_btn" id="overlayers_selectall"><i class="fa fa-check"></i></div>');

            }
            if (options.buttons.zoom === true) {
                overlaySection.find('.deemphasize')
                        .append('<div class="overlayers_btn disabled" id="overlayers_zoom_to_layer"><i class="fa fa-globe"></i></div>');

            }
            overlaySection.find('.deemphasize')
                    .css('border-bottom', '1px grey dotted');
        }

        var list = $('<ul class="overlay_ul">')
                .appendTo(overlaySection);
        function addOverlay(layer, activeLayerSelect, maxArea) {
            var item = $('<li>')
                    .tooltip({
                        placement: 'top'
                    })
                    .appendTo(list);
            var label = $('<label>')
                    .appendTo(item);
            var checked = map.hasLayer(layer.layer);
            var input = $('<input>')
                    .attr('type', 'checkbox')
                    .prop('checked', checked)
                    .appendTo(label);
//       var input_radio = $('<input>')
//          .attr('type', 'radio')
//          .attr('name','activeLayer[]')
//          .prop('checked', false)
//          .appendTo(label);


            //       label.append(I18n.t('javascripts.map.layers.' + name));

            var label_name = I18n.t('javascripts.map.layers.' + layer.layerTitle);
            if (label_name.indexOf('missing ') === 1)
            {
                label.append(layer.layerTitle);
                activeLayerSelect.append("<option value='" + layer.layerId + "'>" + layer.layerTitle + "</option>");
            }
            else
            {
                label.append(label_name);
                activeLayerSelect.append("<option value='" + layer.layerId + "'>" + label_name + "</option>");
            }

            input.on('change', function () {
                checked = input.is(':checked');
                if (checked) {
                    if (!layer.layer)
                    {
                        control.loadLayer(layer);
//                        control.loadGeoJSONLayer(layer);
                        //    control.loadTopoJSONLayer(layer);
                    }
                    else
                    {
//                        if (layer.type === 'geojson' || layer.name === 'My draw geometries') {
//                            //                           control.loadGeoJSONLayer(layer);
//                            control.loadTopoJSONLayer(layer);
//                        }
                        if (layer.layer)
                            map.addLayer(layer.layer);
                    }
                } else {
//                    if (layer.type === 'shapefile_topojson') {
//
//
//                    }
//                    if (layer.type === 'geojson' || layer.name === 'My draw geometries') {
//
//                    }
                    if (layer.layer)
                        map.removeLayer(layer.layer);
                }
                if (layer.layer)
                    map.fire('overlaylayerchange', {layer: layer.layer});
            });
            if (layer.type === 'shapefile_topojson')
            {
                var ul = $('<ul>');
                var li_showlabel = $('<li>');
                ul.append(li_showlabel);
                label.append("<br>");
                item.append(ul);
                var showlabel = $('<label>')
                        .appendTo(li_showlabel);
                var showlabel_input = $('<input>')
                        .attr('type', 'checkbox')
                        .prop('checked', checked)
                        .appendTo(showlabel);
                showlabel.append("Labels");
                showlabel_input.on('change', function () {
                    checked = showlabel_input.is(':checked');
                    if (layer.layer)
                    {
                        layer.layer.options.showLabels = checked;
                        if (checked) {
                            var kename = '';
                            var field_kename = [];
                            var shapefilename = $('.sonata-bc #shapefile_select_list option:selected').map(function () {
                                return  this.text;
                            });
                            // only current map is the same with shapefile list selected file name
                            if (shapefilename === '' || shapefilename[0] === undefined || layer.layer.options.name === shapefilename[0].toLowerCase())
                            {
                                field_kename = $('.sonata-bc #shapefile_labelfield_list option:selected').map(function () {
                                    return  this.text;
                                });
                            }
                            if (field_kename.length === 0 && layer.layer.options.label_field !== '' && layer.layer.options.label_field !== null) {
                                kename = layer.layer.options.label_field;
                            }
                            else
                            {
                                if (field_kename[0] === '' || field_kename[0] === null)
                                    kename = undefined;
                                else
                                    kename = field_kename[0];
                            }
                            layer.layer.showFeatureLabels(kename);
                        } else {
                            layer.layer.removeFeatureLabels();
                        }
                    }
                });
            }


            if (layer.defaultShowOnMap === true)
            {
                $(input).prop('checked', true)
                        .trigger('change');
            }


//                input.on('change', function() {
//                    checked = input.is(':checked');
//                    if (checked) {
//                        map.addLayer(layer.layer);
//                    } else {
//                        map.removeLayer(layer.layer);
//                    }
//                    map.fire('overlaylayerchange', {layer: layer.layer});
//                });
//                

//        input_radio.on('click', function() {
//            input_radio.prop('checked',true);
//        });
//        map.on('layeradd layerremove', function() {
//          input.prop('checked', map.hasLayer(layer));
//        });

            map.on('zoomend', function () {
                // alert(map.getBounds().toBBoxString());
                // alert(maxArea);

                var disabled = false; //map.getBounds().getSize() >= maxArea;
                $(input).prop('disabled', disabled);
                if (disabled && $(input).is(':checked')) {
                    $(input).prop('checked', false)
                            .trigger('change');
                    checked = true;
                } else if (!disabled && !$(input).is(':checked') && checked) {
                    $(input).prop('checked', true)
                            .trigger('change');
                }

                $(item).attr('class', disabled ? 'disabled' : '');
                item.attr('data-original-title', disabled ?
                        I18n.t('javascripts.site.map_' + layer.layerName + '_zoom_in_tooltip') : '');
            });
        }
        map.dataLayers.forEach(function (layer) {
            addOverlay(layer, activeLayerSelect, OSM.MAX_NOTE_REQUEST_AREA);
        });
//      addOverlay(map.noteLayer, 'notes', OSM.MAX_NOTE_REQUEST_AREA);
//      addOverlay(map.dataLayer, 'data', OSM.MAX_REQUEST_AREA);
        //    }

        options.sidebar.addPane($ui);
        jQuery(window).resize(function () {
            barContent.height($('.leaflet-sidebar.right').height() - 70);
        });
        function toggle(e) {
            e.stopPropagation();
            e.preventDefault();
            options.sidebar.togglePane($ui, button);
            $('.leaflet-control .control-button').tooltip('hide');
        }
        return $container[0];
    };
    control.reorderLayers = function () {
        var layers = this._map.dataLayers;
        var showUserDraw = false;
        var activelayer = $("div.sidebar_content div.section.overlay-layers ul.overlay_ul > li.overlay_li.selected");
        $("div.sidebar_content div.section.overlay-layers ul.overlay_ul > li.overlay_li").map(function (i) {

            $(this).data('index', i);


            if (layers[$(this).data('index')].index_id !== undefined) {
                if (activelayer.data("index") !== undefined && parseInt(activelayer.data("index")) === parseInt($(this).data('index'))) {


                    if (layers[$(this).data('index')].layerType === 'group' && layers[$(this).data('index')].filename === 'userdrawlayer-group') {
                        $(this).find("li.overlay_group_li").map(function () {
                            var layerId = $(this).data("layerId");
                            var layerName = $(this).data("layerName");
                            var groupName = $(this).data("groupName");
                            window.map.eachLayer(function (layer) {
                                if (layerId !== undefined && layerName !== undefined && groupName !== undefined && layer.layerId === layerId && layer.layerName === layerName && layer.groupName === groupName) {
                                    layer.bringToFront();
                                }
                                ;
                            });
                        });
                        showUserDraw = true;
                        $(".leaflet-map-pane .leaflet-objects-pane .leaflet-overlay-pane svg.leaflet-zoom-animated").css('z-index', 901);
                    }
                    else {
                        if (parseInt(layers[$(this).data('index')].index_id) === -1)
                        {
                            if (layers[$(this).data('index')].layer) {
                                $(".leaflet-map-pane .leaflet-objects-pane .leaflet-overlay-pane svg.leaflet-zoom-animated").css('z-index', 901);
                            }
                        }
                        else {
                            if (layers[$(this).data('index')].layer !== null && layers[$(this).data('index')].layer !== undefined) {


                                if ((layers[$(this).data('index')].layer instanceof  L.MarkerClusterGroup) === true)
                                {
                                    //  alert(map.dataLayers[i].layer._el);
                                    var clusterlayers = layers[$(this).data('index')].layer._featureGroup._layers;
                                    var keys = Object.keys(clusterlayers).map(function (k) {
                                        return  k;
                                    });
                                    if (clusterlayers[keys[0]] && clusterlayers[keys[0]]._container)
                                        $(clusterlayers[keys[0]]._container).parent().css("z-index", 901);
                                }
                                else {
                                    if ((layers[$(this).data('index')].layer instanceof  L.MarkerClusterGroup) === true) {
                                        var clusterlayers = layers[$(this).data('index')].layer._featureGroup._layers;
                                        var keys = Object.keys(clusterlayers).map(function (k) {
                                            return  k;
                                        });
                                        if (clusterlayers[keys[0]] && clusterlayers[keys[0]]._container)
                                            $(clusterlayers[keys[0]]._container).parent().css("z-index", 901);
                                    }
                                    else {
                                        if (layers[$(this).data('index')].layer && layers[$(this).data('index')].layer._container) {
                                            $(layers[$(this).data('index')].layer._container).css("z-index", 901);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                else {
                    if (layers[$(this).data('index')].layerType === 'group' && layers[$(this).data('index')].filename === 'userdrawlayer-group') {
                        $(this).find("li.overlay_group_li").map(function () {
                            var layerId = $(this).data("layerId");
                            var layerName = $(this).data("layerName");
                            var groupName = $(this).data("groupName");
                            window.map.eachLayer(function (layer) {
                                if (layerId !== undefined && layerName !== undefined && groupName !== undefined && layer.layerId === layerId && layer.layerName === layerName && layer.groupName === groupName) {
                                    layer.bringToBack();
                                }
                                ;
                            });
                        });
                        if (showUserDraw === false)
                            $(".leaflet-map-pane .leaflet-objects-pane .leaflet-overlay-pane svg.leaflet-zoom-animated").css('z-index', 301 - i);
                    }
                    else {
                        // if the layer is user draw layer
                        if (parseInt(layers[$(this).data('index')].index_id) === -1) {
                            if (layers[$(this).data('index')].layer) {
                                $(".leaflet-map-pane .leaflet-objects-pane .leaflet-overlay-pane svg.leaflet-zoom-animated").css('z-index', 300 - i);
                            }
                        }
                        else {
                            if (layers[$(this).data('index')].layer !== null && layers[$(this).data('index')].layer !== undefined)
                            {
                                if ((layers[$(this).data('index')].layer instanceof  L.MarkerClusterGroup) === true)
                                {
                                    //  alert(map.dataLayers[i].layer._el);
                                    var clusterlayers = layers[$(this).data('index')].layer._featureGroup._layers;
                                    var keys = Object.keys(clusterlayers).map(function (k) {
                                        return  k;
                                    });
                                    if (clusterlayers[keys[0]] && clusterlayers[keys[0]]._container)
                                        $(clusterlayers[keys[0]]._container).parent().css("z-index", 300 - i);
                                }
                                else {
                                    if ((layers[$(this).data('index')].layer instanceof  L.MarkerClusterGroup) === true) {
                                        var clusterlayers = layers[$(this).data('index')].layer._featureGroup._layers;
                                        var keys = Object.keys(clusterlayers).map(function (k) {
                                            return  k;
                                        });
                                        if (clusterlayers[keys[0]] && clusterlayers[keys[0]]._container)
                                            $(clusterlayers[keys[0]]._container).parent().css("z-index", 300 - i);
                                    }
                                    else {
                                        if (layers[$(this).data('index')].layer && layers[$(this).data('index')].layer._container) {
                                            $(layers[$(this).data('index')].layer._container).css("z-index", 300 - i);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        });
    };

    control.renderThematicmap = function (opt) {
        var _this = this;
        var maploaded = false;
        var thematicmap_layer;
        _this._map.dataLayers.forEach(function (layer) {
            if (layer.layerType === 'thematicmap' && layer.datasource === opt.datasource && layer.layerId === opt.layerId) {
                maploaded = true;
                thematicmap_layer = layer;
            }
        });
        if (maploaded === false || (maploaded === true && thematicmap_layer && !thematicmap_layer.layer)) {

            this.addUploadfile(Routing.generate('default_uploadfile_info', {'_locale': window.locale}), opt.datasource, opt);

        }

        if (thematicmap_layer && thematicmap_layer.layer && thematicmap_layer.layer.renderThematicMap) {
            thematicmap_layer.layer.options.thematicmap = true;
            thematicmap_layer.layer.options.thematicmap_rule = opt;
            thematicmap_layer.layer.renderThematicMap(opt);
        }

    };
    control.renderThematicMapLayer = function (thematicmap_layer, opt) {
        if (thematicmap_layer && thematicmap_layer.layer && thematicmap_layer.layer.renderThematicMap) {
            thematicmap_layer.layer.options.thematicmap = true;
            thematicmap_layer.layer.options.thematicmap_rule = opt;
            thematicmap_layer.layer.renderThematicMap(opt);
        }
    };
    control.loadLayerInfoFromSource = function (id, type) {
        var result;
        var _this = this;

        $.ajax({
            url: Routing.generate('leaflet_maplayerinfo', {'_locale': window.locale}),
            type: 'GET',
            beforeSend: function () {

                _this._map.spin(true);
            },
            complete: function () {
                _this._map.spin(false);
            },
            error: function () {
                _this._map.spin(false);
            },
            //Ajax events
            success: completeHandler = function (response) {
                result = response;
                if (response === '' || response === undefined || response === null)
                    return;
                if (typeof result !== 'object')
                    result = JSON.parse(result);
                if (result.success !== true) {
                    // if load data not suceess
                    alert(result.message);
                    return;
                }
                if (typeof result.layer === 'string')
                    result.layer = JSON.parse(result.layer);

                var layer = {'defaultShowOnMap': true, 'layerType': result.layer.layerType, 'layer': null, 'minZoom': null, 'maxZoom': null, 'index_id': _this._map.dataLayers.length + 1, 'srs': result.layer.srs, 'layerId': result.layer.id, 'layerTitle': result.layer.layerTitle, 'datasource': result.layer.datasource, 'filename': result.layer.fileName, 'layerName': result.layer.layerName, type: result.layer.datatype};
                if (result.layer.opt !== undefined && typeof result.layer.opt !== 'object')
                    result.layer.opt = JSON.parse(result.layer.opt);

                _this._map.dataLayers[_this._map.dataLayers.length] = layer;
                _this.addOverlayItem(layer, _this._map.dataLayers.length - 1, result.layer.opt);

//                ;
//                switch (result.datatype) {
//                    case 'topojson':
//                        control.RenderTopojsonLayer(result, layer, opt);
//                        break;
//                    case 'geojson':
//
//                        control.RenderGeojsonLayer(result, layer, opt);
//                        break;
//                }

            },
            // Form data
            data: {id: id, layerType: type},
            //Options to tell JQuery not to process data or worry about content-type
            cache: false,
            contentType: false
        });

    };
    // load layer data from server aand create layers based on layer type;
    control.loadLayer = function (layer, opt) {

        var result;
        var _this = this;

        if (layer.layerType === 'wms') {
            control.renderWMSLayer(layer);
            return;
        }
        if (layer.layerType === 'wfs') {
            control.renderWFSLayer(layer);
            return;
        }
        if (layer.layerType === 'group') {
            control.renderGroupLayer(layer);
            return;
        }


        $.ajax({
            url: Routing.generate('leaflet_maplayer', {'_locale': window.locale}),
            type: 'GET',
            beforeSend: function () {

                _this._map.spin(true);
            },
            complete: function () {
                _this._map.spin(false);
            },
            error: function () {
                _this._map.spin(false);
            },
            //Ajax events
            success: completeHandler = function (response) {

                result = response;
                if (response === '' || response === undefined || response === null)
                    return;
                if (typeof result !== 'object')
                    result = JSON.parse(result);
                if (result.success !== true) {
                    // if load data not suceess
                    alert(result.message);
                    return;
                }
                ;
                switch (result.datatype) {
                    case 'topojson':
                        control.RenderTopojsonLayer(result, layer, opt);
                        break;
                    case 'geojson':

                        control.RenderGeojsonLayer(result, layer, opt);
                        break;
                }

            },
            // Form data
            data: {id: layer.layerId, layerType: layer.layerType, public: layer.public},
            //Options to tell JQuery not to process data or worry about content-type
            cache: false,
            contentType: false
        });

        return;
    };
    control.addUploadfile = function (getlayerdata_url, uploadfile_id, opt) {

        var _this = this;
//        if (options.spinner !== undefined && options.spinner !== null && options.spinner_target !== undefined && options.spinner_target !== null) {
//            options.spinner.spin(options.spinner_target);
//        }
        //       spinner.spin(spinner_target);
        var maplayer;

        $.ajax({
            url: getlayerdata_url,
            type: 'GET',
            beforeSend: function () {

                _this._map.spin(true);
            },
            complete: function () {
                _this._map.spin(false);
            },
            error: function () {
                _this._map.spin(false);
            },
            //Ajax events
            success: completeHandler = function (response) {

                var result;
                if (typeof response === 'object') {
                    result = response;
                } else {
                    result = JSON.parse(response);
                }

                if (result.success === true) {
                    var layers = options.layers;
                    layers.forEach(function (layer) {
                        // if this file already exist, delete it first
                        if (result.uploadfile && layer.filename === result.uploadfile.filename) {

                        }
                    });
                    var fileExist = false;
                    _this._map.dataLayers.forEach(function (layer) {
                        if (result.uploadfile && layer.layerId === result.uploadfile.id && layer.layerType === result.uploadfile.layerType && layer.filename === result.uploadfile.filename) {
                            fileExist = true;
                            maplayer = layer;
                        }
                    });
                    if (fileExist === false && result.uploadfile) {
                        if (result.uploadfile.layerType !== 'userdraw' && result.uploadfile.layerType !== 'userdrawlayer') {
                            _this._map.dataLayers[_this._map.dataLayers.length] = {'defaultShowOnMap': true, 'layerType': 'uploadfile', 'layer': null, 'minZoom': null, 'maxZoom': null, 'index_id': _this._map.dataLayers.length + 1, 'srs': result.uploadfile.srs, 'layerId': result.uploadfile.id, 'layerTitle': result.uploadfile.filename, 'datasource': result.uploadfile.datasource, 'filename': result.uploadfile.filename, 'layerName': result.uploadfile.filename, type: 'topojson'};
                            maplayer = _this._map.dataLayers[_this._map.dataLayers.length - 1];
                            _this.addOverlayItem(maplayer, _this._map.dataLayers.length - 1, opt);

//                        if (maplayer.type === 'shapefile_topojson')
//                        {
//                            var ul = $('<ul>');
//                            var li_showlabel = $('<li>');
//                            ul.append(li_showlabel);
//                            label.append("<br>");
//                            item.append(ul);
//                            var showlabel = $('<label>')
//                                    .appendTo(li_showlabel);
//                            var showlabel_input = $('<input>')
//                                    .attr('type', 'checkbox')
//                                    .prop('checked', checked)
//                                    .appendTo(showlabel);
//                            showlabel.append("Labels");
//                            showlabel_input.on('change', function () {
//                                checked = showlabel_input.is(':checked');
//                                if (maplayer.layer)
//                                {
//                                    maplayer.layer.options.showLabels = checked;
//                                    if (checked) {
//                                        var kename = '';
//                                        var field_kename = [];
//                                        var shapefilename = $('.sonata-bc #shapefile_select_list option:selected').map(function () {
//                                            return  this.text;
//                                        });
//                                        // only current map is the same with shapefile list selected file name
//                                        if (shapefilename === '' || shapefilename[0] === undefined || maplayer.layer.options.name === shapefilename[0].toLowerCase())
//                                        {
//                                            field_kename = $('.sonata-bc #shapefile_labelfield_list option:selected').map(function () {
//                                                return  this.text;
//                                            });
//                                        }
//                                        if (field_kename.length === 0 && maplayer.layer.options.label_field !== '' && maplayer.layer.options.label_field !== null) {
//                                            kename = maplayer.layer.options.label_field;
//                                        }
//                                        else
//                                        {
//                                            if (field_kename[0] === '' || field_kename[0] === null)
//                                                kename = undefined;
//                                            else
//                                                kename = field_kename[0];
//                                        }
//                                        maplayer.layer.showFeatureLabels(kename);
//                                    } else {
//                                        maplayer.layer.removeFeatureLabels();
//                                    }
//                                }
//                            });
//                        }



                            _this.overlayToolButtons();
                        }
                        else {

                        }
                    }
                    else {
                        if (!maplayer.layer)
                        {
                            control.loadLayer(maplayer, opt);
                        }
                        else
                        {
                            if (maplayer.layer && !_this._map.hasLayer(maplayer.layer)) {
                                _this._map.addLayer(maplayer.layer);

                            }
                        }
                    }
                }
            },
            // Form data
            data: {id: uploadfile_id},
            //Options to tell JQuery not to process data or worry about content-type
            cache: false,
            contentType: false
                    //   processData: false
        });
    };
    control.renderGroupLayer = function (layer) {

    };
    control.renderWMSLayer = function (layer) {
        if ((layer.layer === undefined || layer.layer === null) && layer.hostName !== undefined && layer.layerName !== undefined)
        {
            var option = {
                layers: layer.layerName,
                format: 'image/png',
                transparent: true,
                attribution: ""
            };
            if (layer.srs !== undefined && layer.srs !== null)
                option['srs'] = layer.srs;
            layer.layer = new L.TileLayer.WMS("http://" + layer.hostName, option);
            layer.map.addLayer(layer.layer);
        }
    };
    control.renderWFSLayer = function (layer) {
        var _this = this;
        if (layer.layer === undefined || layer.layer === null) {

            var geoJsonUrl = "http://" + layer.hostName + "&typeName=" + layer.layerName + "&maxFeatures=5000&srsName=EPSG:4326&outputFormat=json";
            $.ajax({
                url: Routing.generate('default_geoserver_wfs', {'_locale': window.locale}),
                type: 'POST',
                beforeSend: function () {

                    _this._map.spin(true);
                },
                complete: function () {
                    _this._map.spin(false);
                },
                error: function () {
                    _this._map.spin(false);
                },
                data: {
                    address: geoJsonUrl
                },
                success: function (response) {

                    if (typeof response !== 'object')
                        response = JSON.parse(response);
                    if (typeof response.data !== 'object')
                        response.data = JSON.parse(response.data);
                    if (layer.layerType !== 'clustermap') {
                        control.renderD3Layer(layer, response.data, layer.sld, {
                            id: 'svg-leaflet-d3',
                            layerId: layer.layerId,
                            datasource: layer.datasource,
                            zIndex: (300 - layer.index_id),
                            minZoom: layer.minZoom,
                            maxZoom: layer.maxZoom,
                            layerType: layer.layerType
                        });

                    }
                    else {

                        control.renderClusterLayer(layer, response.data);
                    }
                }
            });
        }

        return;
    };
    control.RenderGeojsonLayer = function (result, layer, opt) {
        var _this = this;
        var sld;
        if (typeof result.sld === 'object') {
            sld = result.sld;
        }
        else
        {
            if (result.sld !== undefined && result.sld.trim().length > 100)
                sld = JSON.parse(result.sld);
        }

        var json_data;
        if (result.geomdata && result.geomdata['geom'] === undefined)
            return;
        if (typeof result.geomdata === 'object' && typeof result.geomdata['geom'] !== 'object')
            json_data = JSON.parse(result.geomdata['geom']);
        else
            json_data = result.geomdata['geom'];
        var bounds = d3.geo.bounds(json_data);
        layer.bounds = bounds;
        if (layer.layerType === 'clustermap') {
            control.renderClusterLayer(layer, json_data);
            return;
        }
        else {
            if (layer.layerType === 'userdraw' || layer.layerType === 'userdrawlayer')
            {
                control.renderUserdrawLayer(json_data, layer, opt);
            }
            else {

                control.renderD3Layer(layer, json_data, sld, {
                    id: 'svg-leaflet-d3',
                    layerId: layer.layerId,
                    datasource: layer.datasource,
                    zIndex: (300 - layer.index_id),
                    minZoom: layer.minZoom,
                    maxZoom: layer.maxZoom,
                    layerType: layer.layerType,
                    sld: sld,
                    thematicmap: opt,
                    filename: result.layer['fileName'] ? result.layer['fileName'].toLowerCase() : '',
                    filetype: result.layer['fileType'] ? result.layer['fileType'].toLowerCase() : '',
                    showLabels: (result.layer['label_field'] !== '' && result.layer['label_field'] !== null),
                    type: result.datatype,
                    tip_field: result.layer['tip_field'],
                    tip_percentage: result.layer['tip_percentage'],
                    tip_times100: result.layer['tip_times100'],
                    tip_number: result.layer['tip_number'],
                    label_field: result.layer['label_field']
                });

            }
        }
    };
    control.renderUserdrawLayer = function (data, layer, opt) {
        var _this = this;
        if (data === null || data === undefined)
            return;
        if (layer.layerType === 'userdrawlayer')
        {

        } else {
            _this._map.drawnItems.clearLayers();
            layer.layer = undefined;
        }
        $.each(data, function (i) {
            var feature;
            if (data[i] !== null && data[i].feature !== null) {
                var coordinates;

                if (typeof data[i].feature === 'object')
                    coordinates = data[i].feature.coordinates;
                else
                    coordinates = JSON.parse(data[i].feature).coordinates;

                if ($.isArray(coordinates[0])) {
                    for (var j = 0; j < coordinates[0].length; j++) {
                        var temp = coordinates[0][j][0];
                        coordinates[0][j][0] = coordinates[0][j][1];
                        coordinates[0][j][1] = temp;
                    }
                }
                else
                {
                    var temp = coordinates[0];
                    coordinates[0] = coordinates[1];
                    coordinates[1] = temp;
                }
                if (data[i].geom_type === null) {
                    if (data[i].feature.type === 'Point') {
                        if (parseFloat(data[i].radius) <= 0.0) {
                            data[i].geom_type = "marker";
                        }
                        else {
                            data[i].geom_type = "circle";
                        }
                    }
                    if (data[i].feature.type === 'Polygon') {
                        data[i].geom_type = "polygon";
                    }
                    if (data[i].feature.type === 'LineString') {
                        data[i].geom_type = "polyline";
                    }
                }
                if (data[i].geom_type === 'polygon')
                {
                    feature = new L.Polygon(coordinates);
                }

                if (data[i].geom_type === 'polyline')
                {
                    feature = new L.Polyline(coordinates);
                }
                if (data[i].geom_type === 'rectangle')
                {
                    feature = new L.rectangle([coordinates[0][0], coordinates[0][2]]);
                }
                if (data[i].geom_type === 'circle')
                {
                    feature = new L.circle(coordinates, data[i].radius);
                }

                if (data[i].geom_type === 'marker')
                {
                    feature = L.marker(coordinates);
                }

                //  feature.editing.enable();
                if (feature.bindLabel)
                    feature.bindLabel(data[i].keyname);
                feature.id = data[i].ogc_fid;
                feature.name = data[i].keyname;
                feature.index = _this._map.drawnItems.getLayers().length;
                feature.type = data[i].geom_type;
                feature.layerId = -1;

                feature.on('click', function (e) {

                    var selectedfeature = e.target;
                    if (_this._map.drawControl._toolbars.edit._activeMode === null) {


                        var highlight = {
                            'color': '#333333',
                            'weight': 2,
                            'opacity': 1
                        };
                        if (selectedfeature.selected === false || selectedfeature.selected === undefined) {
                            if (selectedfeature.type !== 'marker')
                                selectedfeature.setStyle(highlight);
                            selectedfeature.selected = true;
                        }
                        else
                        {
                            if (selectedfeature.type !== 'marker')
                                selectedfeature.setStyle({
                                    'color': "blue",
                                    'weight': 5,
                                    'opacity': 0.6
                                });
                            selectedfeature.selected = false;

                        }

                        var shapefilename = $('.sonata-bc #shapefile_select_list option:selected').map(function () {
                            return  this.text;
                        });
                        if (shapefilename !== null && shapefilename !== '' && shapefilename !== undefined && shapefilename.length > 0)
                        {

                            if ($('#geometries_selected').length > 0 && 'user draw trade area' === shapefilename[0].toLowerCase())
                            {
                                var bExist = false;
                                $("#geometries_selected > option").each(function () {

                                    if (parseInt(this.value) === parseInt(selectedfeature.id)) {
                                        bExist = true;
                                    }
                                });
                                if (bExist === false)
                                {
                                    var p = selectedfeature.name;

                                    if (document.getElementById('geometries_selected')) {
                                        var selectBoxOption = document.createElement("option"); //create new option 
                                        selectBoxOption.value = selectedfeature.id; //set option value 
                                        selectBoxOption.text = p; //set option display text 
                                        document.getElementById('geometries_selected').add(selectBoxOption, null);
                                        //    alert(properties_key[0]+ ':'+ e.data.properties[properties_key[0]] + "\n" + properties_key[1] +':' + e.data.properties[properties_key[1]]);
                                    }
                                }
                                else
                                {
                                    $("#geometries_selected option[value='" + selectedfeature.id + "']").each(function () {
                                        $(this).remove();
                                    });
                                }
                            }
                        }
                        else {
                            $.ajax({
                                url: Routing.generate('draw_content', {'_locale': window.locale}),
                                method: 'GET',
                                beforeSend: function () {

                                    _this._map.spin(true);
                                },
                                complete: function () {
                                    _this._map.spin(false);
                                },
                                error: function () {
                                    _this._map.spin(false);
                                },
                                data: {
                                    id: e.target.id
                                },
                                success: function (response) {

                                    $('#sidebar-left #sidebar_content').html('');
                                    $('#sidebar-left #sidebar_content').html(response);

                                    //                            $('#usergeometriesCarousel').carousel({pause: "hover",wrap: true});

                                }
                            });
                        }

                        if (window.leftSidebar && window.leftSidebar.isVisible() === false) {

                            window.leftSidebar.show();
                        }
                        $(".sonata-bc .leftsidebar-close-control").hide();
                        $('#sidebar-left #sidebar_content').css('visibility', 'visible');
                    }
                    else if (_this._map.drawControl._toolbars.edit._activeMode && _this._map.drawControl._toolbars.edit._activeMode.handler.type === 'edit') {

                        var radius = 0;
                        if (e.target.type === 'circle')
                        {
                            radius = e.target._mRadius;
                        }
                        $.ajax({
                            url: Routing.generate('draw_' + e.target.type, {'_locale': window.locale}),
                            method: 'GET',
                            beforeSend: function () {

                                _this._map.spin(true);
                            },
                            complete: function () {
                                _this._map.spin(false);
                            },
                            error: function () {
                                _this._map.spin(false);
                            },
                            data: {
                                id: e.target.id,
                                name: e.target.name,
                                radius: radius,
                                index: e.target.index
                            },
                            success: function (response) {
                                if ($('body.sonata-bc #ajax-dialog').length === 0) {
                                    $('<div class="modal fade" id="ajax-dialog" role="dialog"></div>').appendTo('body');
                                } else {
                                    $('body.sonata-bc #ajax-dialog').html('');
                                }

                                $(response).appendTo($('body.sonata-bc #ajax-dialog'));
                                $('#ajax-dialog').modal({show: true});
                                $('#ajax-dialog').draggable();
                                //  alert(JSON.stringify(html));
                            }
                        });
                    }
                    else if (_this._map.drawControl._toolbars.edit._activeMode && _this._map.drawControl._toolbars.edit._activeMode.handler.type === 'remove') {
                    }
                    ;
                });
                if (layer.layerType === 'userdrawlayer')
                {
                    if (layer.layer === undefined || layer.layer === null)
                    {
                        layer.layer = new L.FeatureGroup();
                        layer.layer.layerId = layer.layerId;
                        layer.layer.layerName = layer.layerName;
                        layer.layer.groupName = layer.groupName;
                    }
                    layer.layer.addLayer(feature);
                    if (!_this._map.hasLayer(layer.layer))
                    {
                        _this._map.addLayer(layer.layer);
                    }
                } else {
                    if (layer.layer === undefined || layer.layer === null)
                        layer.layer = _this._map.drawnItems;
                    _this._map.drawnItems.addLayer(feature);
                }
            }
        });
        return;

    };
    control.RenderTopojsonLayer = function (result, layer, opt) {
        var _this = this;
        var sld;
        if (typeof result.sld === 'object') {
            sld = result.sld;
        }
        else
        {
            if (result.sld !== undefined && result.sld.trim().length > 100)
                sld = JSON.parse(result.sld);
        }
        var json_data = JSON.parse(result.geomdata['geom']); //JSON.parse(result.data[keys[k]]);
        //           var json_data = JSON.parse(result.data);
        var key = Object.keys(json_data.objects).map(function (k) {
            return  k;
        });
        var properties_key = Object.keys(json_data.objects[key].geometries[0].properties).map(function (k) {
            return  k;
        });
        var collection = topojson.feature(json_data, json_data.objects[key]);
        var bounds = d3.geo.bounds(collection);
        layer.bounds = bounds;
        if (layer.layerType === 'clustermap') {

            control.renderClusterLayer(layer, collection);
            return;
        }

        d3.selectAll("#svg-leaflet-d3").each(function () {
            var elt = d3.select(this);
            if (elt.attr("layerType") !== undefined && elt.attr("layerType") !== '' && elt.attr("layerId") !== undefined && parseInt(elt.attr("layerId")) === parseInt(result.layer['layerId']) && elt.attr("layertype").toString().toLowerCase() === layer.layerType)
                elt.remove();
        });

        control.renderD3Layer(layer, collection, sld, {
            id: 'svg-leaflet-d3',
            layerId: layer.layerId,
            zIndex: (300 - layer.index_id),
            minZoom: layer.minZoom,
            maxZoom: layer.maxZoom,
            datasource: layer.datasource,
            layerType: layer.layerType,
            sld: sld,
            thematicmap: opt,
            filename: result.layer['fileName'] ? result.layer['fileName'].toLowerCase() : '',
            filetype: result.layer['fileType'] ? result.layer['fileType'].toLowerCase() : '',
            showLabels: (result.layer['label_field'] !== '' && result.layer['label_field'] !== null),
            type: result.datatype,
            tip_field: result.layer['tip_field'],
            tip_percentage: result.layer['tip_percentage'],
            tip_times100: result.layer['tip_times100'],
            tip_number: result.layer['tip_number'],
            label_field: result.layer['label_field']
        });
        return;
        var geojson_shapefile = new L.D3(collection, {
            id: 'svg-leaflet-d3',
            layerId: layer.layerId,
            zIndex: (300 - layer.index_id),
            minZoom: layer.minZoom,
            maxZoom: layer.maxZoom,
            layerType: layer.layerType,
            sld: sld,
            filename: result.layer['fileName'] ? result.layer['fileName'].toLowerCase() : '',
            filetype: result.layer['fileType'] ? result.layer['fileType'].toLowerCase() : '',
            showLabels: (result.layer['label_field'] !== '' && result.layer['label_field'] !== null),
            type: result.datatype,
            tip_field: result.layer['tip_field'],
            label_field: result.layer['label_field'],
            featureAttributes: {
                'layerId': result.layer['id'],
                'class': function (feature) {
                    return 'default_fcls';
                }
            }
        });
        geojson_shapefile.addTo(_this._map);
        geojson_shapefile.onLoadSLD(sld);
        layer.layer = geojson_shapefile;
        geojson_shapefile.on('click', function (e) {
            //   if (parseInt(e.target.options.layer_id) === parseInt($("select#activelayer_id.layers-ui").val())) {

            var mouse = d3.mouse(e.element);
            var shapefilename = $('.sonata-bc #shapefile_select_list option:selected').map(function () {
                return  this.text;
            });
            if (shapefilename !== null && shapefilename !== '' && shapefilename[0] !== undefined && geojson_shapefile.options.filename === shapefilename[0].toLowerCase())
            {

                if ($('#geometries_selected').length > 0)
                {
                    var bExist = false;
                    $("#geometries_selected > option").each(function () {

                        if (parseInt(this.value) === parseInt(e.data.properties[properties_key[0]])) {
                            bExist = true;
                        }
                    });
                    if (bExist === false)
                    {
                        var fieldkey = $('.sonata-bc #shapefile_labelfield_list option:selected').map(function () {
                            return  this.text;
                        });
                        var p;
                        if (fieldkey === '' || fieldkey[0] === '' || fieldkey[0] === undefined)
                            p = e.data.properties[properties_key[1]];
                        else
                            p = e.data.properties[fieldkey[0]];
                        if (document.getElementById('geometries_selected')) {
                            var selectBoxOption = document.createElement("option"); //create new option 
                            selectBoxOption.value = e.data.properties[properties_key[0]]; //set option value 
                            selectBoxOption.text = p; //set option display text 
                            document.getElementById('geometries_selected').add(selectBoxOption, null);
                            //    alert(properties_key[0]+ ':'+ e.data.properties[properties_key[0]] + "\n" + properties_key[1] +':' + e.data.properties[properties_key[1]]);
                        }
                    }
                }
            }
            ;
            //  }
            var html = '';
            for (var key in e.data.properties) {
                if (e.data.properties.hasOwnProperty(key)) {
                    //alert(e.data.properties[key].substring(0, 5));
                    if (e.data.properties[key] !== 'null' && e.data.properties[key] !== null && e.data.properties[key] !== undefined && e.data.properties[key].length > 10 && (key === 'website' || e.data.properties[key].substring(0, 5) === 'http:'))
                        html = html + key + ":<a href='" + e.data.properties[key] + "' target='_blank'>" + e.data.properties[key] + "</a><br>";
                    else
                        html = html + key + ":" + e.data.properties[key] + "<br>";
                }
            }
            $('#sidebar-left #sidebar_content').html('');
            $('#sidebar-left #sidebar_content').html(html);
        });
        geojson_shapefile.on("mouseover", function (e) {
            e.element.fill = $(e.element).css('fill');
            e.element.fill_opacity = $(e.element).css('fill-opacity');
            if (e.element.fill !== 'none' || e.element.fill_opacity !== '0')
            {
                d3.select(e.element).style({'fill': 'red', 'fill-opacity': '0.8'});
            }

            d3.select(e.element).style('cursor', 'pointer');
        });
        geojson_shapefile.on('mousemove', function (e) {

            //    if (parseInt(e.target.options.layer_id) === parseInt($("select#activelayer_id.layers-ui").val())) {

            var shapefilename = $('.sonata-bc #shapefile_select_list option:selected').map(function () {
                return  this.text;
            });
            if (shapefilename === '' || shapefilename[0] === undefined || geojson_shapefile.options.filename === shapefilename[0].toLowerCase())
            {
                var p;
                var fieldkey = '';
                var mouse = L.DomEvent.getMousePosition(e.originalEvent, _this._map._container);
                fieldkey = $('.sonata-bc #shapefile_labelfield_list option:selected').map(function () {
                    return  this.text;
                });
                if (e.target.options.tip_field !== undefined && e.target.options.tip_field !== '' && e.target.options.tip_field !== null) {

                    p = e.data.properties[e.target.options.tip_field ];
                    if (e.target.options.tip_percentage === true && p !== '' && p !== undefined) {
                        if (e.target.options.tip_times100 === true) {
                            p = parseFloat(p) * 100;
                        }
                        if (e.target.options.tip_number !== undefined && e.target.options.tip_number !== '') {
                            p = parseFloat(p).toFixed(parseInt(e.target.options.tip_number));
                        }
                        p = p + "%";
                    }
                }
                else {
                    if (fieldkey === undefined || fieldkey === null || fieldkey === '' || (typeof fieldkey === 'object' && (fieldkey[0] === null || fieldkey[0] === '' || fieldkey[0] === undefined)))
                    {
                        p = e.data.properties[properties_key[1]];
                        if (e.target.options.tip_percentage === true && p !== '' && p !== undefined) {
                            if (e.target.options.tip_times100 === true) {
                                p = parseFloat(p) * 100;
                            }
                            if (e.target.options.tip_number !== undefined && e.target.options.tip_number !== '') {
                                p = parseFloat(p).toFixed(parseInt(e.target.options.tip_number));
                            }
                            p = p + "%";
                        }
                    }
                    else
                    {
                        p = e.data.properties[fieldkey[0]];
                        if (e.target.options.tip_percentage === true && p !== '' && p !== undefined) {
                            if (e.target.options.tip_times100 === true) {
                                p = parseFloat(p) * 100;
                            }
                            if (e.target.options.tip_number !== undefined && e.target.options.tip_number !== '') {
                                p = parseFloat(p).toFixed(parseInt(e.target.options.tip_number));
                            }
                            p = p + "%";
                        }
                    }
                }
                options.map_tooltip.classed("hidden", false)
                        .attr("style", "left:" + (mouse.x + 30) + "px;top:" + (mouse.y - 35) + "px")
                        .html(p);
            }
            // }
        });
        geojson_shapefile.on('mouseout', function (e) {
            options.map_tooltip.classed("hidden", true);
            d3.select(e.element).style({'fill': e.element.fill});
            d3.select(e.element).style('cursor', 'default');
        });
        //            var bound = d3.geo.bounds(collection);
        if (opt.thematicmap === true) {
            if (geojson_shapefile.options) {
                geojson_shapefile.options.thematicmap = true;
                geojson_shapefile.options.thematicmap_rule = opt;
                if (geojson_shapefile.renderThematicMap)
                    geojson_shapefile.renderThematicMap(geojson_shapefile.options.thematicmap_rule);
            }
        }
    };
    control.loadTopoJSONLayer = function (layer) {
        var _this = this;
        if (layer.type === 'topojsonfile' || layer.type === 'shapefile_topojson' || layer.type === 'topojson' || layer.type === 'geojson') {
            var url;
            if (layer.layerType !== undefined && layer.layerType === 'uploadfile')
                url = Routing.generate('leaflet_uploadfile', {'_locale': window.locale});
            else
            {
                if (layer.layerType === 'uploadfilelayer')
                {

                    url = Routing.generate('leaflet_maplayer', {'_locale': window.locale});
                }
                else if (layer.layerType === 'leafletcluster')
                {
                    url = Routing.generate('leaflet_clusterlayer', {'_locale': window.locale});
                }
                else if (layer.layerType === 'wms') {

                    if (layer.layer === undefined || layer.layer === null)
                    {

                        layer.layer = new L.TileLayer.WMS("http://" + layer.hostName,
                                {
                                    layers: layer.layerName,
                                    format: 'image/png',
                                    transparent: true,
                                    attribution: ""
                                });
                        layer.map.addLayer(layer.layer);
                    }

                    return;
                }
                else if (layer.layerType === 'wfs') {

                    if (layer.layer === undefined || layer.layer === null) {

                        var geoJsonUrl = "http://" + layer.hostName + "&typeName=" + layer.layerName + "&maxFeatures=5000&srsName=EPSG:4326&outputFormat=json";
                        $.ajax({
                            url: Routing.generate('default_geoserver_wfs', {'_locale': window.locale}),
                            type: 'POST',
                            data: {
                                address: geoJsonUrl
                            },
                            success: function (response) {

                                if (typeof response !== 'object')
                                    response = JSON.parse(response);
                                if (typeof response.data !== 'object')
                                    response.data = JSON.parse(response.data);
                                if (layer.layerType !== 'clustermap') {
                                    var geojson_layer = new L.D3(response.data, {
                                        id: 'svg-leaflet-d3',
                                        layerId: layer.layerId,
                                        zIndex: (300 - layer.index_id),
                                        minZoom: layer.minZoom,
                                        maxZoom: layer.maxZoom,
                                        layerType: layer.layerType
                                    });
                                    geojson_layer.addTo(_this._map);
                                    layer.layer = geojson_layer;
                                    //                                geojson_layer.on('click', function(e) {
//                                    //   if (parseInt(e.target.options.layer_id) === parseInt($("select#activelayer_id.layers-ui").val())) {
//
//                                    var mouse = d3.mouse(e.element);
//                                    var shapefilename = $('.sonata-bc #shapefile_select_list option:selected').map(function() {
//                                        return  this.text;
//                                    });
//                                    if (shapefilename !== null && shapefilename !== '' && shapefilename[0] !== undefined && geojson_shapefile.options.filename === shapefilename[0].toLowerCase())
//                                    {
//
//                                        if ($('#geometries_selected').length > 0)
//                                        {
//                                            var bExist = false;
//                                            $("#geometries_selected > option").each(function() {
//
//                                                if (parseInt(this.value) === parseInt(e.data.properties[properties_key[0]])) {
//                                                    bExist = true;
//                                                }
//                                            });
//                                            if (bExist === false)
//                                            {
//                                                var fieldkey = $('.sonata-bc #shapefile_labelfield_list option:selected').map(function() {
//                                                    return  this.text;
//                                                });
//                                                var p;
//                                                if (fieldkey === '' || fieldkey[0] === '' || fieldkey[0] === undefined)
//                                                    p = e.data.properties[properties_key[1]];
//                                                else
//                                                    p = e.data.properties[fieldkey[0]];
//                                                if (document.getElementById('geometries_selected')) {
//                                                    var selectBoxOption = document.createElement("option"); //create new option 
//                                                    selectBoxOption.value = e.data.properties[properties_key[0]]; //set option value 
//                                                    selectBoxOption.text = p; //set option display text 
//                                                    document.getElementById('geometries_selected').add(selectBoxOption, null);
//                                                    //    alert(properties_key[0]+ ':'+ e.data.properties[properties_key[0]] + "\n" + properties_key[1] +':' + e.data.properties[properties_key[1]]);
//                                                }
//                                            }
//                                        }
//                                    }
//                                    ;
//                                    //  }
//                                    var html = '';
//                                    for (var key in e.data.properties) {
//                                        if (e.data.properties.hasOwnProperty(key)) {
//                                            //alert(e.data.properties[key].substring(0, 5));
//                                            if (e.data.properties[key] !== 'null' && e.data.properties[key] !== null && e.data.properties[key] !== undefined && e.data.properties[key].length > 10 && (key === 'website' || e.data.properties[key].substring(0, 5) === 'http:'))
//                                                html = html + key + ":<a href='" + e.data.properties[key] + "' target='_blank'>" + e.data.properties[key] + "</a><br>";
//                                            else
//                                                html = html + key + ":" + e.data.properties[key] + "<br>";
//
//                                        }
//                                    }
//                                    $('div.sidebar_feature_content').html('');
//                                    $('div.sidebar_feature_content').html(html);
//                                });
//
//                                geojson_layer.on("mouseover", function(e) {
//                                    e.element.fill = $(e.element).css('fill');
//                                    e.element.fill_opacity = $(e.element).css('fill-opacity');
//                                    d3.select(e.element).style({'fill': 'red', 'fill-opacity': '0.8'});
//                                    d3.select(e.element).style('cursor', 'pointer');
//
//                                });
//                                geojson_layer.on('mousemove', function(e) {
//
//                                    //    if (parseInt(e.target.options.layer_id) === parseInt($("select#activelayer_id.layers-ui").val())) {
//
//                                    var shapefilename = $('.sonata-bc #shapefile_select_list option:selected').map(function() {
//                                        return  this.text;
//                                    });
//
//                                    if (shapefilename === '' || shapefilename[0] === undefined || geojson_shapefile.options.filename === shapefilename[0].toLowerCase())
//                                    {
//                                        var p;
//
//                                        var fieldkey = '';
//                                        var mouse = L.DomEvent.getMousePosition(e.originalEvent, _this._map._container);
//                                        fieldkey = $('.sonata-bc #shapefile_labelfield_list option:selected').map(function() {
//                                            return  this.text;
//                                        });
//
//                                        if (e.target.options.tip_field !== undefined && e.target.options.tip_field !== '' && e.target.options.tip_field !== null) {
//                                            p = e.data.properties[e.target.options.tip_field ];
//                                        }
//                                        else {
//
//                                            if (fieldkey === undefined || fieldkey === null || fieldkey === '' || (typeof fieldkey === 'object' && (fieldkey[0] === null || fieldkey[0] === '' || fieldkey[0] === undefined)))
//                                                p = e.data.properties[properties_key[1]];
//                                            else
//                                                p = e.data.properties[fieldkey[0]];
//                                        }
//                                        options.map_tooltip.classed("hidden", false)
//                                                .attr("style", "left:" + (mouse.x + 30) + "px;top:" + (mouse.y - 35) + "px")
//                                                .html(p);
//                                    }
//                                    // }
//                                });
//                                geojson_layer.on('mouseout', function(e) {
//                                    options.map_tooltip.classed("hidden", true);
//                                    d3.select(e.element).style({'fill': e.element.fill});
//                                    d3.select(e.element).style({'fill-opacity': e.element.fill_opacity});
//                                    d3.select(e.element).style('cursor', 'default');
//                                });
                                }
                                else {
                                    var properties_key = Object.keys(response.data.features[0].properties).map(function (k) {
                                        return  k;
                                    });
                                    var rmax = 30;
                                    var highlightStyle = {
                                        color: '#2262CC',
                                        weight: 3,
                                        opacity: 0.6,
                                        fillOpacity: 0.65,
                                        fillColor: '#2262CC'
                                    };
                                    var geoJsonLayer = L.geoJson(response.data, {
                                        id: "9",
                                        style: {
                                            fillColor: "#A3C990",
                                            color: "#000",
                                            weight: 1,
                                            opacity: 1,
                                            fillOpacity: 0.4
                                        },
                                        pointToLayer: function (feature, latlng) {
                                            return new L.CircleMarker(latlng, {
                                                radius: 5,
                                                fillColor: "#A3C990",
                                                color: "#000",
                                                weight: 1,
                                                opacity: 1,
                                                fillOpacity: 0.4
                                            });
                                        },
                                        onEachFeature: function (feature, layer) {
                                            (function (layer, properties) {
                                                layer.on('mouseover', function (e) {
                                                    var layer = e.target;
                                                    layer.setStyle({
                                                        weight: 2,
                                                        color: 'red',
                                                        dashArray: '',
                                                        cursor: 'pointer',
                                                        fillOpacity: 0.7
                                                    });
                                                    //    $(this).fill = $(this).css('fill');
                                                    //    $(this).fill_opacity = $(this).css('fill-opacity');
                                                    // d3.select(e.target).style({'fill': 'red'});
//                                                $(e.target).css('fill', 'red');
//                                                $(e.target).css('fill-opacity', '0.8');
                                                    $(this).css('cursor', 'pointer');
                                                });
                                                layer.on('mouseout', function (e) {


                                                    geoJsonLayer.resetStyle(e.target);
                                                    options.map_tooltip.classed("hidden", true);
                                                    //      $(this).css('fill', $(this).fill);
                                                    //      $(this).css('fill-opacity', $(this).fill_opacity);
                                                    $(this).css('cursor', 'default');
                                                });
                                                layer.on('mousemove', function (e) {                         //    if (parseInt(e.target.options.layer_id) === parseInt($("select#activelayer_id.layers-ui").val())) {

                                                    var shapefilename = $('.sonata-bc #shapefile_select_list option:selected').map(function () {
                                                        return  this.text;
                                                    });
                                                    if (shapefilename === '' || shapefilename[0] === undefined)
                                                    {
                                                        var p;
                                                        var fieldkey = '';
                                                        var mouse = L.DomEvent.getMousePosition(e.originalEvent, _this._map._container);
                                                        fieldkey = $('.sonata-bc #shapefile_labelfield_list option:selected').map(function () {
                                                            return  this.text;
                                                        });
                                                        if (e.target.options.tip_field !== undefined && e.target.options.tip_field !== '' && e.target.options.tip_field !== null) {
                                                            p = properties[e.target.options.tip_field ];
                                                        }
                                                        else {

                                                            if (fieldkey === undefined || fieldkey === null || fieldkey === '' || (typeof fieldkey === 'object' && (fieldkey[0] === null || fieldkey[0] === '' || fieldkey[0] === undefined)))
                                                                p = properties[properties_key[1]];
                                                            else
                                                                p = properties[fieldkey[0]];
                                                        }
                                                        options.map_tooltip.classed("hidden", false)
                                                                .attr("style", "left:" + (mouse.x + 30) + "px;top:" + (mouse.y - 35) + "px")
                                                                .html(p);
                                                    }

                                                });
                                                layer.on('click', function (e) {
                                                    var html = '';
                                                    for (var key in properties) {
                                                        if (properties.hasOwnProperty(key)) {
                                                            //alert(e.data.properties[key].substring(0, 5));
                                                            if (properties[key] !== 'null' && properties[key] !== null && properties[key] !== undefined && properties[key].length > 10 && (key === 'website' || properties[key].substring(0, 5) === 'http:'))
                                                                html = html + key + ":<a href='" + properties[key] + "' target='_blank'>" + properties[key] + "</a><br>";
                                                            else
                                                                html = html + key + ":" + properties[key] + "<br>";
                                                        }
                                                    }
                                                    $('div.sidebar_feature_content').html('');
                                                    $('div.sidebar_feature_content').html(html);
                                                    if (window.leftSidebar && window.leftSidebar.isVisible() === false) {

                                                        window.leftSidebar.show();
                                                    }
                                                    $(".sonata-bc .leftsidebar-close-control").hide();
                                                    $('#sidebar-left #sidebar_content').css('visibility', 'visible');
                                                });
                                            })(layer, feature.properties);
                                            //layer.bindPopup(feature.properties.Name);
                                        }
                                    });
                                    var markerclusters = new L.MarkerClusterGroup({
                                        maxClusterRadius: 80,
//                                    iconCreateFunction: function(cluster) {
//                                        var markers = cluster.getAllChildMarkers();
//                                        var n = 0;
//                                        for (var i = 0; i < markers.length; i++) {
//                                            n += markers[i].number;
//                                        }
//                                        return L.divIcon({html: n, className: 'mycluster', iconSize: L.point(40, 40)});
//                                    },
                                        //Disable all of the defaults:
                                        spiderfyOnMaxZoom: true, showCoverageOnHover: true, zoomToBoundsOnClick: true
                                    });
                                    markerclusters.addLayer(geoJsonLayer, true);
                                    //   _this._map.addLayer(markerclusters);
                                    //   geoJsonLayer.addTo(_this._map);
                                    markerclusters.addTo(_this._map);
                                    layer.layer = markerclusters;
                                }
                            }
                        });
                    }
                    return;
                }
                else
                    return;
            }
            $.ajax({
                url: url,
                type: 'GET',
                beforeSend: function () {

                    _this._map.spin(true);
                },
                complete: function () {
                    _this._map.spin(false);
                },
                error: function () {
                    _this._map.spin(false);
                },
                data: {id: layer.layerId, type: layer.type},
                //Ajax events
                success: function (response) {
                    var result;
                    if (typeof response === 'object') {
                        result = response;
                    } else {
                        result = JSON.parse(response);
                    }

                    if (result.success === true && result.type === 'geojson' && result.filename === 'draw' && result.data !== null) {

                        var data;
                        if (typeof result.data === 'object') {
                            data = result.data;
                        } else {
                            data = JSON.parse(result.data);
                        }
                        _this._map.drawnItems.clearLayers();
                        $.each(data, function (i) {
                            var feature;
                            if (data[i] !== null && data[i].feature !== null) {
                                var coordinates;
                                if (typeof data[i].feature === 'object')
                                    coordinates = data[i].feature.coordinates;
                                else
                                    coordinates = JSON.parse(data[i].feature).coordinates;
                                if ($.isArray(coordinates[0])) {
                                    for (var j = 0; j < coordinates[0].length; j++) {
                                        var temp = coordinates[0][j][0];
                                        coordinates[0][j][0] = coordinates[0][j][1];
                                        coordinates[0][j][1] = temp;
                                    }
                                }
                                else
                                {
                                    var temp = coordinates[0];
                                    coordinates[0] = coordinates[1];
                                    coordinates[1] = temp;
                                }
                                if (data[i].geom_type === 'polygon')
                                {
                                    feature = new L.Polygon(coordinates);
                                }

                                if (data[i].geom_type === 'polyline')
                                {
                                    feature = new L.Polyline(coordinates);
                                }
                                if (data[i].geom_type === 'rectangle')
                                {
                                    feature = new L.rectangle([coordinates[0][0], coordinates[0][2]]);
                                }
                                if (data[i].geom_type === 'circle')
                                {
                                    feature = new L.circle(coordinates, data[i].radius);
                                }
                                if (data[i].geom_type === 'marker')
                                {
                                    feature = L.marker(coordinates);
                                }

                                //  feature.editing.enable();
                                if (feature.bindLabel)
                                    feature.bindLabel(data[i].keyname);
                                feature.id = data[i].ogc_fid;
                                feature.name = data[i].keyname;
                                feature.index = _this._map.drawnItems.getLayers().length;
                                feature.type = data[i].geom_type;
                                feature.layerId = -1;
                                feature.on('click', function (e) {



//                                    if (e.originalEvent.button === 2)
//                                    {
//                                        var radius = 0;
//                                        if (e.target.type === 'circle')
//                                        {
//                                            radius = e.target._mRadius;
//                                        }
//                                        $.ajax({
//                                            url: Routing.generate('draw_' + e.target.type),
//                                            method: 'GET',
//                                            data: {
//                                                id: e.target.id,
//                                                name: e.target.name,
//                                                radius: radius,
//                                                index: e.target.index
//                                            },
//                                            success: function(response) {
//                                                if ($('body.sonata-bc #ajax-dialog').length === 0) {
//                                                    $('<div class="modal fade" id="ajax-dialog" role="dialog"></div>').appendTo('body');
//                                                } else {
//                                                    $('body.sonata-bc #ajax-dialog').html('');
//                                                }
//
//                                                $(response).appendTo($('body.sonata-bc #ajax-dialog'));
//                                                $('#ajax-dialog').modal({show: true});
//                                                $('#ajax-dialog').draggable();
//                                                //  alert(JSON.stringify(html));
//                                            }
//                                        });
//                                    } else {
//                                        if (e.originalEvent.button === 0) {
//                                            var highlight = {
//                                                'color': '#333333',
//                                                'weight': 2,
//                                                'opacity': 1
//                                            };
//
//                                            if (feature.selected === false || feature.selected === undefined) {
//                                                feature.setStyle(highlight);
//                                                feature.selected = true;
//                                                if (document.getElementById('geometries_selected')) {
//                                                    var selectBoxOption = document.createElement("option");//create new option 
//                                                    selectBoxOption.value = feature.id;//set option value 
//                                                    selectBoxOption.text = feature.name;//set option display text 
//                                                    document.getElementById('geometries_selected').add(selectBoxOption, null);
//                                                }
//                                            }
//                                            else
//                                            {
//
//                                                feature.setStyle({
//                                                    'color': "blue",
//                                                    'weight': 5,
//                                                    'opacity': 0.6
//                                                });
//                                                feature.selected = false;
//                                                $("#geometries_selected option[value='" + feature.id + "']").each(function() {
//                                                    $(this).remove();
//                                                });
//                                            }
//                                        }
//
//                                    }
                                    var feature = e.target;



//                                    
//                                    if (_this._map.drawControl._toolbars.edit._activeMode === null) {
//
//
//                                        var highlight = {
//                                            'color': '#333333',
//                                            'weight': 2,
//                                            'opacity': 1
//                                        };
//                                        if (feature.selected === false || feature.selected === undefined) {
//                                            if (feature.type !== 'marker')
//                                                feature.setStyle(highlight);
//                                            feature.selected = true;
//                                            if (document.getElementById('geometries_selected')) {
//                                                var selectBoxOption = document.createElement("option"); //create new option 
//                                                selectBoxOption.value = feature.id; //set option value 
//                                                selectBoxOption.text = feature.name; //set option display text 
//                                                document.getElementById('geometries_selected').add(selectBoxOption, null);
//                                            }
//                                        }
//                                        else
//                                        {
//                                            if (feature.type !== 'marker')
//                                                feature.setStyle({
//                                                    'color': "blue",
//                                                    'weight': 5,
//                                                    'opacity': 0.6
//                                                });
//                                            feature.selected = false;
//                                            $("#geometries_selected option[value='" + feature.id + "']").each(function () {
//                                                $(this).remove();
//                                            });
//                                        }
//
//                                        $.ajax({
//                                            url: Routing.generate('draw_content'),
//                                            method: 'GET',
//                                            data: {
//                                                id: e.target.id
//                                            },
//                                            success: function (response) {
//
//                                                $('div.sidebar_feature_content').html('');
//                                                $('div.sidebar_feature_content').html(response);
//                                                if (window.leftSidebar) {
//                                                    alert(window.leftSidebar.isVisible());
//                                                }
//                                            }
//                                        });
//                                    }
                                    var selectedfeature = e.target;
                                    if (_this._map.drawControl._toolbars.edit._activeMode === null) {


                                        var highlight = {
                                            'color': '#333333',
                                            'weight': 2,
                                            'opacity': 1
                                        };
                                        if (selectedfeature.selected === false || selectedfeature.selected === undefined) {
                                            if (selectedfeature.type !== 'marker')
                                                selectedfeature.setStyle(highlight);
                                            selectedfeature.selected = true;
                                        }
                                        else
                                        {
                                            if (selectedfeature.type !== 'marker')
                                                selectedfeature.setStyle({
                                                    'color': "blue",
                                                    'weight': 5,
                                                    'opacity': 0.6
                                                });
                                            selectedfeature.selected = false;

                                        }

                                        var shapefilename = $('.sonata-bc #shapefile_select_list option:selected').map(function () {
                                            return  this.text;
                                        });
                                        if (shapefilename !== null && shapefilename !== '' && shapefilename !== undefined && shapefilename.length > 0)
                                        {

                                            if ($('#geometries_selected').length > 0 && 'user draw trade area' === shapefilename[0].toLowerCase())
                                            {
                                                var bExist = false;
                                                $("#geometries_selected > option").each(function () {

                                                    if (parseInt(this.value) === parseInt(selectedfeature.id)) {
                                                        bExist = true;
                                                    }
                                                });
                                                if (bExist === false)
                                                {
                                                    var p = selectedfeature.name;

                                                    if (document.getElementById('geometries_selected')) {
                                                        var selectBoxOption = document.createElement("option"); //create new option 
                                                        selectBoxOption.value = selectedfeature.id; //set option value 
                                                        selectBoxOption.text = p; //set option display text 
                                                        document.getElementById('geometries_selected').add(selectBoxOption, null);
                                                        //    alert(properties_key[0]+ ':'+ e.data.properties[properties_key[0]] + "\n" + properties_key[1] +':' + e.data.properties[properties_key[1]]);
                                                    }
                                                }
                                                else
                                                {
                                                    $("#geometries_selected option[value='" + selectedfeature.id + "']").each(function () {
                                                        $(this).remove();
                                                    });
                                                }
                                            }
                                        }
                                        else {
                                            $.ajax({
                                                url: Routing.generate('draw_content', {'_locale': window.locale}),
                                                method: 'GET',
                                                beforeSend: function () {

                                                    _this._map.spin(true);
                                                },
                                                complete: function () {
                                                    _this._map.spin(false);
                                                },
                                                error: function () {
                                                    _this._map.spin(false);
                                                },
                                                data: {
                                                    id: e.target.id
                                                },
                                                success: function (response) {

                                                    $('#sidebar-left #sidebar_content').html('');
                                                    $('#sidebar-left #sidebar_content').html(response);
                                                }
                                            });
                                        }
                                        if (window.leftSidebar && window.leftSidebar.isVisible() === false) {

                                            window.leftSidebar.show();
                                        }
                                        $(".sonata-bc .leftsidebar-close-control").hide();
                                        $('#sidebar-left #sidebar_content').css('visibility', 'visible');
                                    }

                                    else if (_this._map.drawControl._toolbars.edit._activeMode && _this._map.drawControl._toolbars.edit._activeMode.handler.type === 'edit') {

                                        var radius = 0;
                                        if (e.target.type === 'circle')
                                        {
                                            radius = e.target._mRadius;
                                        }
                                        $.ajax({
                                            url: Routing.generate('draw_' + e.target.type, {'_locale': window.locale}),
                                            method: 'GET',
                                            data: {
                                                id: e.target.id,
                                                name: e.target.name,
                                                radius: radius,
                                                index: e.target.index
                                            },
                                            success: function (response) {
                                                if ($('body.sonata-bc #ajax-dialog').length === 0) {
                                                    $('<div class="modal fade" id="ajax-dialog" role="dialog"></div>').appendTo('body');
                                                } else {
                                                    $('body.sonata-bc #ajax-dialog').html('');
                                                }

                                                $(response).appendTo($('body.sonata-bc #ajax-dialog'));
                                                $('#ajax-dialog').modal({show: true});
                                                $('#ajax-dialog').draggable();
                                                //  alert(JSON.stringify(html));
                                            }
                                        });
                                    }
                                    else if (_this._map.drawControl._toolbars.edit._activeMode && _this._map.drawControl._toolbars.edit._activeMode.handler.type === 'remove') {
                                    }
                                    ;
                                });
                                layer.layer = _this._map.drawnItems;
                                _this._map.drawnItems.addLayer(feature);
                            }
                        });
                        return;
                    }

                    if (result.success === true && (result.type === 'topojsonfile' || result.type === 'topojson' || result.type === 'shapefile_topojson')) {

                        var sld;
                        if (typeof result.sld === 'object') {
                            sld = result.sld;
                        }
                        else
                        {
                            if (result.sld !== undefined && result.sld.trim().length > 100)
                                sld = JSON.parse(result.sld);
                        }



                        d3.selectAll("#svg-leaflet-d3").each(function () {
                            var elt = d3.select(this);
                            if (elt.attr("filename").toString().toLowerCase() === result.filename.toString().toLowerCase() && elt.attr("layerType").toString().toLowerCase() === layer.layerType)
                                elt.remove();
                        });
                        var keys = Object.keys(result.data, function (k) {
                            return k;
                        });
                        for (var k = 0; k < keys.length; k++) {
                            var json_data = JSON.parse(result.data[keys[k]].geom); //JSON.parse(result.data[keys[k]]);
                            //           var json_data = JSON.parse(result.data);
                            var key = Object.keys(json_data.objects).map(function (k) {
                                return  k;
                            });
                            var properties_key = Object.keys(json_data.objects[key].geometries[0].properties).map(function (k) {
                                return  k;
                            });
                            var collection = topojson.feature(json_data, json_data.objects[key]);
//                            control.createD3SVGLayer(layer, collection, sld, {
//                                layer_id: layer.layer_id,
//                                zIndex: (300 - layer.index_id),
//                                minZoom: layer.minZoom,
//                                maxZoom: layer.maxZoom,
//                                filename: result.filename.toLowerCase(),
//                                filetype: result.filetype.toLowerCase(),
//                                showLabels: (result.layers[keys[k]]['label_field'] !== '' && result.layers[keys[k]]['label_field'] !== null),
//                                type: result.type,
//                                tip_field: result.layers[keys[k]]['tip_field'],
//                                label_field: result.layers[keys[k]]['label_field']
//                            });
                            var geojson_shapefile = new L.D3(collection, {
                                id: 'svg-leaflet-d3',
                                layerId: layer.layerId,
                                zIndex: (300 - layer.index_id),
                                minZoom: layer.minZoom,
                                maxZoom: layer.maxZoom,
                                layerType: layer.layerType,
                                sld: sld,
                                filename: result.filename.toLowerCase(),
                                filetype: result.filetype.toLowerCase(),
                                showLabels: (result.layers[keys[k]]['label_field'] !== '' && result.layers[keys[k]]['label_field'] !== null),
                                type: result.type,
                                tip_field: result.layers[keys[k]]['tip_field'],
                                tip_percentage: result.layers[keys[k]]['tip_percentage'],
                                tip_times100: result.layers[keys[k]]['tip_times100'],
                                tip_number: result.layers[keys[k]]['tip_number'],
                                label_field: result.layers[keys[k]]['label_field'],
                                featureAttributes: {
                                    'layerId': result.layers[keys[k]]['id'],
                                    'class': function (feature) {
                                        return 'default_fcls';
                                    }
                                }
                            });
                            geojson_shapefile.addTo(_this._map);
                            geojson_shapefile.onLoadSLD(sld);
                            layer.layer = geojson_shapefile;
                            geojson_shapefile.on('click', function (e) {
                                //   if (parseInt(e.target.options.layer_id) === parseInt($("select#activelayer_id.layers-ui").val())) {

                                var mouse = d3.mouse(e.element);
                                var shapefilename = $('.sonata-bc #shapefile_select_list option:selected').map(function () {
                                    return  this.text;
                                });
                                if (shapefilename !== null && shapefilename !== '' && shapefilename[0] !== undefined && geojson_shapefile.options.filename === shapefilename[0].toLowerCase())
                                {

                                    if ($('#geometries_selected').length > 0)
                                    {
                                        var bExist = false;
                                        $("#geometries_selected > option").each(function () {

                                            if (parseInt(this.value) === parseInt(e.data.properties[properties_key[0]])) {
                                                bExist = true;
                                            }
                                        });
                                        if (bExist === false)
                                        {
                                            var fieldkey = $('.sonata-bc #shapefile_labelfield_list option:selected').map(function () {
                                                return  this.text;
                                            });
                                            var p;
                                            if (fieldkey === '' || fieldkey[0] === '' || fieldkey[0] === undefined)
                                                p = e.data.properties[properties_key[1]];
                                            else
                                                p = e.data.properties[fieldkey[0]];
                                            if (document.getElementById('geometries_selected')) {
                                                var selectBoxOption = document.createElement("option"); //create new option 
                                                selectBoxOption.value = e.data.properties[properties_key[0]]; //set option value 
                                                selectBoxOption.text = p; //set option display text 
                                                document.getElementById('geometries_selected').add(selectBoxOption, null);
                                                //    alert(properties_key[0]+ ':'+ e.data.properties[properties_key[0]] + "\n" + properties_key[1] +':' + e.data.properties[properties_key[1]]);
                                            }
                                        }
                                    }
                                }
                                else {
                                    //  }
                                    var html = '';
                                    for (var key in e.data.properties) {
                                        if (e.data.properties.hasOwnProperty(key)) {
                                            //alert(e.data.properties[key].substring(0, 5));
                                            if (e.data.properties[key] !== 'null' && e.data.properties[key] !== null && e.data.properties[key] !== undefined && e.data.properties[key].length > 10 && (key === 'website' || e.data.properties[key].substring(0, 5) === 'http:'))
                                                html = html + key + ":<a href='" + e.data.properties[key] + "' target='_blank'>" + e.data.properties[key] + "</a><br>";
                                            else
                                                html = html + key + ":" + e.data.properties[key] + "<br>";
                                        }
                                    }
                                    $('div.sidebar_feature_content').html('');
                                    $('div.sidebar_feature_content').html(html);
                                }
                                if (window.leftSidebar && window.leftSidebar.isVisible() === false) {

                                    window.leftSidebar.show();
                                }
                                $(".sonata-bc .leftsidebar-close-control").hide();
                                $('#sidebar-left #sidebar_content').css('visibility', 'visible');

                            });
                            geojson_shapefile.on("mouseover", function (e) {
                                e.element.fill = $(e.element).css('fill');
                                d3.select(e.element).style({'fill': 'red', 'fill-opacity': '0.8'});
                                d3.select(e.element).style('cursor', 'pointer');
                            });
                            geojson_shapefile.on('mousemove', function (e) {

                                //    if (parseInt(e.target.options.layer_id) === parseInt($("select#activelayer_id.layers-ui").val())) {

                                var shapefilename = $('.sonata-bc #shapefile_select_list option:selected').map(function () {
                                    return  this.text;
                                });
                                if (shapefilename === '' || shapefilename[0] === undefined || geojson_shapefile.options.filename === shapefilename[0].toLowerCase())
                                {
                                    var p;
                                    var fieldkey = '';
                                    var mouse = L.DomEvent.getMousePosition(e.originalEvent, _this._map._container);
                                    fieldkey = $('.sonata-bc #shapefile_labelfield_list option:selected').map(function () {
                                        return  this.text;
                                    });
                                    if (e.target.options.tip_field !== undefined && e.target.options.tip_field !== '' && e.target.options.tip_field !== null) {
                                        p = e.data.properties[e.target.options.tip_field ];
                                        if (e.target.options.tip_percentage === true && p !== '' && p !== undefined) {
                                            if (e.target.options.tip_times100 === true) {
                                                p = parseFloat(p) * 100;
                                            }
                                            if (e.target.options.tip_number !== undefined && e.target.options.tip_number !== '') {
                                                p = parseFloat(p).toFixed(parseInt(e.target.options.tip_number));
                                            }
                                            p = p + "%";
                                        }


                                    }
                                    else {
                                        if (fieldkey === undefined || fieldkey === null || fieldkey === '' || (typeof fieldkey === 'object' && (fieldkey[0] === null || fieldkey[0] === '' || fieldkey[0] === undefined)))
                                        {
                                            p = e.data.properties[properties_key[1]];
                                            if (e.target.options.tip_percentage === true && p !== '' && p !== undefined) {
                                                if (e.target.options.tip_times100 === true) {
                                                    p = parseFloat(p) * 100;
                                                }
                                                if (e.target.options.tip_number !== undefined && e.target.options.tip_number !== '') {
                                                    p = parseFloat(p).toFixed(parseInt(e.target.options.tip_number));
                                                }
                                                p = p + "%";
                                            }
                                        }
                                        else
                                        {
                                            p = e.data.properties[fieldkey[0]];
                                            if (e.target.options.tip_percentage === true && p !== '' && p !== undefined) {
                                                if (e.target.options.tip_times100 === true) {
                                                    p = parseFloat(p) * 100;
                                                }
                                                if (e.target.options.tip_number !== undefined && e.target.options.tip_number !== '') {
                                                    p = parseFloat(p).toFixed(parseInt(e.target.options.tip_number));
                                                }
                                                p = p + "%";
                                            }
                                        }
                                    }
                                    options.map_tooltip.classed("hidden", false)
                                            .attr("style", "left:" + (mouse.x + 30) + "px;top:" + (mouse.y - 35) + "px")
                                            .html(p);
                                }
                                // }
                            });
                            geojson_shapefile.on('mouseout', function (e) {
                                options.map_tooltip.classed("hidden", true);
                                d3.select(e.element).style({'fill': e.element.fill});
                                d3.select(e.element).style('cursor', 'default');
                            });
                        }

                        //            var bound = d3.geo.bounds(collection);

                        //          map.fitBounds([[bound[0][1], bound[0][0]], [bound[1][1], bound[1][0]]]);

                    }
                }
            });
        }
    };
    control.createHeatMapLayer = function (opt) {

        var testData;
        if (opt && opt.data)
            testData = opt.data;
        else
            testData = {
                min: 0,
                max: 11,
                data: [{lat: 24.6408, lng: 46.7728, count: 3}, {lat: 50.75, lng: -1.55, count: 1}, {lat: 52.6333, lng: 1.75, count: 1}, {lat: 48.15, lng: 9.4667, count: 1}, {lat: 52.35, lng: 4.9167, count: 2}, {lat: 60.8, lng: 11.1, count: 1}, {lat: 43.561, lng: -116.214, count: 1}, {lat: 47.5036, lng: -94.685, count: 1}, {lat: 42.1818, lng: -71.1962, count: 1}, {lat: 42.0477, lng: -74.1227, count: 1}, {lat: 40.0326, lng: -75.719, count: 1}, {lat: 40.7128, lng: -73.2962, count: 2}, {lat: 27.9003, lng: -82.3024, count: 1}, {lat: 38.2085, lng: -85.6918, count: 1}, {lat: 46.8159, lng: -100.706, count: 1}, {lat: 30.5449, lng: -90.8083, count: 1}, {lat: 44.735, lng: -89.61, count: 1}, {lat: 41.4201, lng: -75.6485, count: 2}, {lat: 39.4209, lng: -74.4977, count: 11}, {lat: 39.7437, lng: -104.979, count: 1}, {lat: 39.5593, lng: -105.006, count: 1}, {lat: 45.2673, lng: -93.0196, count: 1}, {lat: 41.1215, lng: -89.4635, count: 1}, {lat: 43.4314, lng: -83.9784, count: 1}, {lat: 43.7279, lng: -86.284, count: 1}, {lat: 40.7168, lng: -73.9861, count: 1}, {lat: 47.7294, lng: -116.757, count: 1}, {lat: 47.7294, lng: -116.757, count: 2}, {lat: 35.5498, lng: -118.917, count: 1}, {lat: 34.1568, lng: -118.523, count: 1}, {lat: 39.501, lng: -87.3919, count: 3}, {lat: 33.5586, lng: -112.095, count: 1}, {lat: 38.757, lng: -77.1487, count: 1}, {lat: 33.223, lng: -117.107, count: 1}, {lat: 30.2316, lng: -85.502, count: 1}, {lat: 39.1703, lng: -75.5456, count: 8}, {lat: 30.0041, lng: -95.2984, count: 2}, {lat: 29.7755, lng: -95.4152, count: 1}, {lat: 41.8014, lng: -87.6005, count: 1}, {lat: 37.8754, lng: -121.687, count: 7}, {lat: 38.4493, lng: -122.709, count: 1}, {lat: 40.5494, lng: -89.6252, count: 1}, {lat: 42.6105, lng: -71.2306, count: 1}, {lat: 40.0973, lng: -85.671, count: 1}, {lat: 40.3987, lng: -86.8642, count: 1}, {lat: 40.4224, lng: -86.8031, count: 4}, {lat: 47.2166, lng: -122.451, count: 1}, {lat: 32.2369, lng: -110.956, count: 1}, {lat: 41.3969, lng: -87.3274, count: 2}, {lat: 41.7364, lng: -89.7043, count: 2}, {lat: 42.3425, lng: -71.0677, count: 1}, {lat: 33.8042, lng: -83.8893, count: 1}, {lat: 36.6859, lng: -121.629, count: 2}, {lat: 41.0957, lng: -80.5052, count: 1}, {lat: 46.8841, lng: -123.995, count: 1}, {lat: 40.2851, lng: -75.9523, count: 2}, {lat: 42.4235, lng: -85.3992, count: 1}, {lat: 39.7437, lng: -104.979, count: 2}, {lat: 25.6586, lng: -80.3568, count: 7}, {lat: 33.0975, lng: -80.1753, count: 1}, {lat: 25.7615, lng: -80.2939, count: 1}, {lat: 26.3739, lng: -80.1468, count: 1}, {lat: 37.6454, lng: -84.8171, count: 1}, {lat: 34.2321, lng: -77.8835, count: 1}, {lat: 34.6774, lng: -82.928, count: 1}, {lat: 39.9744, lng: -86.0779, count: 1}, {lat: 35.6784, lng: -97.4944, count: 2}, {lat: 33.5547, lng: -84.1872, count: 1}, {lat: 27.2498, lng: -80.3797, count: 1}, {lat: 41.4789, lng: -81.6473, count: 1}, {lat: 41.813, lng: -87.7134, count: 1}, {lat: 41.8917, lng: -87.9359, count: 1}, {lat: 35.0911, lng: -89.651, count: 1}, {lat: 32.6102, lng: -117.03, count: 1}, {lat: 41.758, lng: -72.7444, count: 1}, {lat: 39.8062, lng: -86.1407, count: 1}, {lat: 41.872, lng: -88.1662, count: 1}, {lat: 34.1404, lng: -81.3369, count: 1}, {lat: 46.15, lng: -60.1667, count: 1}, {lat: 36.0679, lng: -86.7194, count: 1}, {lat: 43.45, lng: -80.5, count: 1}, {lat: 44.3833, lng: -79.7, count: 1}, {lat: 45.4167, lng: -75.7, count: 2}, {lat: 43.75, lng: -79.2, count: 2}, {lat: 45.2667, lng: -66.0667, count: 3}, {lat: 42.9833, lng: -81.25, count: 2}, {lat: 44.25, lng: -79.4667, count: 3}, {lat: 45.2667, lng: -66.0667, count: 2}, {lat: 34.3667, lng: -118.478, count: 3}, {lat: 42.734, lng: -87.8211, count: 1}, {lat: 39.9738, lng: -86.1765, count: 1}, {lat: 33.7438, lng: -117.866, count: 1}, {lat: 37.5741, lng: -122.321, count: 1}, {lat: 42.2843, lng: -85.2293, count: 1}, {lat: 34.6574, lng: -92.5295, count: 1}, {lat: 41.4881, lng: -87.4424, count: 1}, {lat: 25.72, lng: -80.2707, count: 1}, {lat: 34.5873, lng: -118.245, count: 1}, {lat: 35.8278, lng: -78.6421, count: 1}]
            };

        var legendCanvas = document.createElement('canvas');
        if (opt && opt.legend && opt.legend.legendCanvas && opt.legend.legendCanvas.width)
            legendCanvas.width = opt.legendCanvas.width;
        else
            legendCanvas.width = 100;
        legendCanvas.height = 10;
        var legend;
        if (opt && opt.legend && opt.legend.element)
            legend = $(opt.legend.element);
        else
            legend = $("#sidebar-left #sidebar_content");
        legend.empty();
        var legend_title;
        if (opt && opt.legend && opt.legend.title)
            legend_title = opt.legend.title;
        else
            legend_title = "Descriptive Legend Title";
        var opacity;
        if (opt && opt.maxOpacity)
            opacity = opt.maxOpacity;
        else
            opacity = 0.8;
        var radius;
        if (opt && opt.radius)
            radius = opt.radius;
        else
            radius = 2;
        var scaleRadius;
        if (opt && opt.scaleRadius)
            scaleRadius = opt.scaleRadius;
        else
            scaleRadius = true;
        var useLocalExtrema;
        if (opt && opt.useLocalExtrema)
            useLocalExtrema = opt.useLocalExtrema;
        else
            useLocalExtrema = false;

        $('<div id="heatmapLegend"><h4>' + legend_title + '</h4><span id="min" style="float:left;"></span><span id="max" style="float:right;"></span><img id="gradient" src="" style="width:100%" /></div>').appendTo(legend);

        var legendCtx = legendCanvas.getContext('2d');
        var gradientCfg = {};

        var cfg = {
            // radius should be small ONLY if scaleRadius is true (or small radius is intended)
            "radius": radius,
            "maxOpacity": opacity,
            // scales the radius based on map zoom
            "scaleRadius": scaleRadius,
            //  "gradient": {0.45: "rgb(0,0,255)", 0.55: "rgb(0,255,255)", 0.65: "rgb(0,255,0)", 0.95: "yellow", 1.0: "rgb(255,0,0)"},

            // if set to false the heatmap uses the global maximum for colorization
            // if activated: uses the data maximum within the current map boundaries 
            //   (there will always be a red spot with useLocalExtremas true)
            "useLocalExtrema": useLocalExtrema,
            // update the legend whenever there's an extrema change
            onExtremaChange: function (data) {
                // control.updateLegend(data);

                // the onExtremaChange callback gives us min, max, and the gradientConfig
                // so we can update the legend
                $('#heatmapLegend #min').html(data.min);
                $('#heatmapLegend #max').html(data.max);
                // regenerate gradient image
                if (data.gradient !== gradientCfg) {
                    gradientCfg = data.gradient;
                    var gradient = legendCtx.createLinearGradient(0, 0, legendCanvas.width, 1);
                    for (var key in gradientCfg) {
                        gradient.addColorStop(key, gradientCfg[key]);
                    }

                    legendCtx.fillStyle = gradient;
                    legendCtx.fillRect(0, 0, 100, 10);
                    $('#heatmapLegend #gradient').attr('src', legendCanvas.toDataURL());


                }
            },
            // which field name in your data represents the latitude - default "lat"
            latField: 'lat',
            // which field name in your data represents the longitude - default "lng"
            lngField: 'lng',
            // which field name in your data represents the data value - default "value"
            valueField: 'count'
        };

        var heatmapLayer = new HeatmapOverlay(cfg);
        heatmapLayer.onAdd(this._map);
        heatmapLayer.setData(testData);
        control.heatmap_layer = heatmapLayer;
        var _this = this;
        this._map.on("resize", function () {
            var size = _this._map.getSize();
            heatmapLayer._width = size.x;
            heatmapLayer._height = size.y;
            heatmapLayer._el.style.width = size.x + 'px';
            heatmapLayer._el.style.height = size.y + 'px';
            heatmapLayer._heatmap._width = size.x;
            heatmapLayer._heatmap._height = size.y;
            heatmapLayer._heatmap._renderer.setDimensions(size.x, size.y);
            heatmapLayer._heatmap._renderer.renderAll(heatmapLayer._heatmap._store._getInternalData());
            heatmapLayer._draw();
        });
    };
    control.renderD3Layer = function (layer, collection, sld, opt) {
        var _this = this;
        var d3_layer = new L.D3(collection, opt);
        var properties_key = Object.keys(collection.features[0].properties).map(function (k) {
            return  k;
        });
        d3_layer.addTo(_this._map);
        d3_layer.onLoadSLD(sld);
        layer.layer = d3_layer;
        d3_layer.on('click', function (e) {
            //   if (parseInt(e.target.options.layer_id) === parseInt($("select#activelayer_id.layers-ui").val())) {

            var mouse = d3.mouse(e.element);
            var shapefilename = $('.sonata-bc #shapefile_select_list option:selected').map(function () {
                return  this.text;
            });

            if (shapefilename.length > 0) {

                if (d3_layer.options.filename === shapefilename[0].toLowerCase())
                {

                    if ($('#geometries_selected').length > 0)
                    {
                        var bExist = false;
                        $("#geometries_selected > option").each(function () {

                            if (parseInt(this.value) === parseInt(e.data.properties[properties_key[0]])) {
                                bExist = true;
                            }
                        });
                        if (bExist === false)
                        {
                            var fieldkey = $('.sonata-bc #shapefile_labelfield_list option:selected').map(function () {
                                return  this.text;
                            });
                            var p;
                            if (fieldkey === '' || fieldkey[0] === '' || fieldkey[0] === undefined)
                                p = e.data.properties[properties_key[1]];
                            else
                                p = e.data.properties[fieldkey[0]];
                            if (document.getElementById('geometries_selected')) {
                                var selectBoxOption = document.createElement("option"); //create new option 
                                selectBoxOption.value = e.data.properties[properties_key[0]]; //set option value 
                                selectBoxOption.text = p; //set option display text 
                                document.getElementById('geometries_selected').add(selectBoxOption, null);
                                //    alert(properties_key[0]+ ':'+ e.data.properties[properties_key[0]] + "\n" + properties_key[1] +':' + e.data.properties[properties_key[1]]);
                            }
                        }
                    }
                }
                return;
            }

            // if current show thematic map pane
            shapefilename = $('.thematicmap_div select#thematicmap_datasource option:selected').map(function () {
                return  this.text;
            });

            if (shapefilename.length > 0) {

                return;
            }
            // if current show heat map pane
            shapefilename = $('.heatmap_div select#heatmap_datasource option:selected').map(function () {
                return  this.text;
            });
            if (shapefilename.length > 0) {
                return;
            }
            var html = '';
            for (var key in e.data.properties) {
                if (e.data.properties.hasOwnProperty(key)) {
                    //   alert(e.data.properties[key]);
                    if (key === 'website' || (e.data.properties[key] !== null && e.data.properties[key] !== undefined && e.data.properties[key].length > 10 && e.data.properties[key].substr(0, 5) === 'http:'))
                        html = html + key + ":<a href='" + e.data.properties[key] + "' target='_blank'>" + e.data.properties[key] + "</a><br>";
                    else
                        html = html + key + ":" + e.data.properties[key] + "<br>";
                }
            }
            $('#sidebar-left #sidebar_content').html('');
            $('#sidebar-left #sidebar_content').html(html);


            if (window.leftSidebar && window.leftSidebar.isVisible() === false) {

                window.leftSidebar.show();
            }
            $(".sonata-bc .leftsidebar-close-control").hide();
            $('#sidebar-left #sidebar_content').css('visibility', 'visible');

        });
        d3_layer.on("mouseover", function (e) {
            e.element.fill = $(e.element).css('fill');

            e.element.fill_opacity = $(e.element).css('fill-opacity');

            if (e.element.fill !== 'none' || e.element.fill_opacity !== '0')
            {
                d3.select(e.element).style({'fill': 'red', 'fill-opacity': '0.8'});
            }
            d3.select(e.element).style('cursor', 'pointer');
        });
        d3_layer.on('mousemove', function (e) {

            //    if (parseInt(e.target.options.layer_id) === parseInt($("select#activelayer_id.layers-ui").val())) {

            var shapefilename = $('.sonata-bc #shapefile_select_list option:selected').map(function () {
                return  this.text;
            });
            if (shapefilename.length === 1 && d3_layer.options.filename === shapefilename[0].toLowerCase())
            {
                var p;
                var fieldkey = '';
                var mouse = L.DomEvent.getMousePosition(e.originalEvent, _this._map._container);
                fieldkey = $('.sonata-bc #shapefile_labelfield_list option:selected').map(function () {
                    return  this.text;
                });
                if (e.target.options.tip_field !== '' && e.target.options.tip_field !== null && e.target.options.tip_field !== undefined) {
                    {
                        p = e.data.properties[e.target.options.tip_field ];
                        if (e.target.options.tip_percentage === true && p !== '' && p !== undefined) {
                            if (e.target.options.tip_times100 === true) {
                                p = parseFloat(p) * 100;
                            }
                            if (e.target.options.tip_number !== undefined && e.target.options.tip_number !== null && e.target.options.tip_number !== '') {
                                p = parseFloat(p).toFixed(parseInt(e.target.options.tip_number));
                            }
                            p = p + "%";
                        }

                    }
                }
                else {
                    if (fieldkey === '' || fieldkey[0] === '' || fieldkey[0] === undefined)
                    {
                        p = e.data.properties[properties_key[1]];
                        if (e.target.options.tip_percentage === true && p !== '' && p !== undefined) {
                            if (e.target.options.tip_times100 === true) {
                                p = parseFloat(p) * 100;
                            }
                            if (e.target.options.tip_number !== undefined && e.target.options.tip_number !== null && e.target.options.tip_number !== '') {
                                p = parseFloat(p).toFixed(parseInt(e.target.options.tip_number));
                            }
                            p = p + "%";
                        }
                    }
                    else
                    {
                        p = e.data.properties[fieldkey[0]];
                        if (e.target.options.tip_percentage === true && p !== '' && p !== undefined) {
                            if (e.target.options.tip_times100 === true) {
                                p = parseFloat(p) * 100;
                            }
                            if (e.target.options.tip_number !== undefined && e.target.options.tip_number !== null && e.target.options.tip_number !== '') {
                                p = parseFloat(p).toFixed(parseInt(e.target.options.tip_number));
                            }
                            p = p + "%";
                        }
                    }
                }

                options.map_tooltip.classed("hidden", false)
                        .attr("style", "left:" + (mouse.x + 30) + "px;top:" + (mouse.y - 35) + "px")
                        .html(p);
            }
            // }
        });
        d3_layer.on('mouseout', function (e) {
            options.map_tooltip.classed("hidden", true);
            d3.select(e.element).style({'fill': e.element.fill, 'fill-opacity': e.element.fill_opacity});
            d3.select(e.element).style('cursor', 'default');
        });
        if (opt.thematicmap && opt.thematicmap.thematicmap === true) {
            if (d3_layer.options) {
                d3_layer.options.thematicmap = true;
                d3_layer.options.thematicmap_rule = opt.thematicmap;
                if (d3_layer.renderThematicMap)
                    d3_layer.renderThematicMap(d3_layer.options.thematicmap_rule);
            }
        }
    };

    control.renderClusterLayer = function (layer, collection) {
        var _this = this;

        //    _this._map.spin(true);

//                 
        var properties_key = Object.keys(collection.features[0].properties).map(function (k) {
            return  k;
        });

//                var rmax = 30;
//                var highlightStyle = {
//                    color: '#2262CC',
//                    weight: 3,
//                    opacity: 0.6,
//                    fillOpacity: 0.65,
//                    fillColor: '#2262CC'
//                };
        var geoJsonLayer = L.geoJson(collection, {
            id: "9",
            style: {
                fillColor: "#A3C990",
                color: "#000",
                weight: 1,
                opacity: 1,
                fillOpacity: 0.4
            },
            pointToLayer: function (feature, latlng) {
                return new L.CircleMarker(latlng, {
                    radius: 5,
                    fillColor: "#A3C990",
                    color: "#000",
                    weight: 1,
                    opacity: 1,
                    fillOpacity: 0.4
                });
            },
            onEachFeature: function (feature, layer) {
                (function (layer, properties) {
                    layer.on('mouseover', function (e) {
                        var layer = e.target;
                        layer.setStyle({
                            weight: 2,
                            color: 'red',
                            dashArray: '',
                            cursor: 'pointer',
                            fillOpacity: 0.7
                        });
                        //    $(this).fill = $(this).css('fill');
                        //    $(this).fill_opacity = $(this).css('fill-opacity');
                        // d3.select(e.target).style({'fill': 'red'});
//                                                $(e.target).css('fill', 'red');
//                                                $(e.target).css('fill-opacity', '0.8');
                        $(this).css('cursor', 'pointer');
                    });
                    layer.on('mouseout', function (e) {


                        geoJsonLayer.resetStyle(e.target);
                        options.map_tooltip.classed("hidden", true);
                        //      $(this).css('fill', $(this).fill);
                        //      $(this).css('fill-opacity', $(this).fill_opacity);
                        $(this).css('cursor', 'default');
                    });
                    layer.on('mousemove', function (e) {                         //    if (parseInt(e.target.options.layer_id) === parseInt($("select#activelayer_id.layers-ui").val())) {

                        var shapefilename = $('.sonata-bc #shapefile_select_list option:selected').map(function () {
                            return  this.text;
                        });
                        if (shapefilename === '' || shapefilename[0] === undefined)
                        {
                            var p;
                            var fieldkey = '';
                            var mouse = L.DomEvent.getMousePosition(e.originalEvent, _this._map._container);
                            fieldkey = $('.sonata-bc #shapefile_labelfield_list option:selected').map(function () {
                                return  this.text;
                            });
                            if (e.target.options.tip_field !== undefined && e.target.options.tip_field !== '' && e.target.options.tip_field !== null) {
                                p = properties[e.target.options.tip_field ];
                            }
                            else {

                                if (fieldkey === undefined || fieldkey === null || fieldkey === '' || (typeof fieldkey === 'object' && (fieldkey[0] === null || fieldkey[0] === '' || fieldkey[0] === undefined)))
                                    p = properties[properties_key[1]];
                                else
                                    p = properties[fieldkey[0]];
                            }
                            options.map_tooltip.classed("hidden", false)
                                    .attr("style", "left:" + (mouse.x + 30) + "px;top:" + (mouse.y - 35) + "px")
                                    .html(p);
                        }

                    });
                    layer.on('click', function (e) {
                        var html = '';
                        for (var key in properties) {
                            if (properties.hasOwnProperty(key)) {
                                //alert(e.data.properties[key].substring(0, 5));
                                if (properties[key] !== 'null' && properties[key] !== null && properties[key] !== undefined && properties[key].length > 10 && (key === 'website' || properties[key].substring(0, 5) === 'http:'))
                                    html = html + key + ":<a href='" + properties[key] + "' target='_blank'>" + properties[key] + "</a><br>";
                                else
                                    html = html + key + ":" + properties[key] + "<br>";
                            }
                        }
                        $('#sidebar-left #sidebar_content').html('');
                        $('#sidebar-left #sidebar_content').html(html);
                        if (window.leftSidebar && window.leftSidebar.isVisible() === false) {

                            window.leftSidebar.show();
                        }
                        $(".sonata-bc .leftsidebar-close-control").hide();
                        $('#sidebar-left #sidebar_content').css('visibility', 'visible');
                    });
                })(layer, feature.properties);
                //layer.bindPopup(feature.properties.Name);
            }
        });
        var markerclusters = new L.MarkerClusterGroup({
            maxClusterRadius: 80,
//                                    iconCreateFunction: function(cluster) {
//                                        var markers = cluster.getAllChildMarkers();
//                                        var n = 0;
//                                        for (var i = 0; i < markers.length; i++) {
//                                            n += markers[i].number;
//                                        }
//                                        return L.divIcon({html: n, className: 'mycluster', iconSize: L.point(40, 40)});
//                                    },
            //Disable all of the defaults:
            spiderfyOnMaxZoom: true, showCoverageOnHover: true, zoomToBoundsOnClick: true
        });
        markerclusters.addLayer(geoJsonLayer, true);
        //   _this._map.addLayer(markerclusters);
        //   geoJsonLayer.addTo(_this._map);
        markerclusters.addTo(_this._map);
        layer.layer = markerclusters;

        //  _this._map.spin(false);

//var markers = new L.MarkerClusterGroup();
//
//			for (var i = 0; i < addressPoints.length; i++) {
//				var a = addressPoints[i];
//				var title = a[2];
//				var marker = new L.Marker(new L.LatLng(a[0], a[1]), { title: title });
//				marker.bindPopup(title);
//				markers.addLayer(marker);
//			}
//			for (var i = 0; i < addressPoints2.length; i++) {
//				var a = addressPoints[i];
//				var title = a[2];
//				var marker = new L.Marker(new L.LatLng(a[0], a[1]), { title: title });
//				marker.bindPopup(title);
//				markers.addLayer(marker);
//			}
//
//			map.addLayer(markers);


    };

    control.defineClusterIcon = function (cluster) {
        var children = cluster.getAllChildMarkers(),
                n = children.length, //Get number of markers in cluster
                strokeWidth = 1, //Set clusterpie stroke width
                //  r = rmax - 2 * strokeWidth - (n < 10 ? 12 : n < 100 ? 8 : n < 1000 ? 4 : 0), //Calculate clusterpie radius...
                iconDim = (20 + strokeWidth) * 2, //r + strokeWidth) * 2, //...and divIcon dimensions (leaflet really want to know the size)
                data = d3.nest() //Build a dataset for the pie chart
                .key(function (d) {
                    return d.feature.properties[0];
                })
                .entries(children, d3.map),
                //bake some svg markup
                html = bakeThePie({data: data,
                    valueFunc: function (d) {
                        return d.values.length;
                    },
                    strokeWidth: 1,
                    outerRadius: 20, //r,
                    innerRadius: 10, //r - 10,
                    pieClass: 'cluster-pie',
                    pieLabel: n,
                    pieLabelClass: 'marker-cluster-pie-label',
                    pathClassFunc: function (d) {
                        return "category-" + d.data.key;
                    },
                    pathTitleFunc: function (d) {
                        return 10; //metadata.fields[categoryField].lookup[d.data.key] + ' (' + d.data.values.length + ' accident' + (d.data.values.length != 1 ? 's' : '') + ')';
                    }
                }),
                //Create a new divIcon and assign the svg markup to the html property
                myIcon = new L.DivIcon({
                    html: html,
                    className: 'marker-cluster',
                    iconSize: new L.Point(iconDim, iconDim)
                });
        return myIcon;
    };
    /*function that generates a svg markup for the pie chart*/
    control.bakeThePie = function (options) {
        /*data and valueFunc are required*/
        if (!options.data || !options.valueFunc) {
            return '';
        }
        var data = options.data,
                valueFunc = options.valueFunc,
                r = options.outerRadius ? options.outerRadius : 28, //Default outer radius = 28px
                rInner = options.innerRadius ? options.innerRadius : r - 10, //Default inner radius = r-10
                strokeWidth = options.strokeWidth ? options.strokeWidth : 1, //Default stroke is 1
                pathClassFunc = options.pathClassFunc ? options.pathClassFunc : function () {
                    return '';
                }, //Class for each path
                pathTitleFunc = options.pathTitleFunc ? options.pathTitleFunc : function () {
                    return '';
                }, //Title for each path
                pieClass = options.pieClass ? options.pieClass : 'marker-cluster-pie', //Class for the whole pie
                pieLabel = options.pieLabel ? options.pieLabel : d3.sum(data, valueFunc), //Label for the whole pie
                pieLabelClass = options.pieLabelClass ? options.pieLabelClass : 'marker-cluster-pie-label', //Class for the pie label

                origo = (r + strokeWidth), //Center coordinate
                w = origo * 2, //width and height of the svg element
                h = w,
                donut = d3.layout.pie(),
                arc = d3.svg.arc().innerRadius(rInner).outerRadius(r);
        //Create an svg element
        var svg = document.createElementNS(d3.ns.prefix.svg, 'svg');
        //Create the pie chart
        var vis = d3.select(svg)
                .data([data])
                .attr('class', pieClass)
                .attr('width', w)
                .attr('height', h);
        var arcs = vis.selectAll('g.arc')
                .data(donut.value(valueFunc))
                .enter().append('svg:g')
                .attr('class', 'arc')
                .attr('transform', 'translate(' + origo + ',' + origo + ')');
        arcs.append('svg:path')
                .attr('class', pathClassFunc)
                .attr('stroke-width', strokeWidth)
                .attr('d', arc)
                .append('svg:title')
                .text(pathTitleFunc);
        vis.append('text')
                .attr('x', origo)
                .attr('y', origo)
                .attr('class', pieLabelClass)
                .attr('text-anchor', 'middle')
                //.attr('dominant-baseline', 'central')
                /*IE doesn't seem to support dominant-baseline, but setting dy to .3em does the trick*/
                .attr('dy', '.3em')
                .text(pieLabel);
        //Return the svg-markup rather than the actual element
        return serializeXmlNode(svg);
    };
    /*Function for generating a legend with the same categories as in the clusterPie*/
    control.renderLegend = function () {
        var data = d3.entries(metadata.fields[categoryField].lookup),
                legenddiv = d3.select('body').append('div')
                .attr('id', 'legend');
        var heading = legenddiv.append('div')
                .classed('legendheading', true)
                .text(metadata.fields[categoryField].name);
        var legenditems = legenddiv.selectAll('.legenditem')
                .data(data);
        legenditems
                .enter()
                .append('div')
                .attr('class', function (d) {
                    return 'category-' + d.key;
                })
                .classed({'legenditem': true})
                .text(function (d) {
                    return d.value;
                });
    };
    /*Helper function*/
    control.serializeXmlNode = function (xmlNode) {
        if (typeof window.XMLSerializer !== "undefined") {
            return (new window.XMLSerializer()).serializeToString(xmlNode);
        } else if (typeof xmlNode.xml !== "undefined") {
            return xmlNode.xml;
        }
        return "";
    };
    control.overlayToolButtons = function () {
        var _this = this;
        $('div.sidebar_content div.section.overlay-layers div#move_overlayer_up').unbind('click');
        $('div.sidebar_content div.section.overlay-layers div#move_overlayer_up').on('click', function () {
            var selected = $('div.sidebar_content div.section.overlay-layers ul.overlay_ul > li.overlay_li.selected');
            if (selected.prev()) {
                selected.insertBefore(selected.prev());
                _this.reorderLayers();
            }

        });
        $('div.sidebar_content div.section.overlay-layers div#move_overlayer_down').unbind('click');
        $('div.sidebar_content div.section.overlay-layers div#move_overlayer_down').on('click', function () {
            var selected = $('div.sidebar_content div.section.overlay-layers ul.overlay_ul > li.overlay_li.selected');
            if (selected.next()) {
                selected.insertAfter(selected.next());
                _this.reorderLayers();
            }

        });
        // save current layers status to server
        $('div.sidebar_content div.section.overlay-layers div#overlayers_plus').unbind('click');
        $('div.sidebar_content div.section.overlay-layers div#overlayers_plus').on('click', function () {
            $.ajax({
                url: Routing.generate('default_mapoverlayselectionform', {'_locale': window.locale}),
                type: 'GET',
                beforeSend: function () {

                    //      _this._map.spin(true);
                },
                complete: function () {
                    //        _this._map.spin(false);
                },
                error: function () {
                    //       _this._map.spin(false);
                },
                //Ajax events
                success: completeHandler = function (response) {


                    $("#sidebar-left #sidebar_content").html(response);
                },
                // Form data
                data: {},
                //Options to tell JQuery not to process data or worry about content-type
                cache: false,
                contentType: false,
                processData: false
            });

        });
        $('div.sidebar_content div.section.overlay-layers div#overlayers_minus').unbind('click');
        $('div.sidebar_content div.section.overlay-layers div#overlayers_minus').on('click', function () {
            var selected = $('div.sidebar_content div.section.overlay-layers ul.overlay_ul > li.overlay_li.selected');
            if (selected.data("index") !== undefined && _this._map.dataLayers[selected.data("index")] && _this._map.dataLayers[selected.data("index")].index_id !== -1) {
                if (confirm('Do you want to remove it from overlayers?')) {
                    if (_this._map.dataLayers[selected.data("index")] && _this._map.dataLayers[selected.data("index")].layer) {
                        _this._map.removeLayer(_this._map.dataLayers[selected.data("index")].layer);
                    }
                    _this._map.dataLayers.splice(selected.data("index"), 1);
                    selected.remove();
                    _this.reorderLayers();
                    $('div.sidebar_content div.section.overlay-layers ul.overlay_ul').hide().fadeIn('fast');

                }
            }
        });
        $('div.sidebar_content div.section.overlay-layers div#overlayers_zoom_to_layer').unbind('click');
        $('div.sidebar_content div.section.overlay-layers div#overlayers_zoom_to_layer').on('click', function () {
            var selected = $('div.sidebar_content div.section.overlay-layers ul.overlay_ul > li.overlay_li.selected');
            if (selected.data("index") !== undefined && _this._map.dataLayers[selected.data("index")] && _this._map.dataLayers[selected.data("index")].bounds) {
                //  alert("zoom to level");
                var bound = _this._map.dataLayers[selected.data("index")].bounds;
                _this._map.fitBounds([[bound[0][1], bound[0][0]], [bound[1][1], bound[1][0]]]);

            }
            else {
                var bounds = _this._map.getBounds();
                alert(JSON.stringify(bounds));
                _this._map.fitBounds(_this._map.getBounds());
            }
        });
        // save current layers status to server
        $('div.sidebar_content div.section.overlay-layers div#overlayers_selectall').unbind('click');
        $('div.sidebar_content div.section.overlay-layers div#overlayers_selectall').on('click', function () {
            $('div.sidebar_content div.section.overlay-layers ul.overlay_ul > li.overlay_li').map(function () {
                $(this).find("input[type=checkbox]").prop('checked', true)
                        .trigger('change');
            });
        });
        $('div.sidebar_content div.section.overlay-layers div#overlayers_unselectall').unbind('click');
        $('div.sidebar_content div.section.overlay-layers div#overlayers_unselectall').on('click', function () {
            $('div.sidebar_content div.section.overlay-layers ul.overlay_ul > li.overlay_li').map(function () {
                $(this).find("input[type=checkbox]").prop('checked', false)
                        .trigger('change');
            });
        });
        $('div.sidebar_content div.section.overlay-layers ul.overlay_ul > li.overlay_li div.layer_legend_icon').unbind('click');
        $('div.sidebar_content div.section.overlay-layers ul.overlay_ul > li.overlay_li div.layer_legend_icon').click(function (e) {

            if ($(this).find("i").hasClass("fa-plus")) {
                $(this).find("i").removeClass("fa-plus");
                $(this).find("i").addClass("fa-minus");
                if ($(this).parent().find(".layer_legend").hasClass('hidden')) {
                    $(this).parent().find(".layer_legend").removeClass('hidden');
                }


            }
            else {
                $(this).find("i").removeClass("fa-minus");
                $(this).find("i").addClass("fa-plus");
                $(this).parent().find(".layer_legend").addClass('hidden');
            }

//            $('div.sidebar_content div.section.overlay-layers ul > li .layername_label').map(function () {
//                if (_that !== this) {
//                    $(this).parent().removeClass("selected");
//                }
//            });
        });
        $('div.sidebar_content div.section.overlay-layers ul.overlay_ul > li.overlay_li .layername_label').unbind('click');
        $('div.sidebar_content div.section.overlay-layers ul.overlay_ul > li.overlay_li .layername_label').click(function (e) {
            var _that = this;
            $('div.sidebar_content div.section.overlay-layers ul.overlay_ul > li.overlay_li .layername_label').map(function () {
                if (_that !== this) {
                    $(this).parent().removeClass("selected");
                }
            });
            $('div.sidebar_content div.section.overlay-layers ul.overlay_ul > li.overlay_li > ul.layer_legend > li.overlay_group_li .group_layername_label').map(function () {
                if (_that !== this) {
                    $(this).parent().removeClass("selected");
                }

            });
            if ($(this).parent().hasClass("selected"))
            {
                $(this).parent().removeClass("selected");

                $('div.sidebar_content div.section.overlay-layers div#overlayers_zoom_to_layer').addClass('disabled');
                $('div.sidebar_content div.section.overlay-layers div#overlayers_minus').addClass('disabled');
                $('div.sidebar_content div.section.overlay-layers div#move_overlayer_up').addClass('disabled');
                $('div.sidebar_content div.section.overlay-layers div#move_overlayer_down').addClass('disabled');

            }
            else
            {
                $(this).parent().addClass("selected");
                $('div.sidebar_content div.section.overlay-layers div#overlayers_zoom_to_layer').removeClass('disabled');
                $('div.sidebar_content div.section.overlay-layers div#overlayers_minus').removeClass('disabled');
                $('div.sidebar_content div.section.overlay-layers div#move_overlayer_up').removeClass('disabled');
                $('div.sidebar_content div.section.overlay-layers div#move_overlayer_down').removeClass('disabled');
            }

            _this.reorderLayers();
            e.stopPropagation();
        });




        $('div.sidebar_content div.section.overlay-layers ul.overlay_ul > li.overlay_li > ul.layer_legend > li.overlay_group_li .group_layername_label').unbind('click');
        $('div.sidebar_content div.section.overlay-layers ul.overlay_ul > li.overlay_li > ul.layer_legend > li.overlay_group_li .group_layername_label').click(function (e) {
            var _that = this;
            $('div.sidebar_content div.section.overlay-layers ul.overlay_ul > li.overlay_li .layername_label').map(function () {
                if (_that !== this) {
                    $(this).parent().removeClass("selected");
                }

            });
            $('div.sidebar_content div.section.overlay-layers ul.overlay_ul > li.overlay_li > ul.layer_legend > li.overlay_group_li .group_layername_label').map(function () {
                if (_that !== this) {
                    $(this).parent().removeClass("selected");
                }

            });
            if ($(this).parent().hasClass("selected"))
            {
                $(this).parent().removeClass("selected");
//                $('div.sidebar_content div.section.overlay-layers div#overlayers_zoom_to_layer').addClass('disabled');
//                $('div.sidebar_content div.section.overlay-layers div#overlayers_minus').addClass('disabled');
//                $('div.sidebar_content div.section.overlay-layers div#move_overlayer_up').addClass('disabled');
//                $('div.sidebar_content div.section.overlay-layers div#move_overlayer_down').addClass('disabled');
//
            }
            else
            {
                $(this).parent().addClass("selected");
//                $('div.sidebar_content div.section.overlay-layers div#overlayers_zoom_to_layer').removeClass('disabled');
//                $('div.sidebar_content div.section.overlay-layers div#overlayers_minus').removeClass('disabled');
                $('div.sidebar_content div.section.overlay-layers div#move_overlayer_up').addClass('disabled');
                $('div.sidebar_content div.section.overlay-layers div#move_overlayer_down').addClass('disabled');
            }

            _this.reorderLayers();
            e.stopPropagation();
        });


        // save current layers status to server
        $('div.sidebar_content div.section.overlay-layers div#save_overlayers_index').unbind('click');
        $('div.sidebar_content div.section.overlay-layers div#save_overlayers_index').on('click', function () {
            var formData = new FormData();
            var activelayer = null;
            var selected = $('div.sidebar_content div.section.overlay-layers ul > li.selected');
            if (selected.data("index") !== undefined && _this._map.dataLayers[selected.data("index")]) {
                activelayer = _this._map.dataLayers[selected.data("index")];
            }
            var mapcenter = _this._map.getCenter();
            var mapZoomLevel = _this._map.getZoom();
            var basemap = $('div.sidebar_content div.section input[type=radio]:checked').val();
            alert(basemap);
            if (activelayer === null)
                formData.append('activelayer', null);
            else
                formData.append('activelayer', JSON.stringify({'layerId': activelayer.layerId, 'layerType': activelayer.layerType, 'filename': activelayer.filename}));
            formData.append('mapcenter', JSON.stringify(mapcenter));
            formData.append('zoomlevel', mapZoomLevel);
            formData.append('basemap', basemap);
            var layerdata = [];




            $('div.sidebar_content div.section.overlay-layers ul > li').map(function (i) {
                if ($(this).data("index") !== undefined) {
                    var defaultShowOnMap = $(this).find("input[type=checkbox]").is(':checked');
                    alert(defaultShowOnMap + "   " + $(this).data("index"));
                    var layer = _this._map.dataLayers[$(this).data("index")];
                    layerdata.push(JSON.stringify({'id': layer.layerId
                        , 'type': layer.layerType
                        , 'filename': layer.filename
                        , 'index': i
                        , 'defaultShowOnMap': defaultShowOnMap
                    }));
                }
            });
            formData.append('data', layerdata);
            $.ajax({
                url: Routing.generate('leaflet_save_mapoverlayers', {'_locale': window.locale}),
                type: 'POST',
                beforeSend: function () {

                    //      _this._map.spin(true);
                },
                complete: function () {
                    //        _this._map.spin(false);
                },
                error: function () {
                    //       _this._map.spin(false);
                },
                //Ajax events
                success: completeHandler = function (response) {
                    var result = response;
                    if (response === '' || response === undefined || response === null)
                        return;
                    if (typeof result !== 'object')
                        result = JSON.parse(result);
                    if (result.success !== true) {
                        // if load data not suceess
                        alert(result.message);
                        return;
                    }
                },
                // Form data
                data: formData,
                //Options to tell JQuery not to process data or worry about content-type
                cache: false,
                contentType: false,
                processData: false
            });

        });

    };
    control.addOverlayChildItem = function (pitem, layer, i, opt, bRefeshButton) {
        var _this = this;
        if ($(pitem).find("ul").length === 0) {
            $(pitem).append("<ul class='layer_legend hidden'></ul>");
        }
        var ul = $(pitem).find("ul");

        var subitem = $('<li class="overlay_group_li" data-layerId="' + layer.layerId + '" data-layerName="' + layer.layerName + '" data-groupName="' + layer.groupName + '">')
                .tooltip({
                    placement: 'top'
                })
                .appendTo(ul);

        subitem.data('index', i);
        subitem.css('border-bottom', '1px grey dotted');

        var label_div = $("<div>").addClass('group_layername_label');
        var label = $('<label>')
                .appendTo(label_div);

        var checked = _this._map.hasLayer(layer.layer);
        var input = $('<input>')
                .attr('type', 'checkbox')
                .prop('checked', checked)
                .appendTo(subitem);

        //    var legend_icon = $("<div class='layer_legend_icon' style='display:inline-block'><i class='fa fa-plus blue'></i></div>").appendTo(subitem);
        var title = '';
        if (layer.layerTitle)
            title = layer.layerTitle;
        else
            title = layer.layerName;
        var legend_label = I18n.t('javascripts.map.layers.' + title);
        if (legend_label === undefined || legend_label === null || legend_label.indexOf('missing ') === 1)
        {

            label.append(title);
        }
        else
        {

            label.append(legend_label);
        }

        label_div.appendTo(subitem);
        label_div.css('display', 'inline-block');
        input.on('change', function () {
            checked = input.is(':checked');
            if (checked) {
                if (!layer.layer)
                {
                    control.loadLayer(layer, opt);
                }
                else
                {
                    if (layer.layer)
                        _this._map.addLayer(layer.layer);
                }
            } else {
                if (layer.layer)
                    _this._map.removeLayer(layer.layer);
            }
            if (layer.layer)
                _this._map.fire('overlaylayerchange', {layer: layer.layer});
        });

        if (layer.defaultShowOnMap === true)
        {
            $(input).prop('checked', true)
                    .trigger('change');
        }
        if (bRefeshButton === true)
            _this.overlayToolButtons();

    };
    control.addOverlayItem = function (layer, i, opt, bRefeshButton) {
        var overlay_layers_ul = $(".leaflet-control-container .section.overlay-layers > ul.overlay_ul");
        var _this = this;
        var item = $('<li class="overlay_li">')
                .tooltip({
                    placement: 'top'
                })
                .appendTo(overlay_layers_ul);
        item.data('index', i);
        item.css('border-bottom', '1px grey dotted');

        var label_div = $("<div>").addClass("layername_label");
        var label = $('<label>')
                .appendTo(label_div);

        var checked = _this._map.hasLayer(layer.layer);
        var input = $('<input>')
                .attr('type', 'checkbox')
                .prop('checked', checked)
                .appendTo(item);

        var legend_icon = $("<div class='layer_legend_icon'><i class='fa fa-plus blue'></i></div>").appendTo(item);
        var title = '';
        if (layer.layerTitle)
            title = layer.layerTitle;
        else
            title = layer.layerName;
        var legend_label = I18n.t('javascripts.map.layers.' + title);
        if (legend_label === undefined || legend_label === null || legend_label.indexOf('missing ') === 1)
        {
            //   if (title.length > 25)
            //       label.append(title.substr(0, 22) + "...");
            //   else
            label.append(title);
        }
        else
        {
            //  if (legend_label.length > 25)
            //      label.append(legend_label.substr(0, 22) + "...");
            //   else
            label.append(legend_label);
        }

        label_div.appendTo(item);
        label_div.css('display', 'inline-block');
        switch (layer.layerType) {
            case 'clustermap':
                var legend = _this.createClusterLegend();
                if (legend !== null)
                    legend.appendTo(item);
                break;
            case 'heatmap':
                var legend = _this.createHeatmapLegend(layer.sld);
                if (legend !== null)
                    legend.appendTo(item);
                break;
            case 'thematicmap':
                var legend = _this.createThematicmapLegend(layer.sld);
                if (legend !== null)
                    legend.appendTo(item);
                break;
            case 'wms':
                var legend = _this.createWMSLegend(layer);
                if (legend !== null)
                    legend.appendTo(item);

                break;
            case 'group':
                $(item).data("group", true);
                if (layer.layers) {
                    $.map(layer.layers, function (data, index) {
                        data.layerId = data.id;
                        _this.addOverlayChildItem(item, data, index, opt, bRefeshButton);
                    });
                }
                break;
            default:
                if (layer.sld) {
                    var legend = _this.createLegend(layer.sld);
                    if (legend !== null)
                        legend.appendTo(item);
                }
                break;
        }
        input.on('change', function () {


            checked = input.is(':checked');
            if ($(this).parent().data("group") === true)
            {

                $(this).parent().find("li.overlay_group_li input[type='checkbox']").map(function () {

                    $(this).prop("checked", checked).trigger('change');
                });
            }
            else {
                if (checked) {

                    if (!layer.layer)
                    {
                        control.loadLayer(layer, opt);
                    }
                    else
                    {
                        if (layer.layer)
                            _this._map.addLayer(layer.layer);
                    }

                } else {
                    if (layer.layer)
                        _this._map.removeLayer(layer.layer);
                }
                if (layer.layer)
                    _this._map.fire('overlaylayerchange', {layer: layer.layer});
            }
        });

        if (layer.defaultShowOnMap === true)
        {
            $(input).prop('checked', true)
                    .trigger('change');
        }
        if (bRefeshButton === true)
            _this.overlayToolButtons();
    };
    control.createWMSLegend = function (layer) {

        if (layer.hostName === undefined || layer.layerName === undefined)
            return null;
        var legend = $("<div class='layer_legend hidden'>");
        var ul = $("<ul>").appendTo(legend);
        ul.append('<li><img src="' + "http://" + layer.hostName + "?REQUEST=GetLegendGraphic&VERSION=1.0.0&FORMAT=image/png&LAYER=" + layer.layerName + '"></li>');
        return legend;
    };
    control.createHeatmapLegend = function (sld) {
        var legend = $("<div class='layer_legend hidden'>");
        var ul = $("<ul>").appendTo(legend);
        if (typeof sld !== 'object')
            sld = JSON.parse(sld);
        if (sld.gradient === undefined)
            return null;
        if (typeof sld.gradient !== 'object')
            sld.gradient = JSON.parse(unescape(sld.gradient));
        var array = [];
        for (var key in sld.gradient) {
            array.push([key, sld.gradient[key]]);
        }
        array.sort();


        for (var i = 0; i < array.length; i++)
        {
            ul.append('<li><div tabindex="0" style="display:inline-block; margin: 2px 6px 2px 2px; width: 20px; height: 15px; background-color: ' + array[i][1] + '" ></div>' + array[i][0] + '</li>');
        }
        return legend;
    };
    control.createThematicmapLegend = function (sld) {
        var legend = $("<div class='layer_legend hidden'>");
        var ul = $("<ul>").appendTo(legend);

        if (typeof sld !== 'object')
            sld = JSON.parse(sld);
        if (sld.categories === undefined)
            return null;

        if (typeof sld.categories !== 'object')
            sld.categories = JSON.parse(sld.categories);
        if (typeof sld.category !== 'object')
            sld.category = JSON.parse(sld.category);

        var keys = Object.keys(sld.categories);
        for (var key in keys) {

            ul.append('<li><div tabindex="0" style="display:inline-block; margin: 2px 6px 2px 2px; width: 20px; height: 15px;background-color:' + sld.categories[key].fill + ';border: ' + Math.round(sld.category.width) + 'px solid ' + sld.categories[key].boundary + ';" ></div>' + sld.categories[key].from + " - " + sld.categories[key].to + '</li>');
        }
        return legend;
    };
    control.createClusterLegend = function () {
        var legend = $("<div class='layer_legend hidden'>");
        var ul = $("<ul>").appendTo(legend);
        ul.append('<li><div tabindex="0" style="display:inline-block; margin: 2px 6px 2px 2px; width: 40px; height: 40px; " class="marker-cluster marker-cluster-small"><div><span>5</span></div></div>< 10</li>');
        ul.append('<li><div tabindex="0" style="display:inline-block;margin: 2px 6px 2px 2px;  width: 40px; height: 40px;" class="marker-cluster marker-cluster-medium"><div><span>15</span></div></div>10 - 100 </li>');
        ul.append('<li><div tabindex="0" style="display:inline-block;margin: 2px 6px 2px 2px;  width: 40px; height: 40px;" class="marker-cluster marker-cluster-large"><div><span>150</span></div></div>> 100</li>');

        return legend;
    };
    control.createLegend = function (sld) {
        if (typeof sld !== 'object')
            sld = JSON.parse(sld);


        if (sld === undefined || sld.FeatureTypeStyle === undefined || sld.FeatureTypeStyle === null)
            return null;
        var legend = $("<div class='layer_legend hidden'>");
        var ul = $("<ul>").appendTo(legend);
        var keys = Object.keys(sld.FeatureTypeStyle);

        for (var key in keys) {

            var varFeatureTypeStyle = sld.FeatureTypeStyle[key];

            if (typeof varFeatureTypeStyle !== 'object' && varFeatureTypeStyle !== undefined)
                varFeatureTypeStyle = JSON.parse(varFeatureTypeStyle);

            if (typeof varFeatureTypeStyle === 'object' && varFeatureTypeStyle !== undefined && varFeatureTypeStyle.Rule !== undefined) {
                var rule = varFeatureTypeStyle.Rule;
                var legendCanvas = document.createElement('canvas');
                legendCanvas.width = 20;
                legendCanvas.height = 15;
                var centerX = legendCanvas.width / 2;
                var centerY = legendCanvas.height / 2;
                var legendCtx = legendCanvas.getContext('2d');
                var rule_name = '';
                var literal_name = false;
                if (rule.Filter !== undefined) {
                    rule_name = rule.Name;
                    if (rule.Filter.PropertyIsEqualTo) {
                        if ((rule_name === undefined || rule_name === null || rule_name.trim() === '') && (rule.Filter.PropertyIsEqualTo.Literal)) {
                            rule_name = rule.Filter.PropertyIsEqualTo.Literal;
                            literal_name = true;
                        }
                        if (rule.PointSymbolizer && rule.PointSymbolizer.Graphic && rule.PointSymbolizer.Graphic.Mark && rule.PointSymbolizer.Graphic.Mark.WellKnownName) {

                            switch (rule.PointSymbolizer.Graphic.Mark.WellKnownName) {
                                case 'square':
                                    legendCtx.beginPath();
                                    legendCtx.rect((legendCanvas.width - rule.PointSymbolizer.Graphic.Size) / 2, (legendCanvas.height - rule.PointSymbolizer.Graphic.Size) / 2, rule.PointSymbolizer.Graphic.Size, rule.PointSymbolizer.Graphic.Size);
                                    break;
                                case 'star':
                                    legendCtx.moveTo(centerX, centerY - rule.PointSymbolizer.Graphic.Size / 1.6);
                                    legendCtx.lineTo(centerX + rule.PointSymbolizer.Graphic.Size / 2.0, centerY);
                                    legendCtx.lineTo(centerX, centerY + rule.PointSymbolizer.Graphic.Size / 1.6);
                                    legendCtx.lineTo(centerX - rule.PointSymbolizer.Graphic.Size / 2.0, centerY);
                                    legendCtx.closePath();
                                    break;
                                case 'circle':
                                    var radius = rule.PointSymbolizer.Graphic.Size / 2.0;
                                    legendCtx.beginPath();
                                    legendCtx.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
                                    break;
                                case 'triangle':
                                    legendCtx.beginPath();
                                    legendCtx.moveTo(centerX, centerY - rule.PointSymbolizer.Graphic.Size / 2.0);
                                    legendCtx.lineTo(centerX + rule.PointSymbolizer.Graphic.Size / 2.0, centerY + rule.PointSymbolizer.Graphic.Size / 2.0);
                                    legendCtx.lineTo(centerX - rule.PointSymbolizer.Graphic.Size / 2.0, centerY + rule.PointSymbolizer.Graphic.Size / 2.0);
                                    legendCtx.closePath();
                                    break;
                                default:
                                    var centerX = legendCanvas.width / 2;
                                    var centerY = legendCanvas.height / 2;
                                    var radius = rule.PointSymbolizer.Graphic.Size / 2.0;
                                    legendCtx.beginPath();
                                    legendCtx.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
                                    break;
                            }
                            if (rule.PointSymbolizer.Graphic.Mark.Fill && rule.PointSymbolizer.Graphic.Mark.Fill.fill)
                                legendCtx.fillStyle = rule.PointSymbolizer.Graphic.Mark.Fill.fill.trim();
                            else
                                legendCtx.fillStyle = "#ccc";
                            legendCtx.fill();
                            if (rule.PointSymbolizer.Graphic.Mark && rule.PointSymbolizer.Graphic.Mark.Stroke && rule.PointSymbolizer.Graphic.Mark.Stroke['stroke-width'])
                                legendCtx.lineWidth = rule.PointSymbolizer.Graphic.Mark.Stroke['stroke-width'].trim();
                            else
                                legendCtx.lineWidth = 0.5;
                            legendCtx.strokeStyle = '#003300';
                            legendCtx.stroke();
                        }
                        if (rule.PolygonSymbolizer) {
                            legendCtx.beginPath();
                            legendCtx.rect(0, 0, 20, 15);
                            if (rule.PolygonSymbolizer.Fill && rule.PolygonSymbolizer.Fill.fill)
                                legendCtx.fillStyle = rule.PolygonSymbolizer.Fill.fill.trim();
                            else
                                legendCtx.fillStyle = '#ccc';
                            legendCtx.fill();
                            if (rule.PolygonSymbolizer.Stroke && rule.PolygonSymbolizer.Stroke['stroke-width'])
                                legendCtx.lineWidth = rule.PolygonSymbolizer.Stroke['stroke-width'].trim();
                            else
                                legendCtx.lineWidth = 0.5;
                            if (rule.PolygonSymbolizer.Stroke && rule.PolygonSymbolizer.Stroke.stroke)
                                legendCtx.strokeStyle = rule.PolygonSymbolizer.Stroke.stroke.trim();
                            else
                                legendCtx.strokeStyle = 'black';
                            legendCtx.stroke();
                        }
                    }
                    else if (varFeatureTypeStyle.Rule.Filter.PropertyIsBetween) {

                        if (varFeatureTypeStyle.Rule.Filter.PropertyIsBetween.LowerBoundary && varFeatureTypeStyle.Rule.Filter.PropertyIsBetween.LowerBoundary.Literal && literal_name === true)
                            rule_name = Math.round(varFeatureTypeStyle.Rule.Filter.PropertyIsBetween.LowerBoundary.Literal);

                        if (varFeatureTypeStyle.Rule.Filter.PropertyIsBetween.UpperBoundary && varFeatureTypeStyle.Rule.Filter.PropertyIsBetween.UpperBoundary.Literal && literal_name === true)
                            rule_name = rule_name + " - " + Math.round(varFeatureTypeStyle.Rule.Filter.PropertyIsBetween.UpperBoundary.Literal);
                        legendCtx.beginPath();
                        legendCtx.rect(0, 0, 20, 15);
                        if (rule.PolygonSymbolizer.Fill && rule.PolygonSymbolizer.Fill.fill)
                            legendCtx.fillStyle = rule.PolygonSymbolizer.Fill.fill.trim();
                        else
                            legendCtx.fillStyle = '#ccc';
                        legendCtx.fill();
                        if (rule.PolygonSymbolizer.Stroke && rule.PolygonSymbolizer.Stroke['stroke-width'])
                            legendCtx.lineWidth = rule.PolygonSymbolizer.Stroke['stroke-width'].trim();
                        else
                            legendCtx.lineWidth = 0.5;
                        if (rule.PolygonSymbolizer.Stroke && rule.PolygonSymbolizer.Stroke.stroke)
                            legendCtx.strokeStyle = rule.PolygonSymbolizer.Stroke.stroke.trim();
                        else
                            legendCtx.strokeStyle = 'black';
                        legendCtx.stroke();
                    }

                }
                else
                {
                    if (rule.PointSymbolizer) {

                        if (rule.PointSymbolizer && rule.PointSymbolizer.Graphic && rule.PointSymbolizer.Graphic.Mark && rule.PointSymbolizer.Graphic.Mark.WellKnownName) {

                            switch (rule.PointSymbolizer.Graphic.Mark.WellKnownName) {
                                case 'square':
                                    legendCtx.beginPath();
                                    legendCtx.rect((legendCanvas.width - rule.PointSymbolizer.Graphic.Size) / 2, (legendCanvas.height - rule.PointSymbolizer.Graphic.Size) / 2, rule.PointSymbolizer.Graphic.Size, rule.PointSymbolizer.Graphic.Size);
                                    break;
                                case 'star':
                                    legendCtx.moveTo(centerX, centerY - rule.PointSymbolizer.Graphic.Size / 1.6);
                                    legendCtx.lineTo(centerX + rule.PointSymbolizer.Graphic.Size / 2.0, centerY);
                                    legendCtx.lineTo(centerX, centerY + rule.PointSymbolizer.Graphic.Size / 1.6);
                                    legendCtx.lineTo(centerX - rule.PointSymbolizer.Graphic.Size / 2.0, centerY);
                                    legendCtx.closePath();
                                    break;
                                case 'circle':
                                    var radius = rule.PointSymbolizer.Graphic.Size / 2.0;
                                    legendCtx.beginPath();
                                    legendCtx.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
                                    break;
                                case 'triangle':
                                    legendCtx.beginPath();
                                    legendCtx.moveTo(centerX, centerY - rule.PointSymbolizer.Graphic.Size / 2.0);
                                    legendCtx.lineTo(centerX + rule.PointSymbolizer.Graphic.Size / 2.0, centerY + rule.PointSymbolizer.Graphic.Size / 2.0);
                                    legendCtx.lineTo(centerX - rule.PointSymbolizer.Graphic.Size / 2.0, centerY + rule.PointSymbolizer.Graphic.Size / 2.0);
                                    legendCtx.closePath();
                                    break;
                                default:
                                    var centerX = legendCanvas.width / 2;
                                    var centerY = legendCanvas.height / 2;
                                    var radius = rule.PointSymbolizer.Graphic.Size / 2.0;
                                    legendCtx.beginPath();
                                    legendCtx.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
                                    break;
                            }
                            if (rule.PointSymbolizer.Graphic.Mark.Fill && rule.PointSymbolizer.Graphic.Mark.Fill.fill)
                                legendCtx.fillStyle = rule.PointSymbolizer.Graphic.Mark.Fill.fill.trim();
                            else
                                legendCtx.fillStyle = "#ccc";
                            legendCtx.fill();
                            if (rule.PointSymbolizer.Graphic.Mark && rule.PointSymbolizer.Graphic.Mark.Stroke && rule.PointSymbolizer.Graphic.Mark.Stroke['stroke-width'])
                                legendCtx.lineWidth = rule.PointSymbolizer.Graphic.Mark.Stroke['stroke-width'].trim();
                            else
                                legendCtx.lineWidth = 0.5;
                            legendCtx.strokeStyle = '#003300';
                            legendCtx.stroke();
                        }

                    }
                    if (rule.LineSymbolizer) {
                        legendCtx.beginPath();
                        legendCtx.moveTo(centerX - legendCanvas.width / 3, centerY);
                        legendCtx.lineTo(centerX + legendCanvas.width / 3, centerY);
                        if (rule.LineSymbolizer.Fill && rule.LineSymbolizer.Fill.fill)
                            legendCtx.fillStyle = rule.LineSymbolizer.Fill.fill.trim();
                        else
                            legendCtx.fillStyle = '#ccc';
                        legendCtx.fill();
                        if (rule.LineSymbolizer.Stroke && rule.LineSymbolizer.Stroke['stroke-width'])
                            legendCtx.lineWidth = rule.LineSymbolizer.Stroke['stroke-width'].trim();
                        else
                            legendCtx.lineWidth = 0.5;
                        if (rule.LineSymbolizer.Stroke && rule.LineSymbolizer.Stroke.stroke)
                            legendCtx.strokeStyle = rule.LineSymbolizer.Stroke.stroke.trim();
                        else
                            legendCtx.strokeStyle = 'black';
                        legendCtx.stroke();
                    }
                    if (rule.PolygonSymbolizer) {
                        legendCtx.beginPath();
                        if (rule.PolygonSymbolizer.Stroke && rule.PolygonSymbolizer.Stroke['stroke-width'])
                        {
                            legendCtx.lineWidth = rule.PolygonSymbolizer.Stroke['stroke-width'].trim();
//                            legendCtx.lineWidth = legendCtx.lineWidth + 0.1;
//                            alert("legendCtx.lineWidth="+legendCtx.lineWidth);
                        }
                        else
                            legendCtx.lineWidth = 0.5;
                        legendCtx.rect(legendCtx.lineWidth / 2.0, legendCtx.lineWidth / 2.0, 20 - legendCtx.lineWidth, 15 - legendCtx.lineWidth);
                        if (rule.PolygonSymbolizer.Fill && rule.PolygonSymbolizer.Fill.fill)
                            legendCtx.fillStyle = rule.PolygonSymbolizer.Fill.fill.trim();
                        else
                            legendCtx.fillStyle = '#ccc';
                        legendCtx.fill();



                        if (rule.PolygonSymbolizer.Stroke && rule.PolygonSymbolizer.Stroke.stroke)
                            legendCtx.strokeStyle = rule.PolygonSymbolizer.Stroke.stroke.trim();
                        else
                            legendCtx.strokeStyle = 'black';


                        legendCtx.stroke();
                    }

                }
                var li = $("<li><img src='" + legendCanvas.toDataURL() + "'/>" + rule_name + "</li>");
                li.appendTo(ul);
            }
        }
        return legend;
    };
    control.refreshOverlays = function () {
        var _this = this;
        var overlay_layers_ul = $(".leaflet-control-container .section.overlay-layers > ul.overlay_ul");
        overlay_layers_ul.html('');
        $("select#activelayer_id.layers-ui").empty();
        _this._map.dataLayers.forEach(function (layer, i) {
            _this.addOverlayItem(layer, i, null, false);
        });
        _this.overlayToolButtons();
        $("select#activelayer_id.layers-ui").trigger('change');
    };

    return control;
};

L.MAP2U.legend = function (options) {
  var control = L.control(options);

  control.onAdd = function (map) {
    var $container = $('<div>')
      .attr('class', 'leaflet-control');

    var button = $('<a>')
      .attr('class', 'control-button')
      .attr('href', '#')
      .html('<span class="icon key"></span>')
      .on('click', toggle)
      .appendTo($container);

    var $ui = $('<div>')
      .attr('class', 'key-ui');

    $('<div>')
      .attr('class', 'sidebar_heading')
      .appendTo($ui)
      .append(
        $('<h4>')
          .text(I18n.t('javascripts.key.title')));
    var barContent = $('<div>')
         .attr('class', 'sidebar_content')
         .appendTo($ui)
 
    var $section = $('<div>')
      .attr('class', 'section')
      .appendTo(barContent);

    list = $('<ul>')
      .appendTo($section);
      
    map.dataLayers.forEach(function(layer) {
//        var item = $('<li>')
//        .appendTo(list);
//

            if (layer.layer !== null && layer.layer !== undefined && layer.layer.options !== undefined)
            {
          //      list.append('<li>' + layer.name);
          //      list.append('<div>');
          //      list.append("<img src='http://cobas.juturna.ca:8080/geoserver/wms?TRANSPARENT=true&SERVICE=WMS&VERSION=1.1.1&REQUEST=GetLegendGraphic&EXCEPTIONS=application%2Fvnd.ogc.se_xml&FORMAT=image%2Fpng&LAYER=" + layer.layer.options.layers + "'>");
          //      list.append('</div>');
          //      list.append('</li>');
            }


//        item.append(layer.name);
//        item.append("<a>"+layer.layer.options.layers+"</a>");
       
    });
    options.sidebar.addPane($ui);
    jQuery(window).resize(function() { 
        barContent.height($('.leaflet-sidebar.right').height()-70);
    });
//    $ui
//      .on('show', shown)
//      .on('hide', hidden);

//    map.on('overlayschange', updateButton);
//
//    updateButton();
//
//    function shown() {
//      map.on('zoomend baselayerchange', update);
//      $section.load('/key', update);
//    }
//
//    function hidden() {
//      map.off('zoomend baselayerchange', update);
//    }
    
    function toggle(e) {
      e.stopPropagation();
      e.preventDefault();
      if (!button.hasClass('disabled')) {
        options.sidebar.togglePane($ui, button);
      }
      $('.leaflet-control .control-button').tooltip('hide');
    }

    function updateButton() {
      var disabled = false;//map.getMapBaseLayerId() !== 'mapnik'
      button
        .toggleClass('disabled', disabled)
        .attr('data-original-title', I18n.t(disabled ?
          'javascripts.key.tooltip_disabled' :
          'javascripts.key.tooltip'))
    }

    function update() {
      var layer = map.getMapBaseLayerId(),
        zoom = map.getZoom();

//      $('.mapkey-table-entry').each(function () {
//        var data = $(this).data();
//        if (layer == data.layer && zoom >= data.zoomMin && zoom <= data.zoomMax) {
//          $(this).show();
//        } else {
//          $(this).hide();
//        }
//      });
    }

    return $container[0];
  };

  return control;
};

/*
Copyright (c) 2013 Dominik Moritz

This file is part of the leaflet locate control. It is licensed under the MIT license.
You can find the project at: https://github.com/domoritz/leaflet-locatecontrol
*/
L.Control.Locate = L.Control.extend({
    options: {
        position: 'topleft',
        drawCircle: true,
        follow: false,  // follow with zoom and pan the user's location
        stopFollowingOnDrag: false, // if follow is true, stop following when map is dragged (deprecated)
        // range circle
        circleStyle: {
            color: '#136AEC',
            fillColor: '#136AEC',
            fillOpacity: 0.15,
            weight: 2,
            opacity: 0.5
        },
        // inner marker
        markerStyle: {
            color: '#136AEC',
            fillColor: '#2A93EE',
            fillOpacity: 0.7,
            weight: 2,
            opacity: 0.9,
            radius: 5
        },
        // changes to range circle and inner marker while following
        // it is only necessary to provide the things that should change
        followCircleStyle: {},
        followMarkerStyle: {
            //color: '#FFA500',
            //fillColor: '#FFB000'
        },
        circlePadding: [0, 0],
        metric: true,
        onLocationError: function(err) {
            // this event is called in case of any location error
            // that is not a time out error.
            alert(err.message);
        },
        onLocationOutsideMapBounds: function(context) {
            // this event is repeatedly called when the location changes
            alert(context.options.strings.outsideMapBoundsMsg);
        },
        setView: true, // automatically sets the map view to the user's location
        strings: {
            title: "Show me where I am",
            popup: "You are within {distance} {unit} from this point",
            outsideMapBoundsMsg: "You seem located outside the boundaries of the map"
        },
        locateOptions: {}
    },

    onAdd: function (map) {
        var container = L.DomUtil.create('div', 'control-locate');

        var self = this;
        this._layer = new L.LayerGroup();
        this._layer.addTo(map);
        this._event = undefined;

        this._locateOptions = {
            watch: true  // if you overwrite this, visualization cannot be updated
        };
        L.extend(this._locateOptions, this.options.locateOptions);
        L.extend(this._locateOptions, {
            setView: false // have to set this to false because we have to
                           // do setView manually
        });

        // extend the follow marker style and circle from the normal style
        var tmp = {};
        L.extend(tmp, this.options.markerStyle, this.options.followMarkerStyle);
        this.options.followMarkerStyle = tmp;
        tmp = {};
        L.extend(tmp, this.options.circleStyle, this.options.followCircleStyle);
        this.options.followCircleStyle = tmp;

        var link = L.DomUtil.create('a', 'control-button', container);
        link.innerHTML = "<span class='icon geolocate'></span>";
        link.href = '#';
        link.title = this.options.strings.title;

        L.DomEvent
            .on(link, 'click', L.DomEvent.stopPropagation)
            .on(link, 'click', L.DomEvent.preventDefault)
            .on(link, 'click', function() {
                if (self._active && self._event && (map.getBounds().contains(self._event.latlng) || !self.options.setView ||
                    isOutsideMapBounds())) {
                    stopLocate();
                } else {
                    locate();
                }
            })
            .on(link, 'dblclick', L.DomEvent.stopPropagation);

        var locate = function () {
            if (self.options.setView) {
                self._locateOnNextLocationFound = true;
            }
            if(!self._active) {
                map.locate(self._locateOptions);
            }
            self._active = true;
            if (self.options.follow) {
                startFollowing();
            }
            if (!self._event) {
                L.DomUtil.addClass(self._container, "requesting");
                L.DomUtil.removeClass(self._container, "active");
                L.DomUtil.removeClass(self._container, "following");
            } else {
                visualizeLocation();
            }
        };

        var onLocationFound = function (e) {
            // no need to do anything if the location has not changed
            if (self._event &&
                (self._event.latlng.lat === e.latlng.lat &&
                 self._event.latlng.lng === e.latlng.lng &&
                 self._event.accuracy === e.accuracy)) {
                return;
            }

            if (!self._active) {
                return;
            }

            self._event = e;

            if (self.options.follow && self._following) {
                self._locateOnNextLocationFound = true;
            }

            visualizeLocation();
        };

        var startFollowing = function() {
            map.fire('startfollowing');
            self._following = true;
            if (self.options.stopFollowingOnDrag) {
                map.on('dragstart', stopFollowing);
            }
        };

        var stopFollowing = function() {
            map.fire('stopfollowing');
            self._following = false;
            if (self.options.stopFollowingOnDrag) {
                map.off('dragstart', stopFollowing);
            }
            visualizeLocation();
        };

        var isOutsideMapBounds = function () {
            if (self._event === undefined)
                return false;
            return map.options.maxBounds &&
                !map.options.maxBounds.contains(self._event.latlng);
        };

        var visualizeLocation = function() {
            if (self._event.accuracy === undefined)
                self._event.accuracy = 0;

            var radius = self._event.accuracy;
            if (self._locateOnNextLocationFound) {
                if (isOutsideMapBounds()) {
                    self.options.onLocationOutsideMapBounds(self);
                } else {
                    map.fitBounds(self._event.bounds, { padding: self.options.circlePadding });
                }
                self._locateOnNextLocationFound = false;
            }

            // circle with the radius of the location's accuracy
            var style, o;
            if (self.options.drawCircle) {
                if (self._following) {
                    style = self.options.followCircleStyle;
                } else {
                    style = self.options.circleStyle;
                }

                if (!self._circle) {
                    self._circle = L.circle(self._event.latlng, radius, style)
                        .addTo(self._layer);
                } else {
                    self._circle.setLatLng(self._event.latlng).setRadius(radius);
                    for (o in style) {
                        self._circle.options[o] = style[o];
                    }
                }
            }

            var distance, unit;
            if (self.options.metric) {
                distance = radius.toFixed(0);
                unit = "meters";
            } else {
                distance = (radius * 3.2808399).toFixed(0);
                unit = "feet";
            }

            // small inner marker
            var mStyle;
            if (self._following) {
                mStyle = self.options.followMarkerStyle;
            } else {
                mStyle = self.options.markerStyle;
            }

            var t = self.options.strings.popup;
            if (!self._circleMarker) {
                self._circleMarker = L.circleMarker(self._event.latlng, mStyle)
                    .bindPopup(L.Util.template(t, {distance: distance, unit: unit}))
                    .addTo(self._layer);
            } else {
                self._circleMarker.setLatLng(self._event.latlng)
                    .bindPopup(L.Util.template(t, {distance: distance, unit: unit}))
                    ._popup.setLatLng(self._event.latlng);
                for (o in mStyle) {
                    self._circleMarker.options[o] = mStyle[o];
                }
            }

            if (!self._container)
                return;
            if (self._following) {
                L.DomUtil.removeClass(self._container, "requesting");
                L.DomUtil.addClass(self._container, "active");
                L.DomUtil.addClass(self._container, "following");
            } else {
                L.DomUtil.removeClass(self._container, "requesting");
                L.DomUtil.addClass(self._container, "active");
                L.DomUtil.removeClass(self._container, "following");
            }
        };

        var resetVariables = function() {
            self._active = false;
            self._locateOnNextLocationFound = self.options.setView;
            self._following = false;
        };

        resetVariables();

        var stopLocate = function() {
            map.stopLocate();
            map.off('dragstart', stopFollowing);

            L.DomUtil.removeClass(self._container, "requesting");
            L.DomUtil.removeClass(self._container, "active");
            L.DomUtil.removeClass(self._container, "following");
            resetVariables();

            self._layer.clearLayers();
            self._circleMarker = undefined;
            self._circle = undefined;
        };

        var onLocationError = function (err) {
            // ignore time out error if the location is watched
            if (err.code == 3 && this._locateOptions.watch) {
                return;
            }

            stopLocate();
            self.options.onLocationError(err);
        };

        // event hooks
        map.on('locationfound', onLocationFound, self);
        map.on('locationerror', onLocationError, self);

        // make locate functions available to outside world
        this.locate = locate;
        this.stopLocate = stopLocate;
        this.stopFollowing = stopFollowing;

        return container;
    }
});

L.Map.addInitHook(function () {
    if (this.options.locateControl) {
        this.locateControl = L.control.locate();
        this.addControl(this.locateControl);
    }
});

L.control.locate = function (options) {
    return new L.Control.Locate(options);
};

/*
 * Leaflet.locationfilter - leaflet location filter plugin
 * Copyright (C) 2012, Tripbirds.com
 * http://tripbirds.com
 *
 * Licensed under the MIT License.
 *
 * Date: 2012-09-24
 * Version: 0.1
 */
L.LatLngBounds.prototype.modify = function(map, amount) {
    var sw = this.getSouthWest(),
        ne = this.getNorthEast(),
        swPoint = map.latLngToLayerPoint(sw),
        nePoint = map.latLngToLayerPoint(ne);

    sw = map.layerPointToLatLng(new L.Point(swPoint.x-amount, swPoint.y+amount));
    ne = map.layerPointToLatLng(new L.Point(nePoint.x+amount, nePoint.y-amount));
    
    return new L.LatLngBounds(sw, ne);
};

L.Control.Button = L.Class.extend({
    initialize: function(options) {
        L.Util.setOptions(this, options);
    },

    addTo: function(container) {
        container.addButton(this);
        return this;
    },
    
    onAdd: function (buttonContainer) {
        this._buttonContainer = buttonContainer;
        this._button = L.DomUtil.create('a', this.options.className, this._buttonContainer.getContainer());
        this._button.href = '#';
        this.setText(this.options.text);

        var that = this;
        this._onClick = function(event) {
            that.options.onClick.call(that, event);
        };

        L.DomEvent
            .on(this._button, 'click', L.DomEvent.stopPropagation)
            .on(this._button, 'mousedown', L.DomEvent.stopPropagation)
            .on(this._button, 'dblclick', L.DomEvent.stopPropagation)
            .on(this._button, 'click', L.DomEvent.preventDefault)
            .on(this._button, 'click', this._onClick, this);
    },

    remove: function() {
        L.DomEvent.off(this._button, "click", this._onClick);
        this._buttonContainer.getContainer().removeChild(this._button);
    },

    setText: function(text) {
        this._button.title = text;
        this._button.innerHTML = text;
    }
});

L.Control.ButtonContainer = L.Control.extend({
    options: {
        position: 'topleft'
    },

    getContainer: function() {
        if (!this._container) {
            this._container = L.DomUtil.create('div', this.options.className);
        }
        return this._container;
    },

    onAdd: function (map) {
        this._map = map;
        return this.getContainer();
    },

    addButton: function(button) {
        button.onAdd(this);
    },

    addClass: function(className) {
        L.DomUtil.addClass(this.getContainer(), className);
    },

    removeClass: function(className) {
        L.DomUtil.removeClass(this.getContainer(), className);
    }
});

L.LocationFilter = L.Class.extend({
    includes: L.Mixin.Events,

    options: {
        enableButton: {
            enableText: "Select area",
            disableText: "Remove selection"
        },
        adjustButton: {
            text: "Select area within current zoom"
        }
    },

    initialize: function(options) {
        L.Util.setOptions(this, options);
    },

    addTo: function(map) {
        map.addLayer(this);
        return this;
    },

    onAdd: function(map) {
        this._map = map;

        if (this.options.enableButton || this.options.adjustButton) {
            this._initializeButtonContainer();
        }

        if (this.options.enable) {
            this.enable();
        }
    },

    onRemove: function(map) {
        this.disable();
        if (this._buttonContainer) {
            this._buttonContainer.removeFrom(map);
        }
    },

    /* Get the current filter bounds */
    getBounds: function() { 
        return new L.LatLngBounds(this._sw, this._ne); 
    },

    setBounds: function(bounds) {
        this._nw = bounds.getNorthWest();
        this._ne = bounds.getNorthEast();
        this._sw = bounds.getSouthWest();
        this._se = bounds.getSouthEast();
        if (this.isEnabled()) {
            this._draw();
            this.fire("change", {bounds: bounds});
        }
    },

    isEnabled: function() {
        return this._enabled;
    },

    /* Draw a rectangle */
    _drawRectangle: function(bounds, options) {
        options = options || {};
        var defaultOptions = {
            stroke: false,
            fill: true,
            fillColor: "black",
            fillOpacity: 0.3,
            clickable: false
        };
        options = L.Util.extend(defaultOptions, options);
        var rect = new L.Rectangle(bounds, options);
        rect.addTo(this._layer);
        return rect;
    },

    /* Draw a draggable marker */
    _drawImageMarker: function(point, options) {
        var marker = new L.Marker(point, {
            icon: new L.DivIcon({
                iconAnchor: options.anchor,
                iconSize: options.size,
                className: options.className
            }),
            draggable: true
        });
        marker.addTo(this._layer);
        return marker;
    },

    /* Draw a move marker. Sets up drag listener that updates the
       filter corners and redraws the filter when the move marker is
       moved */
    _drawMoveMarker: function(point) {
        var that = this;
        this._moveMarker = this._drawImageMarker(point, {
            "className": "location-filter move-marker",
            "anchor": [-10, -10],
            "size": [13,13]
        });
        this._moveMarker.on('drag', function(e) {
            var markerPos = that._moveMarker.getLatLng(),
                latDelta = markerPos.lat-that._nw.lat,
                lngDelta = markerPos.lng-that._nw.lng;
            that._nw = new L.LatLng(that._nw.lat+latDelta, that._nw.lng+lngDelta, true);
            that._ne = new L.LatLng(that._ne.lat+latDelta, that._ne.lng+lngDelta, true);
            that._sw = new L.LatLng(that._sw.lat+latDelta, that._sw.lng+lngDelta, true);
            that._se = new L.LatLng(that._se.lat+latDelta, that._se.lng+lngDelta, true);
            that._draw();
        });
        this._setupDragendListener(this._moveMarker);
        return this._moveMarker;
    },

    /* Draw a resize marker */
    _drawResizeMarker: function(point, latFollower, lngFollower, otherPos) {
        return this._drawImageMarker(point, {
            "className": "location-filter resize-marker",
            "anchor": [7, 6],
            "size": [13, 12] 
        });
    },

    /* Track moving of the given resize marker and update the markers
       given in options.moveAlong to match the position of the moved
       marker. Update filter corners and redraw the filter */
    _setupResizeMarkerTracking: function(marker, options) {
        var that = this;
        marker.on('drag', function(e) {
            var curPosition = marker.getLatLng(),
                latMarker = options.moveAlong.lat,
                lngMarker = options.moveAlong.lng;
            // Move follower markers when this marker is moved
            latMarker.setLatLng(new L.LatLng(curPosition.lat, latMarker.getLatLng().lng, true));
            lngMarker.setLatLng(new L.LatLng(lngMarker.getLatLng().lat, curPosition.lng, true));
            // Sort marker positions in nw, ne, sw, se order
            var corners = [that._nwMarker.getLatLng(), 
                           that._neMarker.getLatLng(), 
                           that._swMarker.getLatLng(), 
                           that._seMarker.getLatLng()];
            corners.sort(function(a, b) {
                if (a.lat != b.lat)
                    return b.lat-a.lat;
                else
                    return a.lng-b.lng;
            });
            // Update corner points and redraw everything except the resize markers
            that._nw = corners[0];
            that._ne = corners[1];
            that._sw = corners[2];
            that._se = corners[3];
            that._draw({repositionResizeMarkers: false});
        });
        this._setupDragendListener(marker);
    },

    /* Emit a change event whenever dragend is triggered on the
       given marker */
    _setupDragendListener: function(marker) {
        var that = this;
        marker.on('dragend', function(e) {
            that.fire("change", {bounds: that.getBounds()});
        });
    },

    /* Create bounds for the mask rectangles and the location
       filter rectangle */
    _calculateBounds: function() {
        var mapBounds = this._map.getBounds(),
            outerBounds = new L.LatLngBounds(
                new L.LatLng(mapBounds.getSouthWest().lat-0.1,
                             mapBounds.getSouthWest().lng-0.1, true),
                new L.LatLng(mapBounds.getNorthEast().lat+0.1,
                             mapBounds.getNorthEast().lng+0.1, true)
            );

        // The south west and north east points of the mask */
        this._osw = outerBounds.getSouthWest();
        this._one = outerBounds.getNorthEast();

        // Bounds for the mask rectangles
        this._northBounds = new L.LatLngBounds(new L.LatLng(this._ne.lat, this._osw.lng, true), this._one);
        this._westBounds = new L.LatLngBounds(new L.LatLng(this._sw.lat, this._osw.lng, true), this._nw);
        this._eastBounds = new L.LatLngBounds(this._se, new L.LatLng(this._ne.lat, this._one.lng, true));
        this._southBounds = new L.LatLngBounds(this._osw, new L.LatLng(this._sw.lat, this._one.lng, true));
    },

    /* Initializes rectangles and markers */
    _initialDraw: function() {
        if (this._initialDrawCalled) {
            return;
        }

        this._layer = new L.LayerGroup();

        // Calculate filter bounds
        this._calculateBounds();

        // Create rectangles
        this._northRect = this._drawRectangle(this._northBounds);
        this._westRect = this._drawRectangle(this._westBounds);
        this._eastRect = this._drawRectangle(this._eastBounds);
        this._southRect = this._drawRectangle(this._southBounds);
        this._innerRect = this._drawRectangle(this.getBounds(), {
            fillOpacity: 0,
            stroke: true,
            color: "white",
            weight: 1,
            opacity: 0.9
        });

        // Create resize markers
        this._nwMarker = this._drawResizeMarker(this._nw);
        this._neMarker = this._drawResizeMarker(this._ne);
        this._swMarker = this._drawResizeMarker(this._sw);
        this._seMarker = this._drawResizeMarker(this._se);

        // Setup tracking of resize markers. Each marker has pair of
        // follower markers that must be moved whenever the marker is
        // moved. For example, whenever the north west resize marker
        // moves, the south west marker must move along on the x-axis
        // and the north east marker must move on the y axis
        this._setupResizeMarkerTracking(this._nwMarker, {moveAlong: {lat: this._neMarker, lng: this._swMarker}});
        this._setupResizeMarkerTracking(this._neMarker, {moveAlong: {lat: this._nwMarker, lng: this._seMarker}});
        this._setupResizeMarkerTracking(this._swMarker, {moveAlong: {lat: this._seMarker, lng: this._nwMarker}});
        this._setupResizeMarkerTracking(this._seMarker, {moveAlong: {lat: this._swMarker, lng: this._neMarker}});

        // Create move marker
        this._moveMarker = this._drawMoveMarker(this._nw);

        this._initialDrawCalled = true;
    },

    /* Reposition all rectangles and markers to the current filter bounds. */    
    _draw: function(options) {
        options = L.Util.extend({repositionResizeMarkers: true}, options);

        // Calculate filter bounds
        this._calculateBounds();

        // Reposition rectangles
        this._northRect.setBounds(this._northBounds);
        this._westRect.setBounds(this._westBounds);
        this._eastRect.setBounds(this._eastBounds);
        this._southRect.setBounds(this._southBounds);
        this._innerRect.setBounds(this.getBounds());

        // Reposition resize markers
        if (options.repositionResizeMarkers) {
            this._nwMarker.setLatLng(this._nw);
            this._neMarker.setLatLng(this._ne);
            this._swMarker.setLatLng(this._sw);
            this._seMarker.setLatLng(this._se);
        }

        // Reposition the move marker
        this._moveMarker.setLatLng(this._nw);
    }, 

    /* Adjust the location filter to the current map bounds */
    _adjustToMap: function() {
        this.setBounds(this._map.getBounds());
        this._map.zoomOut();
    },

    /* Enable the location filter */
    enable: function() {
        if (this._enabled) {
            return;
        }

        // Initialize corners
        var bounds;
        if (this._sw && this._ne) {
            bounds = new L.LatLngBounds(this._sw, this._ne);
        } else if (this.options.bounds) {
            bounds = this.options.bounds;
        } else {
            bounds = this._map.getBounds();
        }
        this._map.invalidateSize();
        this._nw = bounds.getNorthWest();
        this._ne = bounds.getNorthEast();
        this._sw = bounds.getSouthWest();
        this._se = bounds.getSouthEast();
            

        // Update buttons
        if (this._buttonContainer) {
            this._buttonContainer.addClass("enabled");
        }

        if (this._enableButton) {
            this._enableButton.setText(this.options.enableButton.disableText);
        }

        if (this.options.adjustButton) {
            this._createAdjustButton();
        }
        
        // Draw filter
        this._initialDraw();
        this._draw();

        // Set up map move event listener
        var that = this;
        this._moveHandler = function() {
            that._draw();
        };
        this._map.on("move", this._moveHandler);

        // Add the filter layer to the map
        this._layer.addTo(this._map);
        
        // Zoom out the map if necessary
        var mapBounds = this._map.getBounds();
        bounds = new L.LatLngBounds(this._sw, this._ne).modify(this._map, 10);
        if (!mapBounds.contains(bounds.getSouthWest()) || !mapBounds.contains(bounds.getNorthEast())) {
            this._map.fitBounds(bounds);
        }

        this._enabled = true;
        
        // Fire the enabled event
        this.fire("enabled");
    },

    /* Disable the location filter */
    disable: function() {
        if (!this._enabled) {
            return;
        }

        // Update buttons
        if (this._buttonContainer) {
            this._buttonContainer.removeClass("enabled");
        }

        if (this._enableButton) {
            this._enableButton.setText(this.options.enableButton.enableText);
        }

        if (this._adjustButton) {
            this._adjustButton.remove();
        }

        // Remove event listener
        this._map.off("move", this._moveHandler);

        // Remove rectangle layer from map
        this._map.removeLayer(this._layer);

        this._enabled = false;

        // Fire the disabled event
        this.fire("disabled");
    },

    /* Create a button that allows the user to adjust the location
       filter to the current zoom */
    _createAdjustButton: function() {
        var that = this;
        this._adjustButton = new L.Control.Button({
            className: "adjust-button",
            text: this.options.adjustButton.text,
            
            onClick: function(event) {
                that._adjustToMap();
                that.fire("adjustToZoomClick");
            }
        }).addTo(this._buttonContainer);
    },

    /* Create the location filter button container and the button that
       toggles the location filter */
    _initializeButtonContainer: function() {
        var that = this;
        this._buttonContainer = new L.Control.ButtonContainer({className: "location-filter button-container"});

        if (this.options.enableButton) {
            this._enableButton = new L.Control.Button({
                className: "enable-button",
                text: this.options.enableButton.enableText,

                onClick: function(event) {
                    if (!that._enabled) {
                        // Enable the location filter
                        that.enable();
                        that.fire("enableClick");
                    } else {
                        // Disable the location filter
                        that.disable();
                        that.fire("disableClick");
                    }
                }
            }).addTo(this._buttonContainer);
        }

        this._buttonContainer.addTo(this._map);
    }
});

L.MAP2U = {};

L.MAP2U.Map = L.Map.extend({
    initialize: function(id, options) {
        L.Map.prototype.initialize.call(this, id, options);

        var copyright = I18n.t('javascripts.map.copyright', {copyright_url: '/copyright'});
        var donate = I18n.t('javascripts.map.donate_link_text', {donate_url: 'http://donate.openstreetmap.org'});

//        this.baseLayers = [
//            new L.Google('ROADMAP',{'name':'Google Road Map'}),
//            new L.Google('SATELLITE',{'name':'Google Satellite'}),
//            new L.Google('HYBRID',{'name':'Google Hybrid'}),
//            new L.Google('TERRAIN',{'name':'Google Terrain'})
//
//        ];
//
//        this.noteLayer = new L.FeatureGroup();
//        this.noteLayer.options = {code: 'N'};
//        
//        this.dataLayers = [{'layer':new L.TileLayer.WMS(
//                            "http://cobas.juturna.ca:8080/geoserver/juturna/wms",
//                    {
//                    layers: 'juturna:cvcsubwatersheds',
//                    format: 'image/png',
//                    transparent: true,
//                    srs: 'EPSG:4326',
//                    name: 'Subwatersheds',
//                    attribution: ""
//                   }),'name':'Subwatersheds'},{'layer': new L.TileLayer.WMS(
//                            "http://cobas.juturna.ca:8080/geoserver/juturna/wms",
//                    {
//                    layers: 'juturna:cvcwatersheds',
//                       format: 'image/png',
//                        srs: 'EPSG:4326',
//                       transparent: true,
//                        name: 'Watersheds',
//                       attribution: ""
//                   }),'name':'Watersheds'}];
      //  this.dataLayers = new L.MAP2U.DataLayer(null);
     //   this.dataLayer.options.code = 'D';
    },
    updateLayers: function(layerParam) {
        layerParam = layerParam || "M";
        var layersAdded = "";

        for (var i = this.baseLayers.length - 1; i >= 0; i--) {
            if (layerParam.indexOf(this.baseLayers[i].options.code) >= 0) {
                this.addLayer(this.baseLayers[i]);
                layersAdded = layersAdded + this.baseLayers[i].options.code;
            } else if (i == 0 && layersAdded == "") {
                this.addLayer(this.baseLayers[i]);
            } else {
                this.removeLayer(this.baseLayers[i]);
            }
        }
    },
    getLayersCode: function() {
        var layerConfig = '';
        for (var i in this._layers) { // TODO: map.eachLayer
            var layer = this._layers[i];
            if (layer.options && layer.options.code) {
                layerConfig += layer.options.code;
            }
        }
        return layerConfig;
    },
    getMapBaseLayerId: function() {
        for (var i in this._layers) { // TODO: map.eachLayer
            var layer = this._layers[i];
            if (layer.options && layer.options.keyid)
                return layer.options.keyid;
        }
    },
//    getUrl: function(marker) {
//
//    },
//    getShortUrl: function(marker) {
//
//    },

    getUrl: function(marker) {
      var precision = OSM.zoomPrecision(this.getZoom()),
          params = {};

      if (marker && this.hasLayer(marker)) {
        var latLng = marker.getLatLng().wrap();
        params.mlat = latLng.lat.toFixed(precision);
        params.mlon = latLng.lng.toFixed(precision);
      }

      var url = 'http://' + OSM.SERVER_URL + '/',
        query = querystring.stringify(params),
        hash = OSM.formatHash(this);

      if (query) url += '?' + query;
      if (hash) url += hash;

      return url;
    },

  getShortUrl: function(marker) {
    var zoom = this.getZoom(),
      latLng = marker && this.hasLayer(marker) ? marker.getLatLng().wrap() : this.getCenter().wrap(),
      str = window.location.hostname.match(/^www\.openstreetmap\.org/i) ?
        'http://osm.org/go/' : 'http://' + window.location.hostname + '/go/',
      char_array = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_~",
      x = Math.round((latLng.lng + 180.0) * ((1 << 30) / 90.0)),
      y = Math.round((latLng.lat + 90.0) * ((1 << 30) / 45.0)),
      // JavaScript only has to keep 32 bits of bitwise operators, so this has to be
      // done in two parts. each of the parts c1/c2 has 30 bits of the total in it
      // and drops the last 4 bits of the full 64 bit Morton code.
      c1 = interlace(x >>> 17, y >>> 17), c2 = interlace((x >>> 2) & 0x7fff, (y >>> 2) & 0x7fff),
      digit;

    for (var i = 0; i < Math.ceil((zoom + 8) / 3.0) && i < 5; ++i) {
      digit = (c1 >> (24 - 6 * i)) & 0x3f;
      str += char_array.charAt(digit);
    }
    for (i = 5; i < Math.ceil((zoom + 8) / 3.0); ++i) {
      digit = (c2 >> (24 - 6 * (i - 5))) & 0x3f;
      str += char_array.charAt(digit);
    }
    for (i = 0; i < ((zoom + 8) % 3); ++i) str += "-";

    // Called to interlace the bits in x and y, making a Morton code.
    function interlace(x, y) {
      x = (x | (x << 8)) & 0x00ff00ff;
      x = (x | (x << 4)) & 0x0f0f0f0f;
      x = (x | (x << 2)) & 0x33333333;
      x = (x | (x << 1)) & 0x55555555;
      y = (y | (y << 8)) & 0x00ff00ff;
      y = (y | (y << 4)) & 0x0f0f0f0f;
      y = (y | (y << 2)) & 0x33333333;
      y = (y | (y << 1)) & 0x55555555;
      return (x << 1) | y;
    }

    var params = {};
    var layers = this.getLayersCode().replace('M', '');

    if (layers) {
      params.layers = layers;
    }

    if (marker && this.hasLayer(marker)) {
      params.m = '';
    }

    if (this._object) {
      params[this._object.type] = this._object.id;
    }

    var query = querystring.stringify(params);
    if (query) {
      str += '?' + query;
    }

    return str;
  },

    addObject: function(object, callback) {
        var objectStyle = {
            color: "#FF6200",
            weight: 4,
            opacity: 1,
            fillOpacity: 0.5
        };

        var changesetStyle = {
            weight: 4,
            color: '#FF9500',
            opacity: 1,
            fillOpacity: 0,
            clickable: false
        };

        this._object = object;

        if (this._objectLoader)
            this._objectLoader.abort();
        if (this._objectLayer)
            this.removeLayer(this._objectLayer);

        var map = this;
        this._objectLoader = $.ajax({
            url: OSM.apiUrl(object),
            dataType: "xml",
            success: function(xml) {
                map._objectLayer = new L.OSM.DataLayer(null, {
                    styles: {
                        node: objectStyle,
                        way: objectStyle,
                        area: objectStyle,
                        changeset: changesetStyle
                    }
                });

                map._objectLayer.interestingNode = function(node, ways, relations) {
                    if (object.type === "node") {
                        return true;
                    } else if (object.type === "relation") {
                        for (var i = 0; i < relations.length; i++)
                            if (relations[i].members.indexOf(node) != -1)
                                return true;
                    } else {
                        return false;
                    }
                };

                map._objectLayer.addData(xml);
                map._objectLayer.addTo(map);

                if (callback)
                    callback(map._objectLayer.getBounds());
            }
        });
    },
    removeObject: function() {
        this._object = null;
        if (this._objectLoader)
            this._objectLoader.abort();
        if (this._objectLayer)
            this.removeLayer(this._objectLayer);
    },
    getState: function() {
        return {
            center: this.getCenter().wrap(),
            zoom: this.getZoom(),
            layers: this.getLayersCode()
        }
    },
    setState: function(state, options) {
        if (state.center)
            this.setView(state.center, state.zoom, options);
        this.updateLayers(state.layers);
    }
});

L.Icon.Default.imagePath = "/images";


L.Icon.Default.imageUrls = {
  "/images/marker-icon.png": "/bundles/map2uleaflet/images/marker-icon.png",
  "/images/marker-icon-2x.png": "/bundles/map2uleaflet/images/marker-icon-2x.png",
  "/images/marker-shadow.png": "/bundles/map2uleaflet/images/marker-shadow.png",
  "/images/marker-shadow-2x.png": "/bundles/map2uleaflet/images/marker-shadow-2x.png"
};

L.extend(L.Icon.Default.prototype, {
    _oldGetIconUrl: L.Icon.Default.prototype._getIconUrl,
    _getIconUrl: function(name) {
        var url = this._oldGetIconUrl(name);
        return L.Icon.Default.imageUrls[url];
    }
});

function getUserIcon(url) {
    return L.icon({
//    iconUrl: url || <%= asset_path('marker-red.png').to_json %>,
//    iconSize: [25, 41],
//    iconAnchor: [12, 41],
//    popupAnchor: [1, -34],
//    shadowUrl: <%= asset_path('images/marker-shadow.png').to_json %>,
//    shadowSize: [41, 41]
    });
}


L.MAP2U.TileLayer = L.TileLayer.extend({
    options: {
        url: document.location.protocol === 'https:' ?
                'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png' :
                'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
        attribution: '© <a target="_parent" href="http://www.openstreetmap.org">OpenStreetMap</a> and contributors, under an <a target="_parent" href="http://www.openstreetmap.org/copyright">open license</a>'
    },
    initialize: function(options) {
        options = L.Util.setOptions(this, options);
        L.TileLayer.prototype.initialize.call(this, options.url);
    }
});

L.MAP2U.GoogleMap = L.MAP2U.TileLayer.extend({
    options: {
        url: document.location.protocol === 'https:' ?
                'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png' :
                'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
        maxZoom: 19
    }
});

L.MAP2U.Mapnik = L.MAP2U.TileLayer.extend({
    options: {
        url: document.location.protocol === 'https:' ?
                'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png' :
                'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
        maxZoom: 19
    }
});

L.MAP2U.CycleMap = L.MAP2U.TileLayer.extend({
    options: {
        url: 'http://{s}.tile.opencyclemap.org/cycle/{z}/{x}/{y}.png',
        attribution: "Tiles courtesy of <a href='http://www.opencyclemap.org/' target='_blank'>Andy Allan</a>"
    }
});

L.MAP2U.TransportMap = L.MAP2U.TileLayer.extend({
    options: {
        url: 'http://{s}.tile2.opencyclemap.org/transport/{z}/{x}/{y}.png',
        attribution: "Tiles courtesy of <a href='http://www.opencyclemap.org/' target='_blank'>Andy Allan</a>"
    }
});

L.MAP2U.MapQuestOpen = L.MAP2U.TileLayer.extend({
    options: {
        url: document.location.protocol === 'https:' ?
                'https://otile{s}-s.mqcdn.com/tiles/1.0.0/osm/{z}/{x}/{y}.png' :
                'http://otile{s}.mqcdn.com/tiles/1.0.0/osm/{z}/{x}/{y}.png',
        subdomains: '1234',
        attribution: document.location.protocol === 'https:' ?
                "Tiles courtesy of <a href='http://www.mapquest.com/' target='_blank'>MapQuest</a> <img src='https://developer.mapquest.com/content/osm/mq_logo.png'>" :
                "Tiles courtesy of <a href='http://www.mapquest.com/' target='_blank'>MapQuest</a> <img src='http://developer.mapquest.com/content/osm/mq_logo.png'>"
    }
});

L.MAP2U.HOT = L.MAP2U.TileLayer.extend({
    options: {
        url: 'http://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png',
        maxZoom: 20,
        subdomains: 'abc',
        attribution: "Tiles courtesy of <a href='http://hot.openstreetmap.org/' target='_blank'>Humanitarian OpenStreetMap Team</a>"
    }
});

L.MAP2U.DataLayer = L.FeatureGroup.extend({
    options: {
        areaTags: ['area', 'building', 'leisure', 'tourism', 'ruins', 'historic', 'landuse', 'military', 'natural', 'sport'],
        uninterestingTags: ['source', 'source_ref', 'source:ref', 'history', 'attribution', 'created_by', 'tiger:county', 'tiger:tlid', 'tiger:upload_uuid'],
        styles: {}
    },
    initialize: function(xml, options) {
        L.Util.setOptions(this, options);

        L.FeatureGroup.prototype.initialize.call(this);

        if (xml) {
            this.addData(xml);
        }
    },
    addData: function(features) {
        if (!(features instanceof Array)) {
            features = this.buildFeatures(features);
        }

        for (var i = 0; i < features.length; i++) {
            var feature = features[i], layer;

            if (feature.type === "changeset") {
                layer = L.rectangle(feature.latLngBounds, this.options.styles.changeset);
            } else if (feature.type === "node") {
                layer = L.circleMarker(feature.latLng, this.options.styles.node);
            } else {
                var latLngs = new Array(feature.nodes.length);

                for (var j = 0; j < feature.nodes.length; j++) {
                    latLngs[j] = feature.nodes[j].latLng;
                }

                if (this.isWayArea(feature)) {
                    latLngs.pop(); // Remove last == first.
                    layer = L.polygon(latLngs, this.options.styles.area);
                } else {
                    layer = L.polyline(latLngs, this.options.styles.way);
                }
            }

            layer.addTo(this);
            layer.feature = feature;
        }
    },
    buildFeatures: function(xml) {
        var features = L.MAP2U.getChangesets(xml),
                nodes = L.MAP2U.getNodes(xml),
                ways = L.MAP2U.getWays(xml, nodes),
                relations = L.MAP2U.getRelations(xml, nodes, ways);

        for (var node_id in nodes) {
            var node = nodes[node_id];
            if (this.interestingNode(node, ways, relations)) {
                features.push(node);
            }
        }

        for (var i = 0; i < ways.length; i++) {
            var way = ways[i];
            features.push(way);
        }

        return features;
    },
    isWayArea: function(way) {
        if (way.nodes[0] != way.nodes[way.nodes.length - 1]) {
            return false;
        }

        for (var key in way.tags) {
            if (~this.options.areaTags.indexOf(key)) {
                return true;
            }
        }

        return false;
    },
    interestingNode: function(node, ways, relations) {
        var used = false;

        for (var i = 0; i < ways.length; i++) {
            if (ways[i].nodes.indexOf(node) >= 0) {
                used = true;
                break;
            }
        }

        if (!used) {
            return true;
        }

        for (var i = 0; i < relations.length; i++) {
            if (relations[i].members.indexOf(node) >= 0)
                return true;
        }

        for (var key in node.tags) {
            if (this.options.uninterestingTags.indexOf(key) < 0) {
                return true;
            }
        }

        return false;
    }
});

L.Util.extend(L.MAP2U, {
    getChangesets: function(xml) {
        var result = [];

        var nodes = xml.getElementsByTagName("changeset");
        for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i], id = node.getAttribute("id");
            result.push({
                id: id,
                type: "changeset",
                latLngBounds: L.latLngBounds(
                        [node.getAttribute("min_lat"), node.getAttribute("min_lon")],
                        [node.getAttribute("max_lat"), node.getAttribute("max_lon")]),
                tags: this.getTags(node)
            });
        }

        return result;
    },
    getNodes: function(xml) {
        var result = {};

        var nodes = xml.getElementsByTagName("node");
        for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i], id = node.getAttribute("id");
            result[id] = {
                id: id,
                type: "node",
                latLng: L.latLng(node.getAttribute("lat"),
                        node.getAttribute("lon"),
                        true),
                tags: this.getTags(node)
            };
        }

        return result;
    },
    getWays: function(xml, nodes) {
        var result = [];

        var ways = xml.getElementsByTagName("way");
        for (var i = 0; i < ways.length; i++) {
            var way = ways[i], nds = way.getElementsByTagName("nd");

            var way_object = {
                id: way.getAttribute("id"),
                type: "way",
                nodes: new Array(nds.length),
                tags: this.getTags(way)
            };

            for (var j = 0; j < nds.length; j++) {
                way_object.nodes[j] = nodes[nds[j].getAttribute("ref")];
            }

            result.push(way_object);
        }

        return result;
    },
    getRelations: function(xml, nodes, ways) {
        var result = [];

        var rels = xml.getElementsByTagName("relation");
        for (var i = 0; i < rels.length; i++) {
            var rel = rels[i], members = rel.getElementsByTagName("member");

            var rel_object = {
                id: rel.getAttribute("id"),
                type: "relation",
                members: new Array(members.length),
                tags: this.getTags(rel)
            };

            for (var j = 0; j < members.length; j++) {
                if (members[j].getAttribute("type") === "node")
                    rel_object.members[j] = nodes[members[j].getAttribute("ref")];
                else // relation-way and relation-relation membership not implemented
                    rel_object.members[j] = null;
            }

            result.push(rel_object);
        }

        return result;
    },
    getTags: function(xml) {
        var result = {};

        var tags = xml.getElementsByTagName("tag");
        for (var j = 0; j < tags.length; j++) {
            result[tags[j].getAttribute("k")] = tags[j].getAttribute("v");
        }

        return result;
    }
});


L.MAP2U.MapToolbar = L.Control.extend({
    options: {
        position: 'topleft'
    },
    onAdd: function(map) {
        var zoomName = 'toolbar',
                container = L.DomUtil.create('div', zoomName);

        this._map = map;

        this._zoomFullButton = this._createButton(
                '', I18n.t('javascripts.map.zoom.full'), zoomName + 'full', container, this._zoomFull, this);
//
//        this._zoomInButton = this._createButton(
//                '', I18n.t('javascripts.map.zoom.in'), zoomName + 'in', container, this._zoomIn, this);
//        this._zoomOutButton = this._createButton(
//                '', I18n.t('javascripts.map.zoom.out'), zoomName + 'out', container, this._zoomOut, this);
//
//        this._mapMoveButton = this._createButton(
//                '', I18n.t('javascripts.map.move'), zoomName + 'mapmove', container, this._mapMove, this);
//        this._zoomPrevButton = this._createButton(
//                '', I18n.t('javascripts.map.zoom.prev'), zoomName + 'prev', container, this._zoomPrev, this);
//        this._zoomNextButton = this._createButton(
//                '', I18n.t('javascripts.map.zoom.next'), zoomName + 'next', container, this._zoomNext, this);
//
//        this._measureDistanceButton = this._createButton(
//                '', I18n.t('javascripts.map.measure.distance'), zoomName + 'measuredistance', container, this._measureDistance, this);
//        this._measureAreaButton = this._createButton(
//                '', I18n.t('javascripts.map.measure.area'), zoomName + 'measurearea', container, this._measureArea, this);
//
//
//        this._drawPolylineButton = this._createButton(
//                '', I18n.t('javascripts.map.draw.polyline'), zoomName + 'drawpolyline', container, this._drawPolyline, this);
//        this._drawPolygonButton = this._createButton(
//                '', I18n.t('javascripts.map.draw.polygon'), zoomName + 'drawpolygon', container, this._drawPolygon, this);
//        this._drawRectangleButton = this._createButton(
//                '', I18n.t('javascripts.map.draw.rectangle'), zoomName + 'drawrectangle', container, this._drawRectangle, this);
//
//


        map.on('zoomend zoomlevelschange', this._updateDisabled, this);

        return container;
    },
    onRemove: function(map) {
        map.off('zoomend zoomlevelschange', this._updateDisabled, this);
    },
    _zoomIn: function(e) {
        this._map.zoomIn(e.shiftKey ? 3 : 1);
    },
    _zoomOut: function(e) {
        this._map.zoomOut(e.shiftKey ? 3 : 1);
    },
    _zoomPrev: function(e) {
        this._map.zoomIn(e.shiftKey ? 3 : 1);
    },
    _zoomNext: function(e) {
        this._map.zoomOut(e.shiftKey ? 3 : 1);
    },
    _zoomFull: function(e) {
        this._map.zoomOut(e.shiftKey ? 3 : 1);
    },
    _mapMove: function(e) {
        this._map.zoomOut(e.shiftKey ? 3 : 1);
    },
    _drawPolyline: function(e) {
        this._map.zoomOut(e.shiftKey ? 3 : 1);
    },
    _drawPolygon: function(e) {
        this._map.zoomOut(e.shiftKey ? 3 : 1);
    },
    _drawRectangle: function(e) {
        this._map.zoomOut(e.shiftKey ? 3 : 1);
    },
    _createButton: function(html, title, className, container, fn, context) {

        var link = L.DomUtil.create('a', 'control-button ' + className, container);
        link.innerHTML = html;
        link.href = '#';
        link.title = title;

        var sprite = L.DomUtil.create('span', 'icon ' + className, link);

        var stop = L.DomEvent.stopPropagation;

        L.DomEvent
                .on(link, 'click', stop)
                .on(link, 'mousedown', stop)
                .on(link, 'dblclick', stop)
                .on(link, 'click', L.DomEvent.preventDefault)
                .on(link, 'click', fn, context);

        return link;
    },
    _updateDisabled: function() {
        var map = this._map,
                className = 'leaflet-disabled';

        L.DomUtil.removeClass(this._zoomInButton, className);
        L.DomUtil.removeClass(this._zoomOutButton, className);

        if (map._zoom === map.getMinZoom()) {
            L.DomUtil.addClass(this._zoomOutButton, className);
        }
        if (map._zoom === map.getMaxZoom()) {
            L.DomUtil.addClass(this._zoomInButton, className);
        }
    }
});

L.MAP2U.maptoolbar = function(options) {
    return new L.MAP2U.MapToolbar(options);
};

/*
 Leaflet.markercluster, Provides Beautiful Animated Marker Clustering functionality for Leaflet, a JS library for interactive maps.
 https://github.com/Leaflet/Leaflet.markercluster
 (c) 2012-2013, Dave Leaver, smartrak
*/
(function (window, document, undefined) {/*
 * L.MarkerClusterGroup extends L.FeatureGroup by clustering the markers contained within
 */

L.MarkerClusterGroup = L.FeatureGroup.extend({

	options: {
		maxClusterRadius: 80, //A cluster will cover at most this many pixels from its center
		iconCreateFunction: null,

		spiderfyOnMaxZoom: true,
		showCoverageOnHover: true,
		zoomToBoundsOnClick: true,
		singleMarkerMode: false,

		disableClusteringAtZoom: null,

		// Setting this to false prevents the removal of any clusters outside of the viewpoint, which
		// is the default behaviour for performance reasons.
		removeOutsideVisibleBounds: true,

		//Whether to animate adding markers after adding the MarkerClusterGroup to the map
		// If you are adding individual markers set to true, if adding bulk markers leave false for massive performance gains.
		animateAddingMarkers: false,

		//Increase to increase the distance away that spiderfied markers appear from the center
		spiderfyDistanceMultiplier: 1,

		// When bulk adding layers, adds markers in chunks. Means addLayers may not add all the layers in the call, others will be loaded during setTimeouts
		chunkedLoading: false,
		chunkInterval: 200, // process markers for a maximum of ~ n milliseconds (then trigger the chunkProgress callback)
		chunkDelay: 50, // at the end of each interval, give n milliseconds back to system/browser
		chunkProgress: null, // progress callback: function(processed, total, elapsed) (e.g. for a progress indicator)

		//Options to pass to the L.Polygon constructor
		polygonOptions: {}
	},

	initialize: function (options) {
		L.Util.setOptions(this, options);
		if (!this.options.iconCreateFunction) {
			this.options.iconCreateFunction = this._defaultIconCreateFunction;
		}

		this._featureGroup = L.featureGroup();
		this._featureGroup.on(L.FeatureGroup.EVENTS, this._propagateEvent, this);

		this._nonPointGroup = L.featureGroup();
		this._nonPointGroup.on(L.FeatureGroup.EVENTS, this._propagateEvent, this);

		this._inZoomAnimation = 0;
		this._needsClustering = [];
		this._needsRemoving = []; //Markers removed while we aren't on the map need to be kept track of
		//The bounds of the currently shown area (from _getExpandedVisibleBounds) Updated on zoom/move
		this._currentShownBounds = null;

		this._queue = [];
	},

	addLayer: function (layer) {

		if (layer instanceof L.LayerGroup) {
			var array = [];
			for (var i in layer._layers) {
				array.push(layer._layers[i]);
			}
			return this.addLayers(array);
		}

		//Don't cluster non point data
		if (!layer.getLatLng) {
			this._nonPointGroup.addLayer(layer);
			return this;
		}

		if (!this._map) {
			this._needsClustering.push(layer);
			return this;
		}

		if (this.hasLayer(layer)) {
			return this;
		}


		//If we have already clustered we'll need to add this one to a cluster

		if (this._unspiderfy) {
			this._unspiderfy();
		}

		this._addLayer(layer, this._maxZoom);

		//Work out what is visible
		var visibleLayer = layer,
			currentZoom = this._map.getZoom();
		if (layer.__parent) {
			while (visibleLayer.__parent._zoom >= currentZoom) {
				visibleLayer = visibleLayer.__parent;
			}
		}

		if (this._currentShownBounds.contains(visibleLayer.getLatLng())) {
			if (this.options.animateAddingMarkers) {
				this._animationAddLayer(layer, visibleLayer);
			} else {
				this._animationAddLayerNonAnimated(layer, visibleLayer);
			}
		}
		return this;
	},

	removeLayer: function (layer) {

		if (layer instanceof L.LayerGroup)
		{
			var array = [];
			for (var i in layer._layers) {
				array.push(layer._layers[i]);
			}
			return this.removeLayers(array);
		}

		//Non point layers
		if (!layer.getLatLng) {
			this._nonPointGroup.removeLayer(layer);
			return this;
		}

		if (!this._map) {
			if (!this._arraySplice(this._needsClustering, layer) && this.hasLayer(layer)) {
				this._needsRemoving.push(layer);
			}
			return this;
		}

		if (!layer.__parent) {
			return this;
		}

		if (this._unspiderfy) {
			this._unspiderfy();
			this._unspiderfyLayer(layer);
		}

		//Remove the marker from clusters
		this._removeLayer(layer, true);

		if (this._featureGroup.hasLayer(layer)) {
			this._featureGroup.removeLayer(layer);
			if (layer.setOpacity) {
				layer.setOpacity(1);
			}
		}

		return this;
	},

	//Takes an array of markers and adds them in bulk
	addLayers: function (layersArray) {
		var fg = this._featureGroup,
			npg = this._nonPointGroup,
			chunked = this.options.chunkedLoading,
			chunkInterval = this.options.chunkInterval,
			chunkProgress = this.options.chunkProgress,
			newMarkers, i, l, m;

		if (this._map) {
			var offset = 0,
				started = (new Date()).getTime();
			var process = L.bind(function () {
				var start = (new Date()).getTime();
				for (; offset < layersArray.length; offset++) {
					if (chunked && offset % 200 === 0) {
						// every couple hundred markers, instrument the time elapsed since processing started:
						var elapsed = (new Date()).getTime() - start;
						if (elapsed > chunkInterval) {
							break; // been working too hard, time to take a break :-)
						}
					}

					m = layersArray[offset];

					//Not point data, can't be clustered
					if (!m.getLatLng) {
						npg.addLayer(m);
						continue;
					}

					if (this.hasLayer(m)) {
						continue;
					}

					this._addLayer(m, this._maxZoom);

					//If we just made a cluster of size 2 then we need to remove the other marker from the map (if it is) or we never will
					if (m.__parent) {
						if (m.__parent.getChildCount() === 2) {
							var markers = m.__parent.getAllChildMarkers(),
								otherMarker = markers[0] === m ? markers[1] : markers[0];
							fg.removeLayer(otherMarker);
						}
					}
				}

				if (chunkProgress) {
					// report progress and time elapsed:
					chunkProgress(offset, layersArray.length, (new Date()).getTime() - started);
				}

				if (offset === layersArray.length) {
					//Update the icons of all those visible clusters that were affected
					this._featureGroup.eachLayer(function (c) {
						if (c instanceof L.MarkerCluster && c._iconNeedsUpdate) {
							c._updateIcon();
						}
					});

					this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds);
				} else {
					setTimeout(process, this.options.chunkDelay);
				}
			}, this);

			process();
		} else {
			newMarkers = [];
			for (i = 0, l = layersArray.length; i < l; i++) {
				m = layersArray[i];

				//Not point data, can't be clustered
				if (!m.getLatLng) {
					npg.addLayer(m);
					continue;
				}

				if (this.hasLayer(m)) {
					continue;
				}

				newMarkers.push(m);
			}
			this._needsClustering = this._needsClustering.concat(newMarkers);
		}
		return this;
	},

	//Takes an array of markers and removes them in bulk
	removeLayers: function (layersArray) {
		var i, l, m,
			fg = this._featureGroup,
			npg = this._nonPointGroup;

		if (!this._map) {
			for (i = 0, l = layersArray.length; i < l; i++) {
				m = layersArray[i];
				this._arraySplice(this._needsClustering, m);
				npg.removeLayer(m);
			}
			return this;
		}

		for (i = 0, l = layersArray.length; i < l; i++) {
			m = layersArray[i];

			if (!m.__parent) {
				npg.removeLayer(m);
				continue;
			}

			this._removeLayer(m, true, true);

			if (fg.hasLayer(m)) {
				fg.removeLayer(m);
				if (m.setOpacity) {
					m.setOpacity(1);
				}
			}
		}

		//Fix up the clusters and markers on the map
		this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds);

		fg.eachLayer(function (c) {
			if (c instanceof L.MarkerCluster) {
				c._updateIcon();
			}
		});

		return this;
	},

	//Removes all layers from the MarkerClusterGroup
	clearLayers: function () {
		//Need our own special implementation as the LayerGroup one doesn't work for us

		//If we aren't on the map (yet), blow away the markers we know of
		if (!this._map) {
			this._needsClustering = [];
			delete this._gridClusters;
			delete this._gridUnclustered;
		}

		if (this._noanimationUnspiderfy) {
			this._noanimationUnspiderfy();
		}

		//Remove all the visible layers
		this._featureGroup.clearLayers();
		this._nonPointGroup.clearLayers();

		this.eachLayer(function (marker) {
			delete marker.__parent;
		});

		if (this._map) {
			//Reset _topClusterLevel and the DistanceGrids
			this._generateInitialClusters();
		}

		return this;
	},

	//Override FeatureGroup.getBounds as it doesn't work
	getBounds: function () {
		var bounds = new L.LatLngBounds();

		if (this._topClusterLevel) {
			bounds.extend(this._topClusterLevel._bounds);
		}

		for (var i = this._needsClustering.length - 1; i >= 0; i--) {
			bounds.extend(this._needsClustering[i].getLatLng());
		}

		bounds.extend(this._nonPointGroup.getBounds());

		return bounds;
	},

	//Overrides LayerGroup.eachLayer
	eachLayer: function (method, context) {
		var markers = this._needsClustering.slice(),
			i;

		if (this._topClusterLevel) {
			this._topClusterLevel.getAllChildMarkers(markers);
		}

		for (i = markers.length - 1; i >= 0; i--) {
			method.call(context, markers[i]);
		}

		this._nonPointGroup.eachLayer(method, context);
	},

	//Overrides LayerGroup.getLayers
	getLayers: function () {
		var layers = [];
		this.eachLayer(function (l) {
			layers.push(l);
		});
		return layers;
	},

	//Overrides LayerGroup.getLayer, WARNING: Really bad performance
	getLayer: function (id) {
		var result = null;

		this.eachLayer(function (l) {
			if (L.stamp(l) === id) {
				result = l;
			}
		});

		return result;
	},

	//Returns true if the given layer is in this MarkerClusterGroup
	hasLayer: function (layer) {
		if (!layer) {
			return false;
		}

		var i, anArray = this._needsClustering;

		for (i = anArray.length - 1; i >= 0; i--) {
			if (anArray[i] === layer) {
				return true;
			}
		}

		anArray = this._needsRemoving;
		for (i = anArray.length - 1; i >= 0; i--) {
			if (anArray[i] === layer) {
				return false;
			}
		}

		return !!(layer.__parent && layer.__parent._group === this) || this._nonPointGroup.hasLayer(layer);
	},

	//Zoom down to show the given layer (spiderfying if necessary) then calls the callback
	zoomToShowLayer: function (layer, callback) {

		var showMarker = function () {
			if ((layer._icon || layer.__parent._icon) && !this._inZoomAnimation) {
				this._map.off('moveend', showMarker, this);
				this.off('animationend', showMarker, this);

				if (layer._icon) {
					callback();
				} else if (layer.__parent._icon) {
					var afterSpiderfy = function () {
						this.off('spiderfied', afterSpiderfy, this);
						callback();
					};

					this.on('spiderfied', afterSpiderfy, this);
					layer.__parent.spiderfy();
				}
			}
		};

		if (layer._icon && this._map.getBounds().contains(layer.getLatLng())) {
			//Layer is visible ond on screen, immediate return
			callback();
		} else if (layer.__parent._zoom < this._map.getZoom()) {
			//Layer should be visible at this zoom level. It must not be on screen so just pan over to it
			this._map.on('moveend', showMarker, this);
			this._map.panTo(layer.getLatLng());
		} else {
			var moveStart = function () {
				this._map.off('movestart', moveStart, this);
				moveStart = null;
			};

			this._map.on('movestart', moveStart, this);
			this._map.on('moveend', showMarker, this);
			this.on('animationend', showMarker, this);
			layer.__parent.zoomToBounds();

			if (moveStart) {
				//Never started moving, must already be there, probably need clustering however
				showMarker.call(this);
			}
		}
	},

	//Overrides FeatureGroup.onAdd
	onAdd: function (map) {
		this._map = map;
		var i, l, layer;

		if (!isFinite(this._map.getMaxZoom())) {
			throw "Map has no maxZoom specified";
		}

		this._featureGroup.onAdd(map);
		this._nonPointGroup.onAdd(map);

		if (!this._gridClusters) {
			this._generateInitialClusters();
		}

		for (i = 0, l = this._needsRemoving.length; i < l; i++) {
			layer = this._needsRemoving[i];
			this._removeLayer(layer, true);
		}
		this._needsRemoving = [];

		//Remember the current zoom level and bounds
		this._zoom = this._map.getZoom();
		this._currentShownBounds = this._getExpandedVisibleBounds();

		this._map.on('zoomend', this._zoomEnd, this);
		this._map.on('moveend', this._moveEnd, this);

		if (this._spiderfierOnAdd) { //TODO FIXME: Not sure how to have spiderfier add something on here nicely
			this._spiderfierOnAdd();
		}

		this._bindEvents();

		//Actually add our markers to the map:
		l = this._needsClustering;
		this._needsClustering = [];
		this.addLayers(l);
	},

	//Overrides FeatureGroup.onRemove
	onRemove: function (map) {
		map.off('zoomend', this._zoomEnd, this);
		map.off('moveend', this._moveEnd, this);

		this._unbindEvents();

		//In case we are in a cluster animation
		this._map._mapPane.className = this._map._mapPane.className.replace(' leaflet-cluster-anim', '');

		if (this._spiderfierOnRemove) { //TODO FIXME: Not sure how to have spiderfier add something on here nicely
			this._spiderfierOnRemove();
		}



		//Clean up all the layers we added to the map
		this._hideCoverage();
		this._featureGroup.onRemove(map);
		this._nonPointGroup.onRemove(map);

		this._featureGroup.clearLayers();

		this._map = null;
	},

	getVisibleParent: function (marker) {
		var vMarker = marker;
		while (vMarker && !vMarker._icon) {
			vMarker = vMarker.__parent;
		}
		return vMarker || null;
	},

	//Remove the given object from the given array
	_arraySplice: function (anArray, obj) {
		for (var i = anArray.length - 1; i >= 0; i--) {
			if (anArray[i] === obj) {
				anArray.splice(i, 1);
				return true;
			}
		}
	},

	//Internal function for removing a marker from everything.
	//dontUpdateMap: set to true if you will handle updating the map manually (for bulk functions)
	_removeLayer: function (marker, removeFromDistanceGrid, dontUpdateMap) {
		var gridClusters = this._gridClusters,
			gridUnclustered = this._gridUnclustered,
			fg = this._featureGroup,
			map = this._map;

		//Remove the marker from distance clusters it might be in
		if (removeFromDistanceGrid) {
			for (var z = this._maxZoom; z >= 0; z--) {
				if (!gridUnclustered[z].removeObject(marker, map.project(marker.getLatLng(), z))) {
					break;
				}
			}
		}

		//Work our way up the clusters removing them as we go if required
		var cluster = marker.__parent,
			markers = cluster._markers,
			otherMarker;

		//Remove the marker from the immediate parents marker list
		this._arraySplice(markers, marker);

		while (cluster) {
			cluster._childCount--;

			if (cluster._zoom < 0) {
				//Top level, do nothing
				break;
			} else if (removeFromDistanceGrid && cluster._childCount <= 1) { //Cluster no longer required
				//We need to push the other marker up to the parent
				otherMarker = cluster._markers[0] === marker ? cluster._markers[1] : cluster._markers[0];

				//Update distance grid
				gridClusters[cluster._zoom].removeObject(cluster, map.project(cluster._cLatLng, cluster._zoom));
				gridUnclustered[cluster._zoom].addObject(otherMarker, map.project(otherMarker.getLatLng(), cluster._zoom));

				//Move otherMarker up to parent
				this._arraySplice(cluster.__parent._childClusters, cluster);
				cluster.__parent._markers.push(otherMarker);
				otherMarker.__parent = cluster.__parent;

				if (cluster._icon) {
					//Cluster is currently on the map, need to put the marker on the map instead
					fg.removeLayer(cluster);
					if (!dontUpdateMap) {
						fg.addLayer(otherMarker);
					}
				}
			} else {
				cluster._recalculateBounds();
				if (!dontUpdateMap || !cluster._icon) {
					cluster._updateIcon();
				}
			}

			cluster = cluster.__parent;
		}

		delete marker.__parent;
	},

	_isOrIsParent: function (el, oel) {
		while (oel) {
			if (el === oel) {
				return true;
			}
			oel = oel.parentNode;
		}
		return false;
	},

	_propagateEvent: function (e) {
		if (e.layer instanceof L.MarkerCluster) {
			//Prevent multiple clustermouseover/off events if the icon is made up of stacked divs (Doesn't work in ie <= 8, no relatedTarget)
			if (e.originalEvent && this._isOrIsParent(e.layer._icon, e.originalEvent.relatedTarget)) {
				return;
			}
			e.type = 'cluster' + e.type;
		}

		this.fire(e.type, e);
	},

	//Default functionality
	_defaultIconCreateFunction: function (cluster) {
		var childCount = cluster.getChildCount();

		var c = ' marker-cluster-';
		if (childCount < 10) {
			c += 'small';
		} else if (childCount < 100) {
			c += 'medium';
		} else {
			c += 'large';
		}

		return new L.DivIcon({ html: '<div><span>' + childCount + '</span></div>', className: 'marker-cluster' + c, iconSize: new L.Point(40, 40) });
	},

	_bindEvents: function () {
		var map = this._map,
		    spiderfyOnMaxZoom = this.options.spiderfyOnMaxZoom,
		    showCoverageOnHover = this.options.showCoverageOnHover,
		    zoomToBoundsOnClick = this.options.zoomToBoundsOnClick;

		//Zoom on cluster click or spiderfy if we are at the lowest level
		if (spiderfyOnMaxZoom || zoomToBoundsOnClick) {
			this.on('clusterclick', this._zoomOrSpiderfy, this);
		}

		//Show convex hull (boundary) polygon on mouse over
		if (showCoverageOnHover) {
			this.on('clustermouseover', this._showCoverage, this);
			this.on('clustermouseout', this._hideCoverage, this);
			map.on('zoomend', this._hideCoverage, this);
		}
	},

	_zoomOrSpiderfy: function (e) {
		var map = this._map;
		if (map.getMaxZoom() === map.getZoom()) {
			if (this.options.spiderfyOnMaxZoom) {
				e.layer.spiderfy();
			}
		} else if (this.options.zoomToBoundsOnClick) {
			e.layer.zoomToBounds();
		}

		// Focus the map again for keyboard users.
		if (e.originalEvent && e.originalEvent.keyCode === 13) {
			map._container.focus();
		}
	},

	_showCoverage: function (e) {
		var map = this._map;
		if (this._inZoomAnimation) {
			return;
		}
		if (this._shownPolygon) {
			map.removeLayer(this._shownPolygon);
		}
		if (e.layer.getChildCount() > 2 && e.layer !== this._spiderfied) {
			this._shownPolygon = new L.Polygon(e.layer.getConvexHull(), this.options.polygonOptions);
			map.addLayer(this._shownPolygon);
		}
	},

	_hideCoverage: function () {
		if (this._shownPolygon) {
			this._map.removeLayer(this._shownPolygon);
			this._shownPolygon = null;
		}
	},

	_unbindEvents: function () {
		var spiderfyOnMaxZoom = this.options.spiderfyOnMaxZoom,
			showCoverageOnHover = this.options.showCoverageOnHover,
			zoomToBoundsOnClick = this.options.zoomToBoundsOnClick,
			map = this._map;

		if (spiderfyOnMaxZoom || zoomToBoundsOnClick) {
			this.off('clusterclick', this._zoomOrSpiderfy, this);
		}
		if (showCoverageOnHover) {
			this.off('clustermouseover', this._showCoverage, this);
			this.off('clustermouseout', this._hideCoverage, this);
			map.off('zoomend', this._hideCoverage, this);
		}
	},

	_zoomEnd: function () {
		if (!this._map) { //May have been removed from the map by a zoomEnd handler
			return;
		}
		this._mergeSplitClusters();

		this._zoom = this._map._zoom;
		this._currentShownBounds = this._getExpandedVisibleBounds();
	},

	_moveEnd: function () {
		if (this._inZoomAnimation) {
			return;
		}

		var newBounds = this._getExpandedVisibleBounds();

		this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, this._zoom, newBounds);
		this._topClusterLevel._recursivelyAddChildrenToMap(null, this._map._zoom, newBounds);

		this._currentShownBounds = newBounds;
		return;
	},

	_generateInitialClusters: function () {
		var maxZoom = this._map.getMaxZoom(),
			radius = this.options.maxClusterRadius,
			radiusFn = radius;
	
		//If we just set maxClusterRadius to a single number, we need to create
		//a simple function to return that number. Otherwise, we just have to
		//use the function we've passed in.
		if (typeof radius !== "function") {
			radiusFn = function () { return radius; };
		}

		if (this.options.disableClusteringAtZoom) {
			maxZoom = this.options.disableClusteringAtZoom - 1;
		}
		this._maxZoom = maxZoom;
		this._gridClusters = {};
		this._gridUnclustered = {};
	
		//Set up DistanceGrids for each zoom
		for (var zoom = maxZoom; zoom >= 0; zoom--) {
			this._gridClusters[zoom] = new L.DistanceGrid(radiusFn(zoom));
			this._gridUnclustered[zoom] = new L.DistanceGrid(radiusFn(zoom));
		}

		this._topClusterLevel = new L.MarkerCluster(this, -1);
	},

	//Zoom: Zoom to start adding at (Pass this._maxZoom to start at the bottom)
	_addLayer: function (layer, zoom) {
		var gridClusters = this._gridClusters,
		    gridUnclustered = this._gridUnclustered,
		    markerPoint, z;

		if (this.options.singleMarkerMode) {
			layer.options.icon = this.options.iconCreateFunction({
				getChildCount: function () {
					return 1;
				},
				getAllChildMarkers: function () {
					return [layer];
				}
			});
		}

		//Find the lowest zoom level to slot this one in
		for (; zoom >= 0; zoom--) {
			markerPoint = this._map.project(layer.getLatLng(), zoom); // calculate pixel position

			//Try find a cluster close by
			var closest = gridClusters[zoom].getNearObject(markerPoint);
			if (closest) {
				closest._addChild(layer);
				layer.__parent = closest;
				return;
			}

			//Try find a marker close by to form a new cluster with
			closest = gridUnclustered[zoom].getNearObject(markerPoint);
			if (closest) {
				var parent = closest.__parent;
				if (parent) {
					this._removeLayer(closest, false);
				}

				//Create new cluster with these 2 in it

				var newCluster = new L.MarkerCluster(this, zoom, closest, layer);
				gridClusters[zoom].addObject(newCluster, this._map.project(newCluster._cLatLng, zoom));
				closest.__parent = newCluster;
				layer.__parent = newCluster;

				//First create any new intermediate parent clusters that don't exist
				var lastParent = newCluster;
				for (z = zoom - 1; z > parent._zoom; z--) {
					lastParent = new L.MarkerCluster(this, z, lastParent);
					gridClusters[z].addObject(lastParent, this._map.project(closest.getLatLng(), z));
				}
				parent._addChild(lastParent);

				//Remove closest from this zoom level and any above that it is in, replace with newCluster
				for (z = zoom; z >= 0; z--) {
					if (!gridUnclustered[z].removeObject(closest, this._map.project(closest.getLatLng(), z))) {
						break;
					}
				}

				return;
			}

			//Didn't manage to cluster in at this zoom, record us as a marker here and continue upwards
			gridUnclustered[zoom].addObject(layer, markerPoint);
		}

		//Didn't get in anything, add us to the top
		this._topClusterLevel._addChild(layer);
		layer.__parent = this._topClusterLevel;
		return;
	},

	//Enqueue code to fire after the marker expand/contract has happened
	_enqueue: function (fn) {
		this._queue.push(fn);
		if (!this._queueTimeout) {
			this._queueTimeout = setTimeout(L.bind(this._processQueue, this), 300);
		}
	},
	_processQueue: function () {
		for (var i = 0; i < this._queue.length; i++) {
			this._queue[i].call(this);
		}
		this._queue.length = 0;
		clearTimeout(this._queueTimeout);
		this._queueTimeout = null;
	},

	//Merge and split any existing clusters that are too big or small
	_mergeSplitClusters: function () {

		//Incase we are starting to split before the animation finished
		this._processQueue();

		if (this._zoom < this._map._zoom && this._currentShownBounds.intersects(this._getExpandedVisibleBounds())) { //Zoom in, split
			this._animationStart();
			//Remove clusters now off screen
			this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, this._zoom, this._getExpandedVisibleBounds());

			this._animationZoomIn(this._zoom, this._map._zoom);

		} else if (this._zoom > this._map._zoom) { //Zoom out, merge
			this._animationStart();

			this._animationZoomOut(this._zoom, this._map._zoom);
		} else {
			this._moveEnd();
		}
	},

	//Gets the maps visible bounds expanded in each direction by the size of the screen (so the user cannot see an area we do not cover in one pan)
	_getExpandedVisibleBounds: function () {
		if (!this.options.removeOutsideVisibleBounds) {
			return this.getBounds();
		}

		var map = this._map,
			bounds = map.getBounds(),
			sw = bounds._southWest,
			ne = bounds._northEast,
			latDiff = L.Browser.mobile ? 0 : Math.abs(sw.lat - ne.lat),
			lngDiff = L.Browser.mobile ? 0 : Math.abs(sw.lng - ne.lng);

		return new L.LatLngBounds(
			new L.LatLng(sw.lat - latDiff, sw.lng - lngDiff, true),
			new L.LatLng(ne.lat + latDiff, ne.lng + lngDiff, true));
	},

	//Shared animation code
	_animationAddLayerNonAnimated: function (layer, newCluster) {
		if (newCluster === layer) {
			this._featureGroup.addLayer(layer);
		} else if (newCluster._childCount === 2) {
			newCluster._addToMap();

			var markers = newCluster.getAllChildMarkers();
			this._featureGroup.removeLayer(markers[0]);
			this._featureGroup.removeLayer(markers[1]);
		} else {
			newCluster._updateIcon();
		}
	}
});

L.MarkerClusterGroup.include(!L.DomUtil.TRANSITION ? {

	//Non Animated versions of everything
	_animationStart: function () {
		//Do nothing...
	},
	_animationZoomIn: function (previousZoomLevel, newZoomLevel) {
		this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, previousZoomLevel);
		this._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());

		//We didn't actually animate, but we use this event to mean "clustering animations have finished"
		this.fire('animationend');
	},
	_animationZoomOut: function (previousZoomLevel, newZoomLevel) {
		this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, previousZoomLevel);
		this._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());

		//We didn't actually animate, but we use this event to mean "clustering animations have finished"
		this.fire('animationend');
	},
	_animationAddLayer: function (layer, newCluster) {
		this._animationAddLayerNonAnimated(layer, newCluster);
	}
} : {

	//Animated versions here
	_animationStart: function () {
		this._map._mapPane.className += ' leaflet-cluster-anim';
		this._inZoomAnimation++;
	},
	_animationEnd: function () {
		if (this._map) {
			this._map._mapPane.className = this._map._mapPane.className.replace(' leaflet-cluster-anim', '');
		}
		this._inZoomAnimation--;
		this.fire('animationend');
	},
	_animationZoomIn: function (previousZoomLevel, newZoomLevel) {
		var bounds = this._getExpandedVisibleBounds(),
		    fg = this._featureGroup,
		    i;

		//Add all children of current clusters to map and remove those clusters from map
		this._topClusterLevel._recursively(bounds, previousZoomLevel, 0, function (c) {
			var startPos = c._latlng,
				markers = c._markers,
				m;

			if (!bounds.contains(startPos)) {
				startPos = null;
			}

			if (c._isSingleParent() && previousZoomLevel + 1 === newZoomLevel) { //Immediately add the new child and remove us
				fg.removeLayer(c);
				c._recursivelyAddChildrenToMap(null, newZoomLevel, bounds);
			} else {
				//Fade out old cluster
				c.setOpacity(0);
				c._recursivelyAddChildrenToMap(startPos, newZoomLevel, bounds);
			}

			//Remove all markers that aren't visible any more
			//TODO: Do we actually need to do this on the higher levels too?
			for (i = markers.length - 1; i >= 0; i--) {
				m = markers[i];
				if (!bounds.contains(m._latlng)) {
					fg.removeLayer(m);
				}
			}

		});

		this._forceLayout();

		//Update opacities
		this._topClusterLevel._recursivelyBecomeVisible(bounds, newZoomLevel);
		//TODO Maybe? Update markers in _recursivelyBecomeVisible
		fg.eachLayer(function (n) {
			if (!(n instanceof L.MarkerCluster) && n._icon) {
				n.setOpacity(1);
			}
		});

		//update the positions of the just added clusters/markers
		this._topClusterLevel._recursively(bounds, previousZoomLevel, newZoomLevel, function (c) {
			c._recursivelyRestoreChildPositions(newZoomLevel);
		});

		//Remove the old clusters and close the zoom animation
		this._enqueue(function () {
			//update the positions of the just added clusters/markers
			this._topClusterLevel._recursively(bounds, previousZoomLevel, 0, function (c) {
				fg.removeLayer(c);
				c.setOpacity(1);
			});

			this._animationEnd();
		});
	},

	_animationZoomOut: function (previousZoomLevel, newZoomLevel) {
		this._animationZoomOutSingle(this._topClusterLevel, previousZoomLevel - 1, newZoomLevel);

		//Need to add markers for those that weren't on the map before but are now
		this._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());
		//Remove markers that were on the map before but won't be now
		this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, previousZoomLevel, this._getExpandedVisibleBounds());
	},
	_animationZoomOutSingle: function (cluster, previousZoomLevel, newZoomLevel) {
		var bounds = this._getExpandedVisibleBounds();

		//Animate all of the markers in the clusters to move to their cluster center point
		cluster._recursivelyAnimateChildrenInAndAddSelfToMap(bounds, previousZoomLevel + 1, newZoomLevel);

		var me = this;

		//Update the opacity (If we immediately set it they won't animate)
		this._forceLayout();
		cluster._recursivelyBecomeVisible(bounds, newZoomLevel);

		//TODO: Maybe use the transition timing stuff to make this more reliable
		//When the animations are done, tidy up
		this._enqueue(function () {

			//This cluster stopped being a cluster before the timeout fired
			if (cluster._childCount === 1) {
				var m = cluster._markers[0];
				//If we were in a cluster animation at the time then the opacity and position of our child could be wrong now, so fix it
				m.setLatLng(m.getLatLng());
				if (m.setOpacity) {
					m.setOpacity(1);
				}
			} else {
				cluster._recursively(bounds, newZoomLevel, 0, function (c) {
					c._recursivelyRemoveChildrenFromMap(bounds, previousZoomLevel + 1);
				});
			}
			me._animationEnd();
		});
	},
	_animationAddLayer: function (layer, newCluster) {
		var me = this,
			fg = this._featureGroup;

		fg.addLayer(layer);
		if (newCluster !== layer) {
			if (newCluster._childCount > 2) { //Was already a cluster

				newCluster._updateIcon();
				this._forceLayout();
				this._animationStart();

				layer._setPos(this._map.latLngToLayerPoint(newCluster.getLatLng()));
				layer.setOpacity(0);

				this._enqueue(function () {
					fg.removeLayer(layer);
					layer.setOpacity(1);

					me._animationEnd();
				});

			} else { //Just became a cluster
				this._forceLayout();

				me._animationStart();
				me._animationZoomOutSingle(newCluster, this._map.getMaxZoom(), this._map.getZoom());
			}
		}
	},

	//Force a browser layout of stuff in the map
	// Should apply the current opacity and location to all elements so we can update them again for an animation
	_forceLayout: function () {
		//In my testing this works, infact offsetWidth of any element seems to work.
		//Could loop all this._layers and do this for each _icon if it stops working

		L.Util.falseFn(document.body.offsetWidth);
	}
});

L.markerClusterGroup = function (options) {
	return new L.MarkerClusterGroup(options);
};


L.MarkerCluster = L.Marker.extend({
	initialize: function (group, zoom, a, b) {

		L.Marker.prototype.initialize.call(this, a ? (a._cLatLng || a.getLatLng()) : new L.LatLng(0, 0), { icon: this });


		this._group = group;
		this._zoom = zoom;

		this._markers = [];
		this._childClusters = [];
		this._childCount = 0;
		this._iconNeedsUpdate = true;

		this._bounds = new L.LatLngBounds();

		if (a) {
			this._addChild(a);
		}
		if (b) {
			this._addChild(b);
		}
	},

	//Recursively retrieve all child markers of this cluster
	getAllChildMarkers: function (storageArray) {
		storageArray = storageArray || [];

		for (var i = this._childClusters.length - 1; i >= 0; i--) {
			this._childClusters[i].getAllChildMarkers(storageArray);
		}

		for (var j = this._markers.length - 1; j >= 0; j--) {
			storageArray.push(this._markers[j]);
		}

		return storageArray;
	},

	//Returns the count of how many child markers we have
	getChildCount: function () {
		return this._childCount;
	},

	//Zoom to the minimum of showing all of the child markers, or the extents of this cluster
	zoomToBounds: function () {
		var childClusters = this._childClusters.slice(),
			map = this._group._map,
			boundsZoom = map.getBoundsZoom(this._bounds),
			zoom = this._zoom + 1,
			mapZoom = map.getZoom(),
			i;

		//calculate how far we need to zoom down to see all of the markers
		while (childClusters.length > 0 && boundsZoom > zoom) {
			zoom++;
			var newClusters = [];
			for (i = 0; i < childClusters.length; i++) {
				newClusters = newClusters.concat(childClusters[i]._childClusters);
			}
			childClusters = newClusters;
		}

		if (boundsZoom > zoom) {
			this._group._map.setView(this._latlng, zoom);
		} else if (boundsZoom <= mapZoom) { //If fitBounds wouldn't zoom us down, zoom us down instead
			this._group._map.setView(this._latlng, mapZoom + 1);
		} else {
			this._group._map.fitBounds(this._bounds);
		}
	},

	getBounds: function () {
		var bounds = new L.LatLngBounds();
		bounds.extend(this._bounds);
		return bounds;
	},

	_updateIcon: function () {
		this._iconNeedsUpdate = true;
		if (this._icon) {
			this.setIcon(this);
		}
	},

	//Cludge for Icon, we pretend to be an icon for performance
	createIcon: function () {
		if (this._iconNeedsUpdate) {
			this._iconObj = this._group.options.iconCreateFunction(this);
			this._iconNeedsUpdate = false;
		}
		return this._iconObj.createIcon();
	},
	createShadow: function () {
		return this._iconObj.createShadow();
	},


	_addChild: function (new1, isNotificationFromChild) {

		this._iconNeedsUpdate = true;
		this._expandBounds(new1);

		if (new1 instanceof L.MarkerCluster) {
			if (!isNotificationFromChild) {
				this._childClusters.push(new1);
				new1.__parent = this;
			}
			this._childCount += new1._childCount;
		} else {
			if (!isNotificationFromChild) {
				this._markers.push(new1);
			}
			this._childCount++;
		}

		if (this.__parent) {
			this.__parent._addChild(new1, true);
		}
	},

	//Expand our bounds and tell our parent to
	_expandBounds: function (marker) {
		var addedCount,
		    addedLatLng = marker._wLatLng || marker._latlng;

		if (marker instanceof L.MarkerCluster) {
			this._bounds.extend(marker._bounds);
			addedCount = marker._childCount;
		} else {
			this._bounds.extend(addedLatLng);
			addedCount = 1;
		}

		if (!this._cLatLng) {
			// when clustering, take position of the first point as the cluster center
			this._cLatLng = marker._cLatLng || addedLatLng;
		}

		// when showing clusters, take weighted average of all points as cluster center
		var totalCount = this._childCount + addedCount;

		//Calculate weighted latlng for display
		if (!this._wLatLng) {
			this._latlng = this._wLatLng = new L.LatLng(addedLatLng.lat, addedLatLng.lng);
		} else {
			this._wLatLng.lat = (addedLatLng.lat * addedCount + this._wLatLng.lat * this._childCount) / totalCount;
			this._wLatLng.lng = (addedLatLng.lng * addedCount + this._wLatLng.lng * this._childCount) / totalCount;
		}
	},

	//Set our markers position as given and add it to the map
	_addToMap: function (startPos) {
		if (startPos) {
			this._backupLatlng = this._latlng;
			this.setLatLng(startPos);
		}
		this._group._featureGroup.addLayer(this);
	},

	_recursivelyAnimateChildrenIn: function (bounds, center, maxZoom) {
		this._recursively(bounds, 0, maxZoom - 1,
			function (c) {
				var markers = c._markers,
					i, m;
				for (i = markers.length - 1; i >= 0; i--) {
					m = markers[i];

					//Only do it if the icon is still on the map
					if (m._icon) {
						m._setPos(center);
						m.setOpacity(0);
					}
				}
			},
			function (c) {
				var childClusters = c._childClusters,
					j, cm;
				for (j = childClusters.length - 1; j >= 0; j--) {
					cm = childClusters[j];
					if (cm._icon) {
						cm._setPos(center);
						cm.setOpacity(0);
					}
				}
			}
		);
	},

	_recursivelyAnimateChildrenInAndAddSelfToMap: function (bounds, previousZoomLevel, newZoomLevel) {
		this._recursively(bounds, newZoomLevel, 0,
			function (c) {
				c._recursivelyAnimateChildrenIn(bounds, c._group._map.latLngToLayerPoint(c.getLatLng()).round(), previousZoomLevel);

				//TODO: depthToAnimateIn affects _isSingleParent, if there is a multizoom we may/may not be.
				//As a hack we only do a animation free zoom on a single level zoom, if someone does multiple levels then we always animate
				if (c._isSingleParent() && previousZoomLevel - 1 === newZoomLevel) {
					c.setOpacity(1);
					c._recursivelyRemoveChildrenFromMap(bounds, previousZoomLevel); //Immediately remove our children as we are replacing them. TODO previousBounds not bounds
				} else {
					c.setOpacity(0);
				}

				c._addToMap();
			}
		);
	},

	_recursivelyBecomeVisible: function (bounds, zoomLevel) {
		this._recursively(bounds, 0, zoomLevel, null, function (c) {
			c.setOpacity(1);
		});
	},

	_recursivelyAddChildrenToMap: function (startPos, zoomLevel, bounds) {
		this._recursively(bounds, -1, zoomLevel,
			function (c) {
				if (zoomLevel === c._zoom) {
					return;
				}

				//Add our child markers at startPos (so they can be animated out)
				for (var i = c._markers.length - 1; i >= 0; i--) {
					var nm = c._markers[i];

					if (!bounds.contains(nm._latlng)) {
						continue;
					}

					if (startPos) {
						nm._backupLatlng = nm.getLatLng();

						nm.setLatLng(startPos);
						if (nm.setOpacity) {
							nm.setOpacity(0);
						}
					}

					c._group._featureGroup.addLayer(nm);
				}
			},
			function (c) {
				c._addToMap(startPos);
			}
		);
	},

	_recursivelyRestoreChildPositions: function (zoomLevel) {
		//Fix positions of child markers
		for (var i = this._markers.length - 1; i >= 0; i--) {
			var nm = this._markers[i];
			if (nm._backupLatlng) {
				nm.setLatLng(nm._backupLatlng);
				delete nm._backupLatlng;
			}
		}

		if (zoomLevel - 1 === this._zoom) {
			//Reposition child clusters
			for (var j = this._childClusters.length - 1; j >= 0; j--) {
				this._childClusters[j]._restorePosition();
			}
		} else {
			for (var k = this._childClusters.length - 1; k >= 0; k--) {
				this._childClusters[k]._recursivelyRestoreChildPositions(zoomLevel);
			}
		}
	},

	_restorePosition: function () {
		if (this._backupLatlng) {
			this.setLatLng(this._backupLatlng);
			delete this._backupLatlng;
		}
	},

	//exceptBounds: If set, don't remove any markers/clusters in it
	_recursivelyRemoveChildrenFromMap: function (previousBounds, zoomLevel, exceptBounds) {
		var m, i;
		this._recursively(previousBounds, -1, zoomLevel - 1,
			function (c) {
				//Remove markers at every level
				for (i = c._markers.length - 1; i >= 0; i--) {
					m = c._markers[i];
					if (!exceptBounds || !exceptBounds.contains(m._latlng)) {
						c._group._featureGroup.removeLayer(m);
						if (m.setOpacity) {
							m.setOpacity(1);
						}
					}
				}
			},
			function (c) {
				//Remove child clusters at just the bottom level
				for (i = c._childClusters.length - 1; i >= 0; i--) {
					m = c._childClusters[i];
					if (!exceptBounds || !exceptBounds.contains(m._latlng)) {
						c._group._featureGroup.removeLayer(m);
						if (m.setOpacity) {
							m.setOpacity(1);
						}
					}
				}
			}
		);
	},

	//Run the given functions recursively to this and child clusters
	// boundsToApplyTo: a L.LatLngBounds representing the bounds of what clusters to recurse in to
	// zoomLevelToStart: zoom level to start running functions (inclusive)
	// zoomLevelToStop: zoom level to stop running functions (inclusive)
	// runAtEveryLevel: function that takes an L.MarkerCluster as an argument that should be applied on every level
	// runAtBottomLevel: function that takes an L.MarkerCluster as an argument that should be applied at only the bottom level
	_recursively: function (boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel) {
		var childClusters = this._childClusters,
		    zoom = this._zoom,
			i, c;

		if (zoomLevelToStart > zoom) { //Still going down to required depth, just recurse to child clusters
			for (i = childClusters.length - 1; i >= 0; i--) {
				c = childClusters[i];
				if (boundsToApplyTo.intersects(c._bounds)) {
					c._recursively(boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel);
				}
			}
		} else { //In required depth

			if (runAtEveryLevel) {
				runAtEveryLevel(this);
			}
			if (runAtBottomLevel && this._zoom === zoomLevelToStop) {
				runAtBottomLevel(this);
			}

			//TODO: This loop is almost the same as above
			if (zoomLevelToStop > zoom) {
				for (i = childClusters.length - 1; i >= 0; i--) {
					c = childClusters[i];
					if (boundsToApplyTo.intersects(c._bounds)) {
						c._recursively(boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel);
					}
				}
			}
		}
	},

	_recalculateBounds: function () {
		var markers = this._markers,
			childClusters = this._childClusters,
			i;

		this._bounds = new L.LatLngBounds();
		delete this._wLatLng;

		for (i = markers.length - 1; i >= 0; i--) {
			this._expandBounds(markers[i]);
		}
		for (i = childClusters.length - 1; i >= 0; i--) {
			this._expandBounds(childClusters[i]);
		}
	},


	//Returns true if we are the parent of only one cluster and that cluster is the same as us
	_isSingleParent: function () {
		//Don't need to check this._markers as the rest won't work if there are any
		return this._childClusters.length > 0 && this._childClusters[0]._childCount === this._childCount;
	}
});



L.DistanceGrid = function (cellSize) {
	this._cellSize = cellSize;
	this._sqCellSize = cellSize * cellSize;
	this._grid = {};
	this._objectPoint = { };
};

L.DistanceGrid.prototype = {

	addObject: function (obj, point) {
		var x = this._getCoord(point.x),
		    y = this._getCoord(point.y),
		    grid = this._grid,
		    row = grid[y] = grid[y] || {},
		    cell = row[x] = row[x] || [],
		    stamp = L.Util.stamp(obj);

		this._objectPoint[stamp] = point;

		cell.push(obj);
	},

	updateObject: function (obj, point) {
		this.removeObject(obj);
		this.addObject(obj, point);
	},

	//Returns true if the object was found
	removeObject: function (obj, point) {
		var x = this._getCoord(point.x),
		    y = this._getCoord(point.y),
		    grid = this._grid,
		    row = grid[y] = grid[y] || {},
		    cell = row[x] = row[x] || [],
		    i, len;

		delete this._objectPoint[L.Util.stamp(obj)];

		for (i = 0, len = cell.length; i < len; i++) {
			if (cell[i] === obj) {

				cell.splice(i, 1);

				if (len === 1) {
					delete row[x];
				}

				return true;
			}
		}

	},

	eachObject: function (fn, context) {
		var i, j, k, len, row, cell, removed,
		    grid = this._grid;

		for (i in grid) {
			row = grid[i];

			for (j in row) {
				cell = row[j];

				for (k = 0, len = cell.length; k < len; k++) {
					removed = fn.call(context, cell[k]);
					if (removed) {
						k--;
						len--;
					}
				}
			}
		}
	},

	getNearObject: function (point) {
		var x = this._getCoord(point.x),
		    y = this._getCoord(point.y),
		    i, j, k, row, cell, len, obj, dist,
		    objectPoint = this._objectPoint,
		    closestDistSq = this._sqCellSize,
		    closest = null;

		for (i = y - 1; i <= y + 1; i++) {
			row = this._grid[i];
			if (row) {

				for (j = x - 1; j <= x + 1; j++) {
					cell = row[j];
					if (cell) {

						for (k = 0, len = cell.length; k < len; k++) {
							obj = cell[k];
							dist = this._sqDist(objectPoint[L.Util.stamp(obj)], point);
							if (dist < closestDistSq) {
								closestDistSq = dist;
								closest = obj;
							}
						}
					}
				}
			}
		}
		return closest;
	},

	_getCoord: function (x) {
		return Math.floor(x / this._cellSize);
	},

	_sqDist: function (p, p2) {
		var dx = p2.x - p.x,
		    dy = p2.y - p.y;
		return dx * dx + dy * dy;
	}
};


/* Copyright (c) 2012 the authors listed at the following URL, and/or
the authors of referenced articles or incorporated external code:
http://en.literateprograms.org/Quickhull_(Javascript)?action=history&offset=20120410175256

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Retrieved from: http://en.literateprograms.org/Quickhull_(Javascript)?oldid=18434
*/

(function () {
	L.QuickHull = {

		/*
		 * @param {Object} cpt a point to be measured from the baseline
		 * @param {Array} bl the baseline, as represented by a two-element
		 *   array of latlng objects.
		 * @returns {Number} an approximate distance measure
		 */
		getDistant: function (cpt, bl) {
			var vY = bl[1].lat - bl[0].lat,
				vX = bl[0].lng - bl[1].lng;
			return (vX * (cpt.lat - bl[0].lat) + vY * (cpt.lng - bl[0].lng));
		},

		/*
		 * @param {Array} baseLine a two-element array of latlng objects
		 *   representing the baseline to project from
		 * @param {Array} latLngs an array of latlng objects
		 * @returns {Object} the maximum point and all new points to stay
		 *   in consideration for the hull.
		 */
		findMostDistantPointFromBaseLine: function (baseLine, latLngs) {
			var maxD = 0,
				maxPt = null,
				newPoints = [],
				i, pt, d;

			for (i = latLngs.length - 1; i >= 0; i--) {
				pt = latLngs[i];
				d = this.getDistant(pt, baseLine);

				if (d > 0) {
					newPoints.push(pt);
				} else {
					continue;
				}

				if (d > maxD) {
					maxD = d;
					maxPt = pt;
				}
			}

			return { maxPoint: maxPt, newPoints: newPoints };
		},


		/*
		 * Given a baseline, compute the convex hull of latLngs as an array
		 * of latLngs.
		 *
		 * @param {Array} latLngs
		 * @returns {Array}
		 */
		buildConvexHull: function (baseLine, latLngs) {
			var convexHullBaseLines = [],
				t = this.findMostDistantPointFromBaseLine(baseLine, latLngs);

			if (t.maxPoint) { // if there is still a point "outside" the base line
				convexHullBaseLines =
					convexHullBaseLines.concat(
						this.buildConvexHull([baseLine[0], t.maxPoint], t.newPoints)
					);
				convexHullBaseLines =
					convexHullBaseLines.concat(
						this.buildConvexHull([t.maxPoint, baseLine[1]], t.newPoints)
					);
				return convexHullBaseLines;
			} else {  // if there is no more point "outside" the base line, the current base line is part of the convex hull
				return [baseLine[0]];
			}
		},

		/*
		 * Given an array of latlngs, compute a convex hull as an array
		 * of latlngs
		 *
		 * @param {Array} latLngs
		 * @returns {Array}
		 */
		getConvexHull: function (latLngs) {
			// find first baseline
			var maxLat = false, minLat = false,
				maxPt = null, minPt = null,
				i;

			for (i = latLngs.length - 1; i >= 0; i--) {
				var pt = latLngs[i];
				if (maxLat === false || pt.lat > maxLat) {
					maxPt = pt;
					maxLat = pt.lat;
				}
				if (minLat === false || pt.lat < minLat) {
					minPt = pt;
					minLat = pt.lat;
				}
			}
			var ch = [].concat(this.buildConvexHull([minPt, maxPt], latLngs),
								this.buildConvexHull([maxPt, minPt], latLngs));
			return ch;
		}
	};
}());

L.MarkerCluster.include({
	getConvexHull: function () {
		var childMarkers = this.getAllChildMarkers(),
			points = [],
			p, i;

		for (i = childMarkers.length - 1; i >= 0; i--) {
			p = childMarkers[i].getLatLng();
			points.push(p);
		}

		return L.QuickHull.getConvexHull(points);
	}
});


//This code is 100% based on https://github.com/jawj/OverlappingMarkerSpiderfier-Leaflet
//Huge thanks to jawj for implementing it first to make my job easy :-)

L.MarkerCluster.include({

	_2PI: Math.PI * 2,
	_circleFootSeparation: 25, //related to circumference of circle
	_circleStartAngle: Math.PI / 6,

	_spiralFootSeparation:  28, //related to size of spiral (experiment!)
	_spiralLengthStart: 11,
	_spiralLengthFactor: 5,

	_circleSpiralSwitchover: 9, //show spiral instead of circle from this marker count upwards.
								// 0 -> always spiral; Infinity -> always circle

	spiderfy: function () {
		if (this._group._spiderfied === this || this._group._inZoomAnimation) {
			return;
		}

		var childMarkers = this.getAllChildMarkers(),
			group = this._group,
			map = group._map,
			center = map.latLngToLayerPoint(this._latlng),
			positions;

		this._group._unspiderfy();
		this._group._spiderfied = this;

		//TODO Maybe: childMarkers order by distance to center

		if (childMarkers.length >= this._circleSpiralSwitchover) {
			positions = this._generatePointsSpiral(childMarkers.length, center);
		} else {
			center.y += 10; //Otherwise circles look wrong
			positions = this._generatePointsCircle(childMarkers.length, center);
		}

		this._animationSpiderfy(childMarkers, positions);
	},

	unspiderfy: function (zoomDetails) {
		/// <param Name="zoomDetails">Argument from zoomanim if being called in a zoom animation or null otherwise</param>
		if (this._group._inZoomAnimation) {
			return;
		}
		this._animationUnspiderfy(zoomDetails);

		this._group._spiderfied = null;
	},

	_generatePointsCircle: function (count, centerPt) {
		var circumference = this._group.options.spiderfyDistanceMultiplier * this._circleFootSeparation * (2 + count),
			legLength = circumference / this._2PI,  //radius from circumference
			angleStep = this._2PI / count,
			res = [],
			i, angle;

		res.length = count;

		for (i = count - 1; i >= 0; i--) {
			angle = this._circleStartAngle + i * angleStep;
			res[i] = new L.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle))._round();
		}

		return res;
	},

	_generatePointsSpiral: function (count, centerPt) {
		var legLength = this._group.options.spiderfyDistanceMultiplier * this._spiralLengthStart,
			separation = this._group.options.spiderfyDistanceMultiplier * this._spiralFootSeparation,
			lengthFactor = this._group.options.spiderfyDistanceMultiplier * this._spiralLengthFactor,
			angle = 0,
			res = [],
			i;

		res.length = count;

		for (i = count - 1; i >= 0; i--) {
			angle += separation / legLength + i * 0.0005;
			res[i] = new L.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle))._round();
			legLength += this._2PI * lengthFactor / angle;
		}
		return res;
	},

	_noanimationUnspiderfy: function () {
		var group = this._group,
			map = group._map,
			fg = group._featureGroup,
			childMarkers = this.getAllChildMarkers(),
			m, i;

		this.setOpacity(1);
		for (i = childMarkers.length - 1; i >= 0; i--) {
			m = childMarkers[i];

			fg.removeLayer(m);

			if (m._preSpiderfyLatlng) {
				m.setLatLng(m._preSpiderfyLatlng);
				delete m._preSpiderfyLatlng;
			}
			if (m.setZIndexOffset) {
				m.setZIndexOffset(0);
			}

			if (m._spiderLeg) {
				map.removeLayer(m._spiderLeg);
				delete m._spiderLeg;
			}
		}

		group._spiderfied = null;
	}
});

L.MarkerCluster.include(!L.DomUtil.TRANSITION ? {
	//Non Animated versions of everything
	_animationSpiderfy: function (childMarkers, positions) {
		var group = this._group,
			map = group._map,
			fg = group._featureGroup,
			i, m, leg, newPos;

		for (i = childMarkers.length - 1; i >= 0; i--) {
			newPos = map.layerPointToLatLng(positions[i]);
			m = childMarkers[i];

			m._preSpiderfyLatlng = m._latlng;
			m.setLatLng(newPos);
			if (m.setZIndexOffset) {
				m.setZIndexOffset(1000000); //Make these appear on top of EVERYTHING
			}

			fg.addLayer(m);


			leg = new L.Polyline([this._latlng, newPos], { weight: 1.5, color: '#222' });
			map.addLayer(leg);
			m._spiderLeg = leg;
		}
		this.setOpacity(0.3);
		group.fire('spiderfied');
	},

	_animationUnspiderfy: function () {
		this._noanimationUnspiderfy();
	}
} : {
	//Animated versions here
	SVG_ANIMATION: (function () {
		return document.createElementNS('http://www.w3.org/2000/svg', 'animate').toString().indexOf('SVGAnimate') > -1;
	}()),

	_animationSpiderfy: function (childMarkers, positions) {
		var me = this,
			group = this._group,
			map = group._map,
			fg = group._featureGroup,
			thisLayerPos = map.latLngToLayerPoint(this._latlng),
			i, m, leg, newPos;

		//Add markers to map hidden at our center point
		for (i = childMarkers.length - 1; i >= 0; i--) {
			m = childMarkers[i];

			//If it is a marker, add it now and we'll animate it out
			if (m.setOpacity) {
				m.setZIndexOffset(1000000); //Make these appear on top of EVERYTHING
				m.setOpacity(0);
			
				fg.addLayer(m);

				m._setPos(thisLayerPos);
			} else {
				//Vectors just get immediately added
				fg.addLayer(m);
			}
		}

		group._forceLayout();
		group._animationStart();

		var initialLegOpacity = L.Path.SVG ? 0 : 0.3,
			xmlns = L.Path.SVG_NS;


		for (i = childMarkers.length - 1; i >= 0; i--) {
			newPos = map.layerPointToLatLng(positions[i]);
			m = childMarkers[i];

			//Move marker to new position
			m._preSpiderfyLatlng = m._latlng;
			m.setLatLng(newPos);
			
			if (m.setOpacity) {
				m.setOpacity(1);
			}


			//Add Legs.
			leg = new L.Polyline([me._latlng, newPos], { weight: 1.5, color: '#222', opacity: initialLegOpacity });
			map.addLayer(leg);
			m._spiderLeg = leg;

			//Following animations don't work for canvas
			if (!L.Path.SVG || !this.SVG_ANIMATION) {
				continue;
			}

			//How this works:
			//http://stackoverflow.com/questions/5924238/how-do-you-animate-an-svg-path-in-ios
			//http://dev.opera.com/articles/view/advanced-svg-animation-techniques/

			//Animate length
			var length = leg._path.getTotalLength();
			leg._path.setAttribute("stroke-dasharray", length + "," + length);

			var anim = document.createElementNS(xmlns, "animate");
			anim.setAttribute("attributeName", "stroke-dashoffset");
			anim.setAttribute("begin", "indefinite");
			anim.setAttribute("from", length);
			anim.setAttribute("to", 0);
			anim.setAttribute("dur", 0.25);
			leg._path.appendChild(anim);
			anim.beginElement();

			//Animate opacity
			anim = document.createElementNS(xmlns, "animate");
			anim.setAttribute("attributeName", "stroke-opacity");
			anim.setAttribute("attributeName", "stroke-opacity");
			anim.setAttribute("begin", "indefinite");
			anim.setAttribute("from", 0);
			anim.setAttribute("to", 0.5);
			anim.setAttribute("dur", 0.25);
			leg._path.appendChild(anim);
			anim.beginElement();
		}
		me.setOpacity(0.3);

		//Set the opacity of the spiderLegs back to their correct value
		// The animations above override this until they complete.
		// If the initial opacity of the spiderlegs isn't 0 then they appear before the animation starts.
		if (L.Path.SVG) {
			this._group._forceLayout();

			for (i = childMarkers.length - 1; i >= 0; i--) {
				m = childMarkers[i]._spiderLeg;

				m.options.opacity = 0.5;
				m._path.setAttribute('stroke-opacity', 0.5);
			}
		}

		setTimeout(function () {
			group._animationEnd();
			group.fire('spiderfied');
		}, 200);
	},

	_animationUnspiderfy: function (zoomDetails) {
		var group = this._group,
			map = group._map,
			fg = group._featureGroup,
			thisLayerPos = zoomDetails ? map._latLngToNewLayerPoint(this._latlng, zoomDetails.zoom, zoomDetails.center) : map.latLngToLayerPoint(this._latlng),
			childMarkers = this.getAllChildMarkers(),
			svg = L.Path.SVG && this.SVG_ANIMATION,
			m, i, a;

		group._animationStart();

		//Make us visible and bring the child markers back in
		this.setOpacity(1);
		for (i = childMarkers.length - 1; i >= 0; i--) {
			m = childMarkers[i];

			//Marker was added to us after we were spidified
			if (!m._preSpiderfyLatlng) {
				continue;
			}

			//Fix up the location to the real one
			m.setLatLng(m._preSpiderfyLatlng);
			delete m._preSpiderfyLatlng;
			//Hack override the location to be our center
			if (m.setOpacity) {
				m._setPos(thisLayerPos);
				m.setOpacity(0);
			} else {
				fg.removeLayer(m);
			}

			//Animate the spider legs back in
			if (svg) {
				a = m._spiderLeg._path.childNodes[0];
				a.setAttribute('to', a.getAttribute('from'));
				a.setAttribute('from', 0);
				a.beginElement();

				a = m._spiderLeg._path.childNodes[1];
				a.setAttribute('from', 0.5);
				a.setAttribute('to', 0);
				a.setAttribute('stroke-opacity', 0);
				a.beginElement();

				m._spiderLeg._path.setAttribute('stroke-opacity', 0);
			}
		}

		setTimeout(function () {
			//If we have only <= one child left then that marker will be shown on the map so don't remove it!
			var stillThereChildCount = 0;
			for (i = childMarkers.length - 1; i >= 0; i--) {
				m = childMarkers[i];
				if (m._spiderLeg) {
					stillThereChildCount++;
				}
			}


			for (i = childMarkers.length - 1; i >= 0; i--) {
				m = childMarkers[i];

				if (!m._spiderLeg) { //Has already been unspiderfied
					continue;
				}


				if (m.setOpacity) {
					m.setOpacity(1);
					m.setZIndexOffset(0);
				}

				if (stillThereChildCount > 1) {
					fg.removeLayer(m);
				}

				map.removeLayer(m._spiderLeg);
				delete m._spiderLeg;
			}
			group._animationEnd();
		}, 200);
	}
});


L.MarkerClusterGroup.include({
	//The MarkerCluster currently spiderfied (if any)
	_spiderfied: null,

	_spiderfierOnAdd: function () {
		this._map.on('click', this._unspiderfyWrapper, this);

		if (this._map.options.zoomAnimation) {
			this._map.on('zoomstart', this._unspiderfyZoomStart, this);
		}
		//Browsers without zoomAnimation or a big zoom don't fire zoomstart
		this._map.on('zoomend', this._noanimationUnspiderfy, this);

		if (L.Path.SVG && !L.Browser.touch) {
			this._map._initPathRoot();
			//Needs to happen in the pageload, not after, or animations don't work in webkit
			//  http://stackoverflow.com/questions/8455200/svg-animate-with-dynamically-added-elements
			//Disable on touch browsers as the animation messes up on a touch zoom and isn't very noticable
		}
	},

	_spiderfierOnRemove: function () {
		this._map.off('click', this._unspiderfyWrapper, this);
		this._map.off('zoomstart', this._unspiderfyZoomStart, this);
		this._map.off('zoomanim', this._unspiderfyZoomAnim, this);

		this._unspiderfy(); //Ensure that markers are back where they should be
	},


	//On zoom start we add a zoomanim handler so that we are guaranteed to be last (after markers are animated)
	//This means we can define the animation they do rather than Markers doing an animation to their actual location
	_unspiderfyZoomStart: function () {
		if (!this._map) { //May have been removed from the map by a zoomEnd handler
			return;
		}

		this._map.on('zoomanim', this._unspiderfyZoomAnim, this);
	},
	_unspiderfyZoomAnim: function (zoomDetails) {
		//Wait until the first zoomanim after the user has finished touch-zooming before running the animation
		if (L.DomUtil.hasClass(this._map._mapPane, 'leaflet-touching')) {
			return;
		}

		this._map.off('zoomanim', this._unspiderfyZoomAnim, this);
		this._unspiderfy(zoomDetails);
	},


	_unspiderfyWrapper: function () {
		/// <summary>_unspiderfy but passes no arguments</summary>
		this._unspiderfy();
	},

	_unspiderfy: function (zoomDetails) {
		if (this._spiderfied) {
			this._spiderfied.unspiderfy(zoomDetails);
		}
	},

	_noanimationUnspiderfy: function () {
		if (this._spiderfied) {
			this._spiderfied._noanimationUnspiderfy();
		}
	},

	//If the given layer is currently being spiderfied then we unspiderfy it so it isn't on the map anymore etc
	_unspiderfyLayer: function (layer) {
		if (layer._spiderLeg) {
			this._featureGroup.removeLayer(layer);

			layer.setOpacity(1);
			//Position will be fixed up immediately in _animationUnspiderfy
			layer.setZIndexOffset(0);

			this._map.removeLayer(layer._spiderLeg);
			delete layer._spiderLeg;
		}
	}
});


}(window, document));
L.MAP2U.note = function (options) {
  var control = L.control(options);

  control.onAdd = function (map) {
    var $container = $('<div>')
      .attr('class', 'control-note');

    var link = $('<a>')
      .attr('class', 'control-button')
      .attr('href', '#')
      .html('<span class="icon note"></span>')
      .appendTo($container);

    map.on('zoomend', update);

    update();

    function update() {
      var disabled = map.getZoom() < 12;
      link
        .toggleClass('disabled', disabled)
        .attr('data-original-title', I18n.t(disabled ?
          'javascripts.site.createnote_disabled_tooltip' :
          'javascripts.site.createnote_tooltip'));
    }

    return $container[0];
  };

  return control;
};

L.PhotoMarkerMatrix = L.Class.extend({
  initialize: function(config) {
    var levels = [];
    for(var k in config) {
      levels.push(parseInt(k, 10));
    }
    // Sort the levels array numerically
    levels.sort(function(a,b){return(a-b);});
    var m = this.metric = {};
    // Find the highest and lowest zooms we have data for
    m.min = levels[0];
    m.minScale = config[levels[0]];
    m.max = levels[levels.length-1];
    m.maxScale = config[levels[levels.length-1]];
    m.zooms = {};
    var last;
    for(var i = m.min; i <= m.max; i ++) {
      if(config[i]) {
        m.zooms[i] = config[i];
        last = config[i];
      }
      else {
        m.zooms[i] = (last !== undefined) ? last : config[m.max];
      }
    }
  },
  findScale: function(zoom) {
    var m = this.metric,
        z = parseInt(zoom, 10);

    if ( z < m.min ) {
      return m.minScale;
    }
    else if ( z > m.max ) {
      return m.maxScale;
    }
    else {
      return (m.zooms[z] !== undefined) ? m.zooms[z] : m.maxScale;
    }
  }
});

L.PhotoIcon = L.Class.extend({
  options: {
    className: 'leaflet-photomarker-img'
  },

  initialize: function (options) {
    L.setOptions(this, options);
    this.original_size = L.point(options.size);
    this.size = this.original_size;
  },

  scale: function(factor) {
    var to = this.original_size.multiplyBy(factor);
    if ( (to.x !== this.size.x) && (to.y !== this.size.y) ) {
      this.resize(to);
    }
  },

  createIcon: function () {
    var src = this.options.src;

    if (!src) {
      if (name === 'icon') {
        throw new Error("iconUrl not set in Icon options (see the docs).");
      }
      return null;
    }

    this._container = L.DomUtil.create("div", 'leaflet-photomarker-container');
    this._container.style.position = 'relative';
    this.img = this._createImg(src);
    this._container.appendChild(this.img);

    // Add class names
    L.DomUtil.addClass(this.img, 'leaflet-marker-icon');
    L.DomUtil.addClass(this.img, this.options.className);

    // Set size styles
    this._setIconSize(this.img, this.size);

    // return this.img;
    return this._container;
  },

  resize: function(size) {
    this.size = size;
    this._setIconSize(this.img, this.size);
  },

  createShadow: function () {
    return null;
  },

  _setIconSize: function (img, size) {
    var anchor = size.divideBy(2, true);

    if (anchor) {
      img.style.marginLeft = (-anchor.x) + 'px';
      img.style.marginTop  = (-anchor.y) + 'px';
    }

    if (size) {
      img.style.width  = size.x + 'px';
      img.style.height = size.y + 'px';
    }
  },

  _createImg: function (src) {
    var el;

    if (!L.Browser.ie6) {
      el = document.createElement('img');
      el.src = src;
    } else {
      el = document.createElement('div');
      el.style.filter =
              'progid:DXImageTransform.Microsoft.AlphaImageLoader(src="' + src + '")';
    }
    return el;
  }
});

L.PhotoMarker = L.Marker.extend({
  options: {
    title: '',
    clickable: true,
    draggable: false,
    zIndexOffset: 0,
    opacity: 1,
    riseOnHover: true,
    riseOffset: 250,
    // Default zoom matrix
    matrix: { 11: 0.125, 12: 0.25, 14: 0.5, 16: 1 }
  },
  initialize: function(latlng, options) {
    options.icon = new L.PhotoIcon({src:options.src,size:options.size});
    L.Marker.prototype.initialize.call(this, latlng, options);
  },
  _initIcon: function() {
    L.Marker.prototype._initIcon.call(this);
    this.resize();
  },
  onAdd: function(map) {
    map.on('zoomend', this.resize, this);
    L.Marker.prototype.onAdd.call(this, map);
  },
  onRemove: function(map) {
    map.off('zoomend', this.resize, this);
    L.Marker.prototype.onRemove.call(this, map);
  },
  scale: function(factor) {
    var icon = this.options.icon;
    icon.scale(factor);
  },
  resize: function() {
    if ( typeof(this.options.resize) === 'function' ) {
      this.options.resize.call(this,this._map);
    }
    else {
      this._resize(this._map);
    }
  },
  _resize: function(map) {
    // Only instantiate the matrix here if we're not overriden
    if ( this.matrix === undefined ) {
      this.matrix = new L.PhotoMarkerMatrix(this.options.matrix);
    }
    this.scale( this.matrix.findScale(map.getZoom()) );
  }
});

L.photoMarker = function (latlng, options) {
  return new L.PhotoMarker(latlng, options);
};

L.MAP2U.share = function (options) {
  var control = L.control(options),
    marker = L.marker([0, 0], {draggable: true}),
    locationFilter = new L.LocationFilter({
      enableButton: false,
      adjustButton: false
    });

  control.onAdd = function (map) {
    var $container = $('<div>')
      .attr('class', 'control-share');

    var button = $('<a>')
      .attr('class', 'control-button')
      .attr('href', '#')
      .attr('title', I18n.t('javascripts.share.title'))
      .html('<span class="icon share"></span>')
      .on('click', toggle)
      .appendTo($container);

    var $ui = $('<div>')
      .attr('class', 'share-ui');

    $('<div>')
      .attr('class', 'sidebar_heading')
      .appendTo($ui)
      .append(
        $('<span>')
          .text(I18n.t('javascripts.close'))
          .attr('class', 'icon close')
          .bind('click', toggle))
      .append(
        $('<h4>')
          .text(I18n.t('javascripts.share.title')));

    // Link / Embed
   var barContent = $('<div>')
                .attr('class', 'sidebar_content')
                .appendTo($ui)
        
    var $linkSection = $('<div>')
      .attr('class', 'section share-link')
      .appendTo(barContent);

    $('<h4>')
      .text(I18n.t('javascripts.share.link'))
      .appendTo($linkSection);

    var $form = $('<form>')
      .attr('class', 'standard-form')
      .appendTo($linkSection);

    $('<div>')
      .attr('class', 'form-row')
      .appendTo($form)
      .append(
        $('<label>')
          .attr('for', 'link_marker')
          .append(
            $('<input>')
              .attr('id', 'link_marker')
              .attr('type', 'checkbox')
              .bind('change', toggleMarker))
          .append(I18n.t('javascripts.share.include_marker')));

    $('<div>')
      .attr('class', 'share-tabs')
      .appendTo($form)
      .append($('<a>')
        .attr('class', 'active')
        .attr('for', 'long_input')
        .attr('id', 'long_link')
        .text(I18n.t('javascripts.share.long_link')))
      .append($('<a>')
        .attr('for', 'short_input')
        .attr('id', 'short_link')
        .text(I18n.t('javascripts.share.short_link')))
      .append($('<a>')
        .attr('for', 'embed_html')
        .attr('href', '#')
        .text(I18n.t('javascripts.share.embed')))
      .on('click', 'a', function(e) {
        e.preventDefault();
        var id = '#' + $(this).attr('for');
        $linkSection.find('.share-tabs a')
          .removeClass('active');
        $(this).addClass('active');
        $linkSection.find('.share-tab')
          .hide();
        $linkSection.find('.share-tab:has(' + id + ')')
          .show()
          .find('input, textarea')
          .select();
      });

    $('<div>')
      .attr('class', 'form-row share-tab')
      .css('display', 'block')
      .appendTo($form)
      .append($('<input>')
        .attr('id', 'long_input')
        .attr('type', 'text')
        .on('click', select));

    $('<div>')
      .attr('class', 'form-row share-tab')
      .appendTo($form)
      .append($('<input>')
        .attr('id', 'short_input')
        .attr('type', 'text')
        .on('click', select));

    $('<div>')
      .attr('class', 'form-row share-tab')
      .appendTo($form)
      .append(
        $('<textarea>')
          .attr('id', 'embed_html')
          .on('click', select))
      .append(
        $('<p>')
          .attr('class', 'deemphasize')
          .text(I18n.t('javascripts.share.paste_html'))
          .appendTo($linkSection));

    // Image

    var $imageSection = $('<div>')
      .attr('class', 'section share-image')
      .appendTo(barContent);

    $('<h4>')
      .text(I18n.t('javascripts.share.image'))
      .appendTo($imageSection);

    $form = $('<form>')
      .attr('class', 'standard-form')
      .attr('action', '/export/finish')
      .attr('method', 'post')
      .appendTo($imageSection);

    $('<div>')
      .attr('class', 'form-row')
      .appendTo($form)
      .append(
        $('<label>')
          .attr('for', 'image_filter')
          .append(
            $('<input>')
              .attr('id', 'image_filter')
              .attr('type', 'checkbox')
              .bind('change', toggleFilter))
          .append(I18n.t('javascripts.share.custom_dimensions')));

    $('<div>')
      .attr('class', 'form-row')
      .appendTo($form)
      .append(
        $('<label>')
          .attr('for', 'mapnik_format')
          .text(I18n.t('javascripts.share.format')))
      .append($('<select>')
        .attr('name', 'mapnik_format')
        .attr('id', 'mapnik_format')
        .append($('<option>').val('png').text('PNG').prop('selected', true))
        .append($('<option>').val('jpeg').text('JPEG'))
        .append($('<option>').val('svg').text('SVG'))
        .append($('<option>').val('pdf').text('PDF')));

    $('<div>')
      .attr('class', 'form-row')
      .appendTo($form)
      .append($('<label>')
        .attr('for', 'mapnik_scale')
        .text(I18n.t('javascripts.share.scale')))
      .append('1 : ')
      .append($('<input>')
        .attr('name', 'mapnik_scale')
        .attr('id', 'mapnik_scale')
        .attr('type', 'text')
        .on('change', update));

    ['minlon', 'minlat', 'maxlon', 'maxlat'].forEach(function(name) {
      $('<input>')
        .attr('id', 'mapnik_' + name)
        .attr('name', name)
        .attr('type', 'hidden')
        .appendTo($form);
    });

    $('<input>')
      .attr('name', 'format')
      .attr('value', 'mapnik')
      .attr('type', 'hidden')
      .appendTo($form);

    $('<p>')
      .attr('class', 'deemphasize')
      .html(I18n.t('javascripts.share.image_size') + ' <span id="mapnik_image_width"></span> x <span id="mapnik_image_height"></span>')
      .appendTo($form);

    $('<input>')
      .attr('type', 'submit')
      .attr('value', I18n.t('javascripts.share.download'))
      .appendTo($form);

    locationFilter
      .on('change', update)
      .addTo(map);

    marker.on('dragend', movedMarker);
    map.on('move', movedMap);
    map.on('moveend layeradd layerremove', update);

    options.sidebar.addPane($ui);
    
    jQuery(window).resize(function() { 
        barContent.height($('.leaflet-sidebar.right').height()-70);
    });
    
    $ui
      .on('hide', hidden);

    function hidden() {
      map.removeLayer(marker);
      map.options.scrollWheelZoom = map.options.doubleClickZoom = true;
      locationFilter.disable();
      update();
    }

    function toggle(e) {
      e.stopPropagation();
      e.preventDefault();

      $('#mapnik_scale').val(getScale());
      marker.setLatLng(map.getCenter());

      update();
      options.sidebar.togglePane($ui, button);
      $('.leaflet-control .control-button').tooltip('hide');
    }

    function toggleMarker() {
      if ($(this).is(':checked')) {
        marker.setLatLng(map.getCenter());
        map.addLayer(marker);
        map.options.scrollWheelZoom = map.options.doubleClickZoom = 'center';
      } else {
        map.removeLayer(marker);
        map.options.scrollWheelZoom = map.options.doubleClickZoom = true;
      }
      update();
    }

    function toggleFilter() {
      if ($(this).is(':checked')) {
        locationFilter.setBounds(map.getBounds().pad(-0.2));
        locationFilter.enable();
      } else {
        locationFilter.disable();
      }
      update();
    }

    function movedMap() {
      marker.setLatLng(map.getCenter());
      update();
    }

    function movedMarker() {
      if (map.hasLayer(marker)) {
        map.off('move', movedMap);
        map.on('moveend', updateOnce);
        map.panTo(marker.getLatLng());
      }
    }

    function updateOnce() {
      map.off('moveend', updateOnce);
      map.on('move', movedMap);
      update();
    }

    function update() {
      var bounds = map.getBounds();

      $('#link_marker')
        .prop('checked', map.hasLayer(marker));

      $('#image_filter')
        .prop('checked', locationFilter.isEnabled());

      // Link / Embed

      $('#short_input').val(map.getShortUrl(marker));
      $('#long_input').val(map.getUrl(marker));
      $('#short_link').attr('href', map.getShortUrl(marker));
      $('#long_link').attr('href', map.getUrl(marker));

      var params = {
        bbox: bounds.toBBoxString(),
        layer: map.getMapBaseLayerId()
      };

      if (map.hasLayer(marker)) {
        var latLng = marker.getLatLng().wrap();
        params.marker = latLng.lat + ',' + latLng.lng;
      }

      $('#embed_html').val(
        '<iframe width="425" height="350" frameborder="0" scrolling="no" marginheight="0" marginwidth="0" src="' +
          escapeHTML('http://' + OSM.SERVER_URL + '/export/embed.html?' + $.param(params)) +
          '" style="border: 1px solid black"></iframe><br/>' +
          '<small><a href="' + escapeHTML(map.getUrl(marker)) + '">' +
          escapeHTML(I18n.t('javascripts.share.view_larger_map')) + '</a></small>');

      // Image

      if (locationFilter.isEnabled()) {
        bounds = locationFilter.getBounds();
      }

      var scale = $("#mapnik_scale").val(),
        size = L.bounds(L.CRS.EPSG3857.project(bounds.getSouthWest()),
                        L.CRS.EPSG3857.project(bounds.getNorthEast())).getSize(),
        maxScale = Math.floor(Math.sqrt(size.x * size.y / 0.3136));

      $('#mapnik_minlon').val(bounds.getWest());
      $('#mapnik_minlat').val(bounds.getSouth());
      $('#mapnik_maxlon').val(bounds.getEast());
      $('#mapnik_maxlat').val(bounds.getNorth());

      if (scale < maxScale) {
        scale = roundScale(maxScale);
        $("#mapnik_scale").val(scale);
      }

      $("#mapnik_image_width").text(Math.round(size.x / scale / 0.00028));
      $("#mapnik_image_height").text(Math.round(size.y / scale / 0.00028));
    }

    function select() {
      $(this).select();
    }

    function getScale() {
      var bounds = map.getBounds(),
        centerLat = bounds.getCenter().lat,
        halfWorldMeters = 6378137 * Math.PI * Math.cos(centerLat * Math.PI / 180),
        meters = halfWorldMeters * (bounds.getEast() - bounds.getWest()) / 180,
        pixelsPerMeter = map.getSize().x / meters,
        metersPerPixel = 1 / (92 * 39.3701);
      return Math.round(1 / (pixelsPerMeter * metersPerPixel));
    }

    function roundScale(scale) {
      var precision = 5 * Math.pow(10, Math.floor(Math.LOG10E * Math.log(scale)) - 2);
      return precision * Math.ceil(scale / precision);
    }

    return $container[0];
  };

  return control;
};

L.MAP2U.sidebar = function(selector) {
  var control = {},
    sidebar = $(selector),
    current = $(),
    currentButton  = $(),
    map;

  control.addTo = function (_) {
    map = _;
    return control;
  };

  control.addPane = function(pane) {
    pane
      .hide()
      .appendTo(sidebar);
      
  };

  control.togglePane = function(pane, button) {
    current
      .hide()
      .trigger('hide');

    currentButton
      .removeClass('active');

    if (current === pane) {
      $(sidebar).hide();
      current = currentButton = $();
    } else {
      $(sidebar).show();
      current = pane;
      currentButton = button || $();
    }

    map.invalidateSize({pan: false, animate: false});

    current
      .show()
      .trigger('show');

    currentButton
      .addClass('active');
  };

  return control;
};

L.SpinMapMixin = {
    spin: function (state, options) {
        if (!!state) {
            // start spinning !
            if (!this._spinner) {
                this._spinner = new Spinner(options).spin(this._container);
                this._spinning = 0;
            }
            this._spinning++;
        }
        else {
            this._spinning--;
            if (this._spinning <= 0) {
                // end spinning !
                if (this._spinner) {
                    this._spinner.stop();
                    this._spinner = null;
                }
            }
        }
    }
};

L.Map.include(L.SpinMapMixin);

L.Map.addInitHook(function () {
    this.on('layeradd', function (e) {
        // If added layer is currently loading, spin !
        if (e.layer.loading) this.spin(true);
        if (typeof e.layer.on != 'function') return;
        e.layer.on('data:loading', function () { this.spin(true); }, this);
        e.layer.on('data:loaded',  function () { this.spin(false); }, this);
    }, this);
    this.on('layerremove', function (e) {
        // Clean-up
        if (e.layer.loading) this.spin(false);
        if (typeof e.layer.on != 'function') return;
        e.layer.off('data:loaded');
        e.layer.off('data:loading');
    }, this);
});

L.MAP2U.uploadfile = function(options) {
    var control = L.control(options);

    control.onAdd = function(map) {
        var $container = $('<div>')
                .attr('class', 'leaflet-control control-uploadfile');

        var link = $('<a>')
                .attr('class', 'control-button')
                .attr('href', '#')
                .html('<span class="icon uploadfile"></span>')
                .on('click', toggle)
                .appendTo($container);

        var $ui = $('<div>')
                .attr('class', 'uploadfile-ui');

        $('<div>')
                .attr('class', 'sidebar_heading')
                .appendTo($ui)
                .append(
                        $('<h4>')
                        .text(I18n.t('javascripts.uploadfile.title')));

        var uploadfile_link = $('<div>')
                .attr('class', 'uploadfile_link');
        uploadfile_link.append('<a class="uploadfile" rel="tooltip"   href="#" title="Upload Shapefile" id="shapefileform">Shapefile</a>');
        uploadfile_link.append('<a class="help"  rel="tooltip"  title="Upload Shapefile Help" href="'+Routing.generate('help_uploadshapefile',{'_locale':  window.locale})+'" target="_blank"><i class="fa fa-question-circle"></i></a>');
        uploadfile_link.append('<a class="uploadfile" rel="tooltip"   href="#" title="Upload Mapinfo File" id="mapinfofileform">Mapinfo</a>');
        uploadfile_link.append('<a class="help"  rel="tooltip"  title="Upload Mapinfo File Help" href="'+Routing.generate('help_uploadmapinfofile',{'_locale':  window.locale})+'" target="_blank"><i class="fa fa-question-circle"></i></a>');
        uploadfile_link.append('<a class="uploadfile" rel="tooltip"   href="#" title="Upload KML File" id="kmlfileform">KML</a>');
        uploadfile_link.append('<a class="help"  rel="tooltip"  title="Upload KML File Help" href="'+Routing.generate('help_uploadkmlfile',{'_locale':  window.locale})+'" target="_blank"><i class="fa fa-question-circle"></i></a>');
        uploadfile_link.append('<a class="uploadfile" rel="tooltip"   href="#" title="Upload Text File" id="textfileform">Text</a>');
        uploadfile_link.append('<a class="help"  rel="tooltip"  title="Upload Text File Help" href="'+Routing.generate('help_uploadtextfile',{'_locale':  window.locale})+'" target="_blank"><i class="fa fa-question-circle"></i></a>');
        uploadfile_link.appendTo($ui);

        var barContent = $('<div>')
                .attr('class', 'sidebar_content')
                .appendTo($ui);

        var $section = $('<div>')
                .attr('class', 'section')
                .appendTo(barContent);

        list = $('<ul>')
                .appendTo($section);

        options.sidebar.addPane($ui);
        jQuery(window).resize(function() {
            barContent.height($('.leaflet-sidebar.right').height() - 70);
        });

        $.ajax({
            url: Routing.generate('default_uploadshapefileform',{'_locale':  window.locale}),
            method: 'GET',
            success: function(response) {

                var response = (response[0] === '{' || response[0] === '[') ? JSON.parse(response) : response;
                if (response.success === undefined)
                {
                    control.disabled = false;
                    $(response).appendTo(barContent);
                }
                else {
                    control.disabled = true;
                }

                update();
                uploadfile_link_click();
            }
        });
        //       map.on('zoomend', update);

        //  update();

        function toggle(e) {
            e.stopPropagation();
            e.preventDefault();
            if (!link.hasClass('disabled')) {
                options.sidebar.togglePane($ui, link);
            }
            $('.leaflet-control .control-button').tooltip('hide');
        }

        function update() {
            var disabled = false;//map.getZoom() < 12;
            link
                    .toggleClass('disabled', control.disabled)
                    .attr('data-original-title', I18n.t(control.disabled ?
                            'javascripts.site.uploadfile_disabled_tooltip' :
                            'javascripts.site.uploadfile_tooltip'));


        }
        function uploadfile_link_click() {
            $("div.uploadfile_link > a.uploadfile").click(function() {
                var _this = this;
                if ($(this).attr("id") !== null && $(this).attr("id") !== '' && $(this).attr("id") !== undefined)
                {
                    var spinner = new Spinner();

                    var spinner_target = document.getElementById('leafmap');

                    var url = "default_upload" + $(this).attr("id");
                    $.ajax({
                        url: Routing.generate(url,{'_locale':  window.locale}),
                        type: 'GET',
                        beforeSend: function() {
                            //       spinner.spin(spinner_target);
                        },
                        complete: function() {
                            //      spinner.stop();
                        },
                        //Ajax events
                        success: completeHandler = function(response) {
                            //  alert(response);
                            $(".uploadfile-ui .sidebar_heading h4").html($(_this).attr("title"));
                            var result = $('<div/>').html(response).contents();
                            //   alert(result.find('div.uploadfile_link').parent().html());
                            $('div.uploadfile_block').html(result.find('div.uploadfile_block').html());

                        },
                        error: errorHandler = function() {
                            //     spinner.stop();
                        }//,
                        // Form data
                        // data: {id: shapefile_id}
                    });
                }
            });
        }

        return $container[0];
    };

    return control;
};

L.MAP2U.uploadfile_list = function(options) {
    var control = L.control(options);

    control.onAdd = function(map) {
        var $container = $('<div>')
                .attr('class', 'control-uploadfile');

        var link = $('<a>')
                .attr('class', 'control-button')
                .attr('href', '#')
                .html('<span class="icon uploadfile-list"></span>')
                .on('click', toggle)
                .appendTo($container);

        var $ui = $('<div>')
                .attr('class', 'uploadfile-list-ui');

        $('<div>')
                .attr('class', 'sidebar_heading')
                .appendTo($ui)
                .append(
                        $('<h4>')
                        .text(I18n.t('javascripts.uploadfile-list.title')));
        var barContent = $('<div>')
                .attr('class', 'sidebar_content')
                .appendTo($ui);

        var $section = $('<div>')
                .attr('class', 'section')
                .appendTo(barContent);

        list = $('<ul>')
                .appendTo($section);

        options.sidebar.addPane($ui);
        jQuery(window).resize(function() {
            barContent.height($('.leaflet-sidebar.right').height() - 70);
        });
        
        $.ajax({
            url: Routing.generate('default_uploadfilelistform',{_locale:I18n.locale}),
            method: 'GET',
           
            success: function(response) {
                
             var response = (response[0] === '{' || response[0] === '[') ? JSON.parse(response) : response;
                if(response.success===undefined)
                {
                    control.disabled=false;
                    $(response).appendTo(barContent);
                }
                else {
                     control.disabled=true;
                }
                
                update();
            }
        });
        //       map.on('zoomend', update);

      //  update();

        function toggle(e) {
            e.stopPropagation();
            e.preventDefault();
            if (!link.hasClass('disabled')) {
                options.sidebar.togglePane($ui, link);
            }
            $('.leaflet-control .control-button').tooltip('hide');
        }

        function update() {
            var disabled = false;//map.getZoom() < 12;
            link
                    .toggleClass('disabled', control.disabled)
                    .attr('data-original-title', I18n.t(control.disabled ?
                            'javascripts.site.uploadfile_list_disabled_tooltip' :
                            'javascripts.site.uploadfile_list_tooltip'));
        }

        return $container[0];
    };
    return control;
};


L.MAP2U.Zoom = L.Control.extend({
	options: {
		position: 'topright'
	},

	onAdd: function (map) {
		var zoomName = 'zoom',
		    container = L.DomUtil.create('div', zoomName);

		this._map = map;


		this._zoomInButton  = this._createButton(
		        '', I18n.t('javascripts.map.zoom.in'),  zoomName + 'in',  container, this._zoomIn,  this);
		this._zoomOutButton = this._createButton(
		        '', I18n.t('javascripts.map.zoom.out'), zoomName + 'out', container, this._zoomOut, this);

		map.on('zoomend zoomlevelschange', this._updateDisabled, this);

		return container;
	},

	onRemove: function (map) {
		map.off('zoomend zoomlevelschange', this._updateDisabled, this);
	},

	_zoomIn: function (e) {
		this._map.zoomIn(e.shiftKey ? 3 : 1);
	},

	_zoomOut: function (e) {
		this._map.zoomOut(e.shiftKey ? 3 : 1);
	},

	_createButton: function (html, title, className, container, fn, context) {
            
		var link = L.DomUtil.create('a', 'control-button ' + className, container);
		link.innerHTML = html;
		link.href = '#';
		link.title = title;

		var sprite = L.DomUtil.create('span', 'icon ' + className, link);

		var stop = L.DomEvent.stopPropagation;

		L.DomEvent
		    .on(link, 'click', stop)
		    .on(link, 'mousedown', stop)
		    .on(link, 'dblclick', stop)
		    .on(link, 'click', L.DomEvent.preventDefault)
		    .on(link, 'click', fn, context);

		return link;
	},

	_updateDisabled: function () {
		var map = this._map,
			className = 'leaflet-disabled';

		L.DomUtil.removeClass(this._zoomInButton, className);
		L.DomUtil.removeClass(this._zoomOutButton, className);

		if (map._zoom === map.getMinZoom()) {
			L.DomUtil.addClass(this._zoomOutButton, className);
		}
		if (map._zoom === map.getMaxZoom()) {
			L.DomUtil.addClass(this._zoomInButton, className);
		}
	}
});

L.MAP2U.zoom = function (options) {
	return new L.MAP2U.Zoom(options);
};

/* 
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */



OSM.SERVER_URL="localhost:8001/app.php"

window.onload = function () {
    var map;
    var leafletmap_tooltip;
    var layersControl;
    var leftSidebar;
    var historyControl;
    var printProvider,
            printControl;
alert(window.location.hash);
//    var mapapp;
//    var canvas;
//    var context;
//    var path;

    $(".navbar.navbar-fixed-top").resize(function () {
        // alert("qqq=" + $(".navbar.navbar-fixed-top").height());
        $("body.sonata-bc").css('top', $(".navbar.navbar-fixed-top").height());
    });

    $('#leafmap').height($(window).height() - 126);





    $(window).resize(function () { /* do something */

        $('#leafmap').height($(window).height() - 126);
//        $('#leafmap').css('height',$('#leafmap').height());
//        $('#leafmap').css('width',$('#leafmap').width());
        $('#map-ui').height($(window).height() - 126);
        // $('.leaflet-sidebar #sidebar-left').height($(window).height() - 146);
    });
    map = new L.MAP2U.Map('leafmap', {
        'zoomControl': false
    }).setView([43.73737, -79.95987], 10);

    this.map = map;


//canvas = d3.select(map.getPanes().overlayPane).append("canvas")
//    .attr("width", $('#leafmap').width())
//    .attr("height", $('#leafmap').height());
//
// context = canvas.node().getContext("2d");
//
// path = d3.geo.path()
//    .projection(simplify)
//    .context(context);

    //add a tile layer to add to our map, in this case it's the 'standard' OpenStreetMap.org tile server
    var mapnik = L.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '© <a href="http://openstreetmap.org">OpenStreetMap</a> contributors',
        maxZoom: 18
    });

    var googleLayer_satellite = new L.Google('SATELLITE', {attribution: ""});
    var googleLayer_roadmap = new L.Google('ROADMAP', {attribution: ""});
    var googleLayer_hybrid = new L.Google('HYBRID', {attribution: ""});
    var googleLayer_terrain = new L.Google('TERRAIN', {attribution: ""});
    var bingkey = 'Ahxau5mtl944aCyAb8tfmrLebWENWZDXEmMIQWRaRQjTho2U0NkHqAUpcT1nTW1v';
    var BingAttribution = '';
    //  var bing = new L.BingLayer("AqTGBsziZHIJYYxgivLBf0hVdrAk9mWO5cQcb8Yux8sW5M8c8opEC2lZqKR1ZZXf", {type: 'Road'});

    //   map.addLayer(bing);

    var Thunderforest_Transport = L.tileLayer('http://{s}.tile2.opencyclemap.org/transport/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="http://www.opencyclemap.org">OpenCycleMap</a>, &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>'
    });

//    var tiles = new L.TileLayer.Canvas();
//
//    map.addLayer(tiles);

//
//var BingRoad = new L.TileLayer.Bing(bingkey, "Road",
//                    {
//                        maxZoom: 21,
//                        attribution: BingAttribution
//                    });
//
//            var BingAerial = new L.TileLayer.Bing(bingkey, "Aerial",
//                    {
//                        maxZoom: 21,
//                        attribution: BingAttribution
//                    });
//
//            var BingAerialWithLabels = new L.TileLayer.Bing(bingkey, "AerialWithLabels",
//                    {
//                        maxZoom: 21,
//                        attribution: BingAttribution
//                    });
//
//    var baseMaps = {
//                "BingRoads": BingRoad,
//                "BingAerial": BingAerial,
//                "BingAerialWithLabels": BingAerialWithLabels
//            };

//    var bing = new L.BingLayer('');
//    map.addLayer(bing);
//    
    var mapnik_minimap = L.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '© <a href="http://openstreetmap.org">OpenStreetMap</a> contributors',
        maxZoom: 18
    });
    var miniMap = new L.Control.MiniMap(mapnik_minimap, {position: 'bottomright', width: 150, height: 150, zoomLevelOffset: -4, zoomAnimation: false, toggleDisplay: true, autoToggleDisplay: false}).addTo(map);

    map.addLayer(mapnik);

    var subwatersheds = new L.TileLayer.WMS(
            "http://cobas.juturna.ca:8080/geoserver/juturna/wms",
            {
                layers: 'juturna:cvcsubwatersheds',
                format: 'image/png',
                transparent: true,
                srs: 'EPSG:4326',
                attribution: ""
            });

    //   map.addLayer(subwatersheds);

    map.baseLayers = [
        {'layer': mapnik, 'layerName': 'Open Street Map'},
        {'layer': Thunderforest_Transport, 'layerName': 'Thunderforest_Transport'},
        //       {'layer': bing, 'name': 'Bing'},
        {'layer': googleLayer_roadmap, 'layerName': 'Google Road Map'},
        {'layer': new L.Google('SATELLITE'), 'layerName': 'Google Satellite'},
        {'layer': new L.Google('HYBRID'), 'layerName': 'Google Hybrid'},
        {'layer': new L.Google('TERRAIN'), 'layerName': 'Google Terrain'}

    ];
    map.noteLayer = new L.FeatureGroup();
    map.noteLayer.options = {code: 'N'};
    //   map.dataLayers = //{'layer':creditriverparks, name:'Credit River Parks'}, {'layer':conservationareas, name:'Conservation'}, {'layer': subwatersheds, 'name': 'Subwatersheds'},
    //          [{'layer': subwatersheds, 'name': 'Subwatersheds'}];




    map.dataLayers = [];

    var index;
    var layers = [];
//
//
//var testlayer = new L.TileLayer.WMS(
//            "http://www.sig.mep.go.cr:8080/geoserver/mep/wms",
//            {
//                layers: 'CINDEA',
//                format: 'image/png',
//                transparent: true,
//                attribution: ""
//            });
//       testlayer.addTo(map);
//
//var testlayer2 = new L.TileLayer.WMS(
//            "http://www.sig.mep.go.cr:8080/geoserver/mep/wms",
//            {
//                layers: 'Escuelas_Nocturnas',
//                format: 'image/png',
//                transparent: true,
//                attribution: ""
//            });
//       testlayer2.addTo(map);

//       
//    

    // Create the print provider, subscribing to print events
    printProvider = L.print.provider({
        //    capabilities: printConfig,
        method: 'POST',
        dpi: 254,
        outputFormat: 'pdf',
        customParams: {
            mapTitle: 'Print Test',
            comment: 'Testing Leaflet printing'
        }
    });

    // Create a print control with the configured provider and add to the map
    printControl = L.control.print({
        provider: printProvider
    });

    map.addControl(printControl);


    var leftsidebarControl = L.Control.extend({
        options: {
            position: 'topleft'

        },
        onAdd: function (map) {
            // create the control container with a particular class name
            var container = L.DomUtil.create('div', 'leftsidebar-control');
            L.DomEvent
                    .addListener(container, 'click', L.DomEvent.stopPropagation)
                    .addListener(container, 'click', L.DomEvent.preventDefault)
                    .addListener(container, 'click', function () {
                        ShowLeftSideBar(leftSidebar);
                    });
            var controlUI = L.DomUtil.create('div', 'leftsidebar-close-control hidden noprint', container);
            controlUI.title = 'Show Left Side Bar';
            return container;
        }
    });

    map.addControl(new leftsidebarControl());
//var history = new L.HistoryControl().addTo(map);
    historyControl = new L.HistoryControl({position: 'topleft', useExternalControls: true});
    map.addControl(historyControl);

    this.historyControl = historyControl;
    historyControl.addTo(map);
    $(".leaflet-control-minimap").addClass("noprint");


//    var MapToolbarControl = L.Control.extend({
//        options: {
//            position: 'topright'
//
//        },
//        onAdd: function(map) {
//            // create the control container with a particular class name
//            var container = L.DomUtil.create('div', 'maptoolbar-control');
////            L.DomEvent
////                    .addListener(container, 'click', L.DomEvent.stopPropagation)
////                    .addListener(container, 'click', L.DomEvent.preventDefault)
////                    .addListener(container, 'click', function() {
////                        MapExtentReset(map);
////                    });
//            var controlUI = L.DomUtil.create('div', 'maptoolbar-control-reset', container);
//            L.DomEvent
//                    .addListener(controlUI, 'click', L.DomEvent.stopPropagation)
//                    .addListener(controlUI, 'click', L.DomEvent.preventDefault)
//                    .addListener(controlUI, 'click', function() {
//                        MapExtentReset(map);
//                    });
//            controlUI.title = I18n.t('Reset Map Extent');
//            var Prev_Extent = L.DomUtil.create('div', 'maptoolbar-control-prev', container);
//            
//           
//            L.DomEvent
//                    .addListener(Prev_Extent, 'click', L.DomEvent.stopPropagation)
//                    .addListener(Prev_Extent, 'click', L.DomEvent.preventDefault)
//                    .addListener(Prev_Extent, 'click', function() {
//                       // PrevMapExtent(map);
//                              historyControl.goBack();
//                    });
//            Prev_Extent.title = I18n.t('Prev Map Extent');
//            var Next_Extent = L.DomUtil.create('div', 'maptoolbar-control-next', container);
//            L.DomEvent
//                    .addListener(Next_Extent, 'click', L.DomEvent.stopPropagation)
//                    .addListener(Next_Extent, 'click', L.DomEvent.preventDefault)
//                    .addListener(Next_Extent, 'click', function() {
//                     //   NextMapExtent(map);
//                              historyControl.goForward();
//                    });
//            Next_Extent.title = I18n.t('Next Map Extent');
//            return container;
//        }
//    });
//
//    map.addControl(new MapToolbarControl());


//    var popup = L.popup();
//
//    function onMapClick(e) {
//        popup
//                .setLatLng(e.latlng)
//                .setContent("You clicked the map at " + e.latlng.toString())
//                .openOn(map);
//    }
//
//    map.on('click', onMapClick);

    var position = $('html').attr('dir') === 'rtl' ? 'topleft' : 'topright';
    //  L.MAP2U.zoom({position: position}).addTo(map);

    var lc = L.control.locate({
        position: position,
        strings: {
            title: I18n.t('javascripts.map.locate.title'),
            popup: I18n.t('javascripts.map.locate.popup')
        }
    }).addTo(map);

    L.control.scale().addTo(map);
    this.lc = lc;

    mouseposition = L.control.mousePosition({'emptyString': '', 'position': 'bottomleft'}).addTo(map);

    leafletmap_tooltip = d3.select("#leafmap").append("div").attr("class", "leafmap_title_tooltip hidden");
    //  var map_tooltip = d3.select("#leafmap").append("div").attr("class", "leafmap_title_tooltip hidden");

    leftSidebar = L.control.sidebar('sidebar-left', {
        position: 'left'
    });
    map.addControl(leftSidebar);
    this.leftSidebar = leftSidebar;
    var rightSidebar = L.control.sidebar('sidebar-right', {
        position: 'right'
    });
    map.addControl(rightSidebar);

    this.rightSidebar = rightSidebar;

    layersControl = L.MAP2U.layers({
        position: position,
        map: map,
        map_tooltip: leafletmap_tooltip,
        layers: map.baseLayers,
        sidebar: rightSidebar
    });
    layersControl.addTo(map);
    this.layersControl = layersControl;

//    var mapToolbarControl = L.MAP2U.maptoolbar({
//        position: position,
//        map: map
//    });
//    mapToolbarControl.addTo(map);
//    this.mapToolbarControl = mapToolbarControl;


    L.MAP2U.uploadfile({position: position,
        sidebar: rightSidebar,
        'short': true
    }).addTo(map);

    L.MAP2U.uploadfile_list({position: position,
        sidebar: rightSidebar,
        'short': true
    }).addTo(map);
  L.MAP2U.business({position: position,
        sidebar: rightSidebar,
        'short': true
    }).addTo(map);
    L.MAP2U.graphchart({
        position: position,
        sidebar: rightSidebar,
        'short': true
    }).addTo(map);
    L.MAP2U.share({
        position: position,
        sidebar: rightSidebar,
        'short': true
    }).addTo(map);


    L.MAP2U.note({
        position: position,
        sidebar: rightSidebar
    }).addTo(map);


    setTimeout(function () {
        leftSidebar.toggle();
    }, 500);

// if close left sidebar, then show sidebar controller icon
    $(".sonata-bc div.leaflet-sidebar.left a.close").click(function () {
        if ($(".leaflet-sidebar.left").css('left') === 0 || $(".leaflet-sidebar.left").css('left') === '0px') {
            $(".sonata-bc .leftsidebar-close-control").removeClass("hidden");
            $(".sonata-bc .leftsidebar-close-control").show();
        } else {

            $(".sonata-bc .leftsidebar-close-control").hide();
        }
    });



    $.ajax({
        url: Routing.generate('leaflet_userlayers', {'_locale': window.locale}),
        method: 'GET',
        beforeSend: function () {
            map.spin(true);
        },
        complete: function () {
            map.spin(false);
        },
        error: function () {
            map.spin(false);
        },
        success: function (response) {
            var result;
            if (typeof response !== 'object')
                result = JSON.parse(response);
            else
                result = response;

            //  alert(result.success===true);
            if (result.success === true && result.layers) {

                //    alert(JSON.stringify(result.layers));
                // alert(result.layers.length);

                var keys = Object.keys(result.layers).map(function (k) {

                    return k;
                });

                // alert(keys.length + "," + keys[0]);

                for (var k = 0; k < keys.length; k++)
                {
                    var layer = result.layers[keys[k]];
                    map.dataLayers[map.dataLayers.length] = {'map': map, 'layerType': layer.layerType, 'clusterLayer': layer.clusterLayer, 'defaultShowOnMap': layer.defaultShowOnMap, 'layer': null, 'minZoom': layer.minZoom, 'maxZoom': layer.maxZoom, 'index_id': k, 'srs': layer.srs, 'layerId': layer.id, layerTitle: layer.layerTitle, 'datasource': layer.datasource, 'sld': layer.sld, 'filename': layer.filename, 'layerName': layer.layerName, 'hostName': layer.hostName};
                }
                map.dataLayers[map.dataLayers.length] = {'map': map, 'layerType': 'userdraw', 'layer': null, 'index_id': -1, 'layerId': -1, layerTitle: "My draw geometries", 'filename': 'userdraw', 'layerName': 'My draw geometries', 'filename':'userdraw', type: 'geojson'};
            }
            else
                map.dataLayers[map.dataLayers.length] = {'map': map, 'layerType': 'userdraw', 'layer': null, 'index_id': -1, 'layerId': -1, layerTitle: "My draw geometries", 'filename': 'userdraw', 'layerName': 'My draw geometries', 'filename':'userdraw', type: 'geojson'};
            layersControl.refreshOverlays();
        }
    });



    $(window).resize();
    $(".navbar.navbar-fixed-top").resize();


    initMapDraw(map);
    maptoolbar_init(this);
    // control map_draw_select_pane defined in base.html.twig
    $(".sonata-bc div.close_map_draw_select_pane_button").click(function () {
        $(".sonata-bc div#map_draw_select_pane").hide();
    });
    $('.sonata-bc div#map_draw_select_pane').draggable({handle: '.header'});


    $(".sonata-bc div#map_draw_select_pane").on("drag", function (event, ui) {
        if (ui.position.left < 1)
            ui.position.left = 1;
        if (ui.position.top < 1)
            ui.position.top = 1;
        if ($(window).width() < ($(this).width() + ui.position.left + 5))
            ui.position.left = $(window).width() - $(this).width() - 5;
        if ((ui.position.top + $(this).height()) > ($(window).height() - 5))
            ui.position.top = $(window).height() - 5 - $(this).height();

        //  $("#mapping_system_status_id").html(ui.position.top + " , " + ui.position.left + "  ,  " + $(window).height() + "  ,  " + $(window).width() + "margin-bottom:" + $(this).css("margin-bottom"));
    });


//    $.ajax({
//        url: Routing.generate("default_heatmap_gradientform"),
//        method: 'GET',
//        success: function(html) {
//            $(".sidebar_feature_content").html(html);
//            heatmap_gradient_minicolors();
//            heatmap_gradient_submit()
//        }
//    });
    //   layersControl.createHeatMapLayer();
    $(".search_form").on("submit", function (e) {
        e.preventDefault();
//    $("header").addClass("closed");
        var query = $(this).find("input[name=query]").val();
        if (query !== undefined && query.trim() !== '') {
            var coordinate = query.split(",");

            if (coordinate.length === 2 && $.isNumeric(coordinate[0]) && $.isNumeric(coordinate[1]))
            {
                createSearchIcon(map, {lat: coordinate[0], lng: coordinate[1]});
                return;
            }
            var geocoder = new google.maps.Geocoder();
            geocoder.geocode({'address': query}, function (results, status) {


                if (status === google.maps.GeocoderStatus.OK)
                {
                    var pt = results[0].geometry.location;
                    var layers = map.drawnItems.getLayers();
                    for (var i = layers.length - 1; i >= 0; i--) {
                        if (layers[i].source !== undefined && layers[i].source === 'searchbox_query') {
                            map.drawnItems.removeLayer(layers[i]);
                        }
                    }

                    var feature = L.marker([pt.lat(), pt.lng()]);
                    feature.bindLabel(results[0].formatted_address);
                    feature.id = 0;
                    feature.name = results[0].formatted_address;
                    feature.index = map.drawnItems.getLayers().length;
                    feature.type = 'marker';
                    feature.source = 'searchbox_query';
                    feature.on('click', function (e) {

                        if (map.drawControl._toolbars.edit._activeMode === null) {



                        }
                        else if (map.drawControl._toolbars.edit._activeMode && map.drawControl._toolbars.edit._activeMode.handler.type === 'edit') {

                            var radius = 0;

                            $.ajax({
                                url: Routing.generate('draw_' + e.target.type, {'_locale': window.locale}),
                                method: 'GET',
                                data: {
                                    id: e.target.id,
                                    name: e.target.name,
                                    radius: radius,
                                    index: e.target.index
                                },
                                success: function (response) {
                                    if ($('body.sonata-bc #ajax-dialog').length === 0) {
                                        $('<div class="modal fade" id="ajax-dialog" role="dialog"></div>').appendTo('body');
                                    } else {
                                        $('body.sonata-bc #ajax-dialog').html('');
                                    }

                                    $(response).appendTo($('body.sonata-bc #ajax-dialog'));
                                    $('#ajax-dialog').modal({show: true});
                                    $('#ajax-dialog').draggable();
                                    //  alert(JSON.stringify(html));
                                }
                            });
                        }
                        ;


                    });

                    map.drawnItems.addLayer(feature);
                    if (pt !== undefined && pt.lat !== undefined && pt.lng !== undefined)
                        //      map.panTo(new L.LatLng(pt.lat(), pt.lng()));
                        map.setView(new L.LatLng(pt.lat(), pt.lng()), 14);

                }
                ;

            });
        } else {
            alert("search can not be empty!");
//      OSM.router.route("/" + OSM.formatHash(map));
        }
    });
    $(".sonata-bc .describe_location").on("click", function (e) {

        e.preventDefault();
//            alert(" map center=" + map.getCenter().lat + "  " + map.getCenter().lng);

        var HOST_URL = 'http://open.mapquestapi.com';
        var SAMPLE_POST = HOST_URL + '/nominatim/v1/search.php?format=json';
        var searchType = '';
        var safe = SAMPLE_POST + "&q=" + map.getCenter().lat + "," + map.getCenter().lng;//westminster+abbey";
//            alert(safe);
        $.ajax({
            url: safe,
            method: 'GET',
//                data: {
//                  zoom: map.getZoom(),
//                  minlon: map.getBounds().getWest(),
//                  minlat: map.getBounds().getSouth(),
//                  maxlon: map.getBounds().getEast(),
//                  maxlat: map.getBounds().getNorth()
//                },
            success: function (html) {
                alert(html[0].display_name)
                //  alert(JSON.stringify(html));
            }
        });




    });
    $('.leaflet-control .control-button').tooltip({placement: 'left', container: 'body'});
//    L.MarkerClusterGroup.prototype.bringToFront = function() {
//        var pane = this._map._panes.overlayPane;
//
//        if (this._container) {
//            pane.appendChild(this._container);
//            this._setAutoZIndex(pane, Math.max);
//        }
//
//        return this;
//    };

};

function createSearchIcon(map, opt) {

    var layers = map.drawnItems.getLayers();
    for (var i = layers.length - 1; i >= 0; i--) {
        if (layers[i].source !== undefined && layers[i].source === 'searchbox_query') {
            map.drawnItems.removeLayer(layers[i]);
        }
    }

    var feature = L.marker([opt.lat, opt.lng]);
    feature.bindLabel(opt.lat + "," + opt.lng);
    feature.id = 0;
    feature.name = "Searched Icon";
    feature.index = map.drawnItems.getLayers().length;
    feature.type = 'marker';
    feature.source = 'searchbox_query';
    feature.on('click', function (e) {
        if (map.drawControl._toolbars.edit._activeMode === null) {



        }
        else if (map.drawControl._toolbars.edit._activeMode && map.drawControl._toolbars.edit._activeMode.handler.type === 'edit') {

            var radius = 0;

            $.ajax({
                url: Routing.generate('draw_' + e.target.type, {'_locale': window.locale}),
                method: 'GET',
                data: {
                    id: e.target.id,
                    name: e.target.name,
                    radius: radius,
                    index: e.target.index
                },
                success: function (response) {
                    if ($('body.sonata-bc #ajax-dialog').length === 0) {
                        $('<div class="modal fade" id="ajax-dialog" role="dialog"></div>').appendTo('body');
                    } else {
                        $('body.sonata-bc #ajax-dialog').html('');
                    }
                    $(response).appendTo($('body.sonata-bc #ajax-dialog'));
                    $('#ajax-dialog').modal({show: true});
                    $('#ajax-dialog').draggable();
                    //  alert(JSON.stringify(html));
                }
            });
        }
        ;
    });

    map.drawnItems.addLayer(feature);

}

function saveuserdraw() {
    for (var i = 0; i < map.drawlayer._originalPoints.length; i++) {
        //  layer._originalPoints.each(function(point) {
        alert(map.drawlayer._originalPoints[i]);
        var position = map.containerPointToLatLng(layer._originalPoints[i]);
        alert("Lat, Lon : " + position.lng.toFixed(3) + "," + position.lat.toFixed(3));
    }
}


function ShowLeftSideBar(leftSidebar) {
    if ($(".leaflet-sidebar.left").css('left') === 0 || $(".leaflet-sidebar.left").css('left') === '0px') {

        $(".sonata-bc .leftsidebar-close-control").show();
        setTimeout(function () {
            leftSidebar.hide();
        }, 500);
    } else {

        $(".sonata-bc .leftsidebar-close-control").hide();
        setTimeout(function () {
            $('#sidebar-left #sidebar_content').css('visibility', 'visible');
            leftSidebar.show();
        }, 500);
    }
}

/* 
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

function initMapDraw(map) {
    var drawnItems = new L.FeatureGroup();
    $(drawnItems).attr({"id": 'user_draw_features'});

    map.addLayer(drawnItems);
    map.drawnItems = drawnItems;
    var drawControl = new L.Control.Draw({
        position: 'topleft',
        draw: {
            rectangle: {
                shapeOptions: {
                    color: '#0000FF',
                    weight: 3
                }
            },
            polyline: {
                shapeOptions: {
                    color: '#0000FF',
                    weight: 3
                }
            },
            polygon: {
                shapeOptions: {
                    color: '#0000FF',
                    weight: 3
                },
                allowIntersection: false
            },
            circle: {
                shapeOptions: {
                    color: '#0000FF',
                    weight: 3
                }
            }
        },
        edit: {
            featureGroup: drawnItems
        }
    });

    map.drawControl = drawControl;
    map.addControl(drawControl);

    map.on('draw:created', function (e) {
        var type = e.layerType,
                layer = e.layer;
        layer.id = 0;
        layer.type = type;
        var radius = 0;
        drawnItems.addLayer(layer);
        layer.index = drawnItems.getLayers().length - 1;

        if (type === 'circle')
        {
            radius = layer._mRadius.toFixed(0);
        }

        //   alert(JSON.stringify(layer.toGeoJSON()));
        layer.on('click', function (e) {
            alert(this.id);
            var feature = e.target;
            if (map.drawControl._toolbars.edit._activeMode === null) {
                var highlight = {
                    'color': '#333333',
                    'weight': 2,
                    'opacity': 1
                };
                if (feature.selected === false || feature.selected === undefined) {
                    if (feature.setStyle)
                        feature.setStyle(highlight);
                    feature.selected = true;
                    if (document.getElementById('geometries_selected')) {
                        var selectBoxOption = document.createElement("option");//create new option 
                        selectBoxOption.value = feature.id;//set option value 
                        selectBoxOption.text = feature.name;//set option display text 
                        document.getElementById('geometries_selected').add(selectBoxOption, null);
                    }
                }
                else
                {
                    if (feature.setStyle)
                        feature.setStyle({'color': "blue", 'weight': 5, 'opacity': 0.6});
                    feature.selected = false;
                    $("#geometries_selected option[value='" + feature.id + "']").each(function () {
                        $(this).remove();
                    });
                }













            }
            else if (map.drawControl._toolbars.edit._activeMode && map.drawControl._toolbars.edit._activeMode.handler.type === 'edit') {

                var radius = 0;
                if (e.target.type === 'circle')
                {
                    radius = e.target._mRadius;
                }
                $.ajax({
                    url: Routing.generate('draw_' + e.target.type, {'_locale': window.locale}),
                    method: 'GET',
                    data: {
                        id: e.target.id,
                        name: e.target.name,
                        radius: radius,
                        index: e.target.index
                    },
                    success: function (response) {



                        if ($('body.sonata-bc #ajax-dialog').length === 0) {
                            $('<div class="modal fade" id="ajax-dialog" role="dialog"></div>').appendTo('body');
                        } else {
                            $('body.sonata-bc #ajax-dialog').html('');
                        }

                        $(response).appendTo($('body.sonata-bc #ajax-dialog'));
                        $('#ajax-dialog').modal({show: true});
                        $('#ajax-dialog').draggable();
                        //  alert(JSON.stringify(html));
                    }
                });
            }
            ;
        });


        if ($('body.sonata-bc #ajax-dialog').length === 0) {


            $('<div class="modal fade" id="ajax-dialog" z-index="-1" data-backdrop="false" data-backdrop="static" data-keyboard="false" role="dialog"></div>').appendTo('body');
        } else {
            $('body.sonata-bc #ajax-dialog').html('');
        }



        $.ajax({
            url: Routing.generate('draw_' + layer.type, {'_locale': window.locale}),
            method: 'GET',
            data: {
                id: 0,
                name: layer.name,
                radius: radius,
                index: layer.index
            },
            success: function (response) {
                $(response).appendTo($('body.sonata-bc #ajax-dialog'));

                $('body.sonata-bc #ajax-dialog').modal('show');
                $('body.sonata-bc #ajax-dialog').draggable();
                //  alert(JSON.stringify(html));
            }
        });

        $('body.sonata-bc #ajax-dialog').on('hidden.bs.modal', function (e) {
            // do something...
            //   alert(drawnItems.getLayers()[drawnItems.getLayers().length - 1].id);

            if (drawnItems.getLayers()[drawnItems.getLayers().length - 1].id === 0)
            {
                drawnItems.removeLayer(drawnItems.getLayers()[drawnItems.getLayers().length - 1]);
            }
            $('body.sonata-bc #ajax-dialog').remove();
        });


        $('#ajax-dialog').on('hide.bs.modal', function (e) {

        });
        if (type === 'marker') {
            // Do marker specific actions
        }
//var item=drawnItems.getLayers();
//var itemgeojson=item[0].toGeoJSON();
//itemgeojson.properties.id=layer.id;
//itemgeojson.properties.name=layer.name;
//alert(layer._mRadius);
//
//alert(JSON.stringify(itemgeojson));
//alert(JSON.stringify(layer));
        // Do whatever else you need to. (save to db, add to map etc)
        // map.addLayer(layer);
    });

    map.on('draw:drawstop', function (e) {

        $(".sonata-bc div#map_draw_select_pane").hide();

    });
    map.on('draw:editstop', function (e) {

        $(".sonata-bc div#map_draw_select_pane").hide();

    });
    map.on('draw:edited', function (e) {
        var layers = e.layers;

        layers.eachLayer(function (layer) {
            if (confirm("Modify my draw geometry id:" + layer.id + ",name:" + layer.name + "?"))
            {

                var itemgeojson = layer.toGeoJSON();
                var radius = 0;
                if (layer._mRadius !== undefined)
                    radius = layer._mRadius;
                $.ajax({
                    url: Routing.generate('draw_save', {'_locale': window.locale}),
                    method: 'POST',
                    data: {
                        id: layer.id,
                        name: layer.name,
                        feature: itemgeojson,
                        type: layer.type,
                        radius: radius
                    },
                    success: function (response) {
                        var results = JSON.parse(response);
                        if (results.success === false)
                            alert(results.message);
                        else {
                            //    alert("Geometry has been successfully updated!");
                        }
                    }
                });
            }
        });
    });

    map.on('draw:deleted', function (e) {
        var layers = e.layers;
        layers.eachLayer(function (layer) {
            if (layer.name === 'Searched Icon' && layer.id === 0 && layer.source === 'searchbox_query') {
                drawnItems.removeLayer(layer);
            } else {
                if (confirm("Delete my draw item id:" + layer.id + ",name:" + layer.name + "?"))
                {

                    $.ajax({
                        url: Routing.generate('draw_delete', {'_locale': window.locale}),
                        method: 'POST',
                        data: {
                            id: layer.id
                        },
                        success: function (response) {
                            var result = JSON.parse(response);
                            if (result.success === true) {

                                $("#geometries_select option[value='" + layer.id + "']").each(function () {
                                    $(this).remove();
                                });
                                $("#geometries_selected option[value='" + layer.id + "']").each(function () {
                                    $(this).remove();
                                });
                            }
                            else
                                alert(result.message);
                            //  alert(JSON.stringify(html));
                        }
                    });
                }
            }
        });

    });

}

//= require ohauth

$(document).ready(function () {
  function makeAbsolute(url) {
    var a = document.createElement('a');
    a.href = url;
    return a.href;
  }

  if (OSM.oauth_token) {
    var headerGenerator = window.ohauth.headerGenerator({
      consumer_key: OSM.oauth_consumer_key,
      consumer_secret: OSM.oauth_consumer_secret,
      token: OSM.oauth_token,
      token_secret: OSM.oauth_token_secret
    });

    $.ajaxPrefilter(function(options, jqxhr) {
      if (options.oauth) {
        options.headers = options.headers || {};
        options.headers.Authorization = headerGenerator(options.type, makeAbsolute(options.url), jqxhr.data);
      }
    });
  }
});

/* 
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

OSM = {
//<% if defined?(PIWIK) %>
//  PIWIK:                 <%= PIWIK.to_json %>,
//<% end %>

//  MAX_REQUEST_AREA:      <%= MAX_REQUEST_AREA.to_json %>,
//  SERVER_URL:            <%= SERVER_URL.to_json %>,
//  API_VERSION:           <%= API_VERSION.to_json %>,
//  STATUS:                <%= STATUS.to_json %>,
//  MAX_NOTE_REQUEST_AREA: <%= MAX_NOTE_REQUEST_AREA.to_json %>,

  apiUrl: function (object) {
    var url = "/api/" + OSM.API_VERSION + "/" + object.type + "/" + object.id;

    if (object.type === "way" || object.type === "relation") {
      url += "/full";
    } else if (object.version) {
      url += "/" + object.version;
    }

    return url;
  },

  params: function(search) {
    var params = {};

    search = (search || window.location.search).replace('?', '').split(/&|;/);

    for (var i = 0; i < search.length; ++i) {
      var pair = search[i],
        j = pair.indexOf('='),
        key = pair.slice(0, j),
        val = pair.slice(++j);
      params[key] = decodeURIComponent(val);
    }

    return params;
  },

  mapParams: function (search) {
    var params = OSM.params(search), mapParams = {}, loc, match;

    if (params.mlon && params.mlat) {
      mapParams.marker = true;
      mapParams.mlon = parseFloat(params.mlon);
      mapParams.mlat = parseFloat(params.mlat);
    }

    // Old-style object parameters; still in use for edit links e.g. /edit?way=1234
    if (params.node) {
      mapParams.object = {type: 'node', id: parseInt(params.node)};
    } else if (params.way) {
      mapParams.object = {type: 'way', id: parseInt(params.way)};
    } else if (params.relation) {
      mapParams.object = {type: 'relation', id: parseInt(params.relation)};
    }

    var hash = OSM.parseHash(location.hash);

    // Decide on a map starting position. Various ways of doing this.
    if (hash.center) {
      mapParams.lon = hash.center.lng;
      mapParams.lat = hash.center.lat;
      mapParams.zoom = hash.zoom;
    } else if (params.bbox) {
      var bbox = params.bbox.split(',');
      mapParams.bounds = L.latLngBounds(
        [parseFloat(bbox[1]), parseFloat(bbox[0])],
        [parseFloat(bbox[3]), parseFloat(bbox[2])]);
    } else if (params.minlon && params.minlat && params.maxlon && params.maxlat) {
      mapParams.bounds = L.latLngBounds(
        [parseFloat(params.minlat), parseFloat(params.minlon)],
        [parseFloat(params.maxlat), parseFloat(params.maxlon)]);
    } else if (params.lon && params.lat) {
      mapParams.lon = parseFloat(params.lon);
      mapParams.lat = parseFloat(params.lat);
      mapParams.zoom = parseInt(params.zoom || 5);
    } else if (params.mlon && params.mlat) {
      mapParams.lon = parseFloat(params.mlon);
      mapParams.lat = parseFloat(params.mlat);
      mapParams.zoom = parseInt(params.zoom || 12);
    } else if (loc = $.cookie('_osm_location')) {
      loc = loc.split("|");
      mapParams.lon = parseFloat(loc[0]);
      mapParams.lat = parseFloat(loc[1]);
      mapParams.zoom = parseInt(loc[2]);
    } else if (OSM.home) {
      mapParams.lon = OSM.home.lon;
      mapParams.lat = OSM.home.lat;
      mapParams.zoom = 10;
    } else if (OSM.location) {
      mapParams.bounds = L.latLngBounds(
        [OSM.location.minlat,
         OSM.location.minlon],
        [OSM.location.maxlat,
         OSM.location.maxlon]);
    } else {
      mapParams.lon = -0.1;
      mapParams.lat = 51.5;
      mapParams.zoom = parseInt(params.zoom || 5);
    }

    mapParams.layers = hash.layers || (loc && loc[3]) || '';

    var scale = parseFloat(params.scale);
    if (scale > 0) {
      mapParams.zoom = Math.log(360.0 / (scale * 512.0)) / Math.log(2.0);
    }

    return mapParams;
  },

  parseHash: function(hash) {
    var args = {};

    var i = hash.indexOf('#');
    if (i < 0) {
      return args;
    }

    hash = querystring.parse(hash.substr(i + 1));

    var map = (hash.map || '').split('/'),
      zoom = parseInt(map[0], 10),
      lat = parseFloat(map[1]),
      lon = parseFloat(map[2]);

    if (!isNaN(zoom) && !isNaN(lat) && !isNaN(lon)) {
      args.center = new L.LatLng(lat, lon);
      args.zoom = zoom;
    }

    if (hash.layers) {
      args.layers = hash.layers;
    }

    return args;
  },

  formatHash: function(args) {
    var center, zoom, layers;

    if (args instanceof L.Map) {
      center = args.getCenter();
      zoom = args.getZoom();
      layers = args.getLayersCode();
    } else {
      center = args.center || L.latLng(args.lat, args.lon);
      zoom = args.zoom;
      layers = args.layers || '';
    }

    center = center.wrap();
    layers = layers.replace('M', '');

    var precision = OSM.zoomPrecision(zoom),
      hash = '#map=' + zoom +
        '/' + center.lat.toFixed(precision) +
        '/' + center.lng.toFixed(precision);

    if (layers) {
      hash += '&layers=' + layers;
    }

    return hash;
  },

  zoomPrecision: function(zoom) {
    return Math.max(0, Math.ceil(Math.log(zoom) / Math.LN2));
  },

  locationCookie: function(map) {
    var center = map.getCenter().wrap(),
      zoom = map.getZoom(),
      precision = OSM.zoomPrecision(zoom);
    return [center.lng.toFixed(precision), center.lat.toFixed(precision), zoom, map.getLayersCode()].join('|');
  }
};
require=(function(e,t,n){function i(n,s){if(!t[n]){if(!e[n]){var o=typeof require=="function"&&require;if(!s&&o)return o(n,!0);if(r)return r(n,!0);throw new Error("Cannot find module '"+n+"'")}var u=t[n]={exports:{}};e[n][0].call(u.exports,function(t){var r=e[n][1][t];return i(r?r:t)},u,u.exports)}return t[n].exports}var r=typeof require=="function"&&require;for(var s=0;s<n.length;s++)i(n[s]);return i})({"querystring-component":[function(require,module,exports){
module.exports=require('Xr2wId');
},{}],"Xr2wId":[function(require,module,exports){

/**
 * Module dependencies.
 */

var trim = require('trim');

/**
 * Parse the given query `str`.
 *
 * @param {String} str
 * @return {Object}
 * @api public
 */

exports.parse = function(str){
  if ('string' != typeof str) return {};

  str = trim(str);
  if ('' == str) return {};

  var obj = {};
  var pairs = str.split('&');
  for (var i = 0; i < pairs.length; i++) {
    var parts = pairs[i].split('=');
    obj[parts[0]] = null == parts[1]
      ? ''
      : decodeURIComponent(parts[1]);
  }

  return obj;
};

/**
 * Stringify the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api public
 */

exports.stringify = function(obj){
  if (!obj) return '';
  var pairs = [];
  for (var key in obj) {
    pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(obj[key]));
  }
  return pairs.join('&');
};

},{"trim":1}],1:[function(require,module,exports){

exports = module.exports = trim;

function trim(str){
  return str.replace(/^\s*|\s*$/g, '');
}

exports.left = function(str){
  return str.replace(/^\s*/, '');
};

exports.right = function(str){
  return str.replace(/\s*$/, '');
};

},{}]},{},[])
;
/*
  OSM.Router implements pushState-based navigation for the main page and
  other pages that use a sidebar+map based layout (export, search results,
  history, and browse pages).

  For browsers without pushState, it falls back to full page loads, which all
  of the above pages support.

  The router is initialized with a set of routes: a mapping of URL path templates
  to route controller objects. Path templates can contain placeholders
  (`/note/:id`) and optional segments (`/:type/:id(/history)`).

  Route controller objects can define four methods that are called at defined
  times during routing:

     * The `load` method is called by the router when a path which matches the
       route's path template is loaded via a normal full page load. It is passed
       as arguments the URL path plus any matching arguments for placeholders
       in the path template.

     * The `pushstate` method is called when a page which matches the route's path
       template is loaded via pushState. It is passed the same arguments as `load`.

     * The `popstate` method is called when returning to a previously
       pushState-loaded page via popstate (i.e. browser back/forward buttons).

     * The `unload` method is called on the exiting route controller when navigating
       via pushState or popstate to another route.

   Note that while `load` is not called by the router for pushState-based loads,
   it's frequently useful for route controllers to call it manually inside their
   definition of the `pushstate` and `popstate` methods.

   An instance of OSM.Router is assigned to `OSM.router`. To navigate to a new page
   via pushState (with automatic full-page load fallback), call `OSM.router.route`:

       OSM.router.route('/way/1234');

   If `route` is passed a path that matches one of the path templates, it performs
   the appropriate actions and returns true. Otherwise it returns false.

   OSM.Router also handles updating the hash portion of the URL containing transient
   map state such as the position and zoom level. Some route controllers may wish to
   temporarily suppress updating the hash (for example, to omit the hash on pages
   such as `/way/1234` unless the map is moved). This can be done by calling
   `OSM.router.moveListenerOff` and `OSM.router.moveListenerOn`.
 */
OSM.Router = function(map, rts) {
  var escapeRegExp  = /[\-{}\[\]+?.,\\\^$|#\s]/g;
  var optionalParam = /\((.*?)\)/g;
  var namedParam    = /(\(\?)?:\w+/g;
  var splatParam    = /\*\w+/g;

  function Route(path, controller) {
    var regexp = new RegExp('^' +
      path.replace(escapeRegExp, '\\$&')
        .replace(optionalParam, '(?:$1)?')
        .replace(namedParam, function(match, optional){
          return optional ? match : '([^\/]+)';
        })
        .replace(splatParam, '(.*?)') + '(?:\\?.*)?$');

    var route = {};

    route.match = function(path) {
      return regexp.test(path);
    };

    route.run = function(action, path) {
      var params = [];

      if (path) {
        params = regexp.exec(path).map(function(param, i) {
          return (i > 0 && param) ? decodeURIComponent(param) : param;
        });
      }
alert(controller);
alert(action);
alert(controller[action]);
alert(params);
      return (controller[action] || $.noop).apply(controller, params);
    };

    return route;
  }

  var routes = [];
  for (var r in rts)
    routes.push(Route(r, rts[r]));

  routes.recognize = function(path) {
    for (var i = 0; i < this.length; i++) {
      if (this[i].match(path)) return this[i];
    }
  };

  var currentPath = window.location.pathname.replace(/(.)\/$/, '$1') + window.location.search,
    currentRoute = routes.recognize(currentPath),
    currentHash = location.hash || OSM.formatHash(map);

  var router = {};

  if (window.history && window.history.pushState) {
    $(window).on('popstate', function(e) {
      if (!e.originalEvent.state) return; // Is it a real popstate event or just a hash change?
      var path = window.location.pathname + window.location.search;
      if (path === currentPath) return;
      currentRoute.run('unload');
      currentPath = path;
      currentRoute = routes.recognize(currentPath);
      currentRoute.run('popstate', currentPath);
      map.setState(e.originalEvent.state, {animate: false});
    });

    router.route = function (url) {
      var path = url.replace(/#.*/, ''),
        route = routes.recognize(path);
        
        
      if (!route) return false;
      currentRoute.run('unload');
      window.history.pushState(OSM.parseHash(url), document.title, url);
      currentPath = path;
      currentRoute = route;
      currentRoute.run('pushstate', currentPath);
      return true;
    };

    router.stateChange = function(state) {
      if (state.center) {
        window.history.replaceState(state, document.title, OSM.formatHash(state));
      } else {
        window.history.replaceState(state, document.title, window.location);
      }
    };
  } else {
    router.route = function (url) {
      window.location.assign(url);
    };

    router.stateChange = function(state) {
      if (state.center) window.location.replace(OSM.formatHash(state));
    };
  }

  router.updateHash = function() {
    var hash = OSM.formatHash(map);
    if (hash === currentHash) return;
    currentHash = hash;
    router.stateChange(OSM.parseHash(hash));
  };

  router.hashUpdated = function() {
    var hash = location.hash;
    if (hash === currentHash) return;
    currentHash = hash;
    var state = OSM.parseHash(hash);
    map.setState(state);
    router.stateChange(state, hash);
  };

  router.moveListenerOn = function() {
    map.on('moveend', router.updateHash);
  };

  router.moveListenerOff = function() {
    map.off('moveend', router.updateHash);
  };

  router.load = function() {
    var loadState = currentRoute.run('load', currentPath);
    router.stateChange(loadState || {});
  };

  router.setCurrentPath = function (path) {
    currentPath = path;
    currentRoute = routes.recognize(currentPath);
  };

  map.on('moveend baselayerchange overlaylayerchange', router.updateHash);
  $(window).on('hashchange', router.hashUpdated);

  return router;
};

(function() {

d3.simplify = function() {
  var projection = d3.geo.albers();

  function simplify(feature) {
    if (feature.type !== "MultiPolygon") throw new Error("not yet supported");

    var heap = minHeap(),
        maxArea = 0,
        triangle;

    feature.coordinates = feature.coordinates.map(function(polygon) {
      return polygon.map(function(lineString) {
        var points = lineString.map(projection),
            triangles = [];

        for (var i = 1, n = lineString.length - 1; i < n; ++i) {
          triangle = points.slice(i - 1, i + 2);
          if (triangle[1][2] = area(triangle)) {
            triangles.push(triangle);
            heap.push(triangle);
          }
        }

        for (var i = 0, n = triangles.length; i < n; ++i) {
          triangle = triangles[i];
          triangle.previous = triangles[i - 1];
          triangle.next = triangles[i + 1];
        }

        return points;
      });
    });

    while (triangle = heap.pop()) {

      // If the area of the current point is less than that of the previous point
      // to be eliminated, use the latter’s area instead. This ensures that the
      // current point cannot be eliminated without eliminating previously-
      // eliminated points.
      if (triangle[1][2] < maxArea) triangle[1][2] = maxArea;
      else maxArea = triangle[1][2];

      if (triangle.previous) {
        triangle.previous.next = triangle.next;
        triangle.previous[2] = triangle[2];
        update(triangle.previous);
      } else {
        triangle[0][2] = triangle[1][2];
      }

      if (triangle.next) {
        triangle.next.previous = triangle.previous;
        triangle.next[0] = triangle[0];
        update(triangle.next);
      } else {
        triangle[2][2] = triangle[1][2];
      }
    }

    function update(triangle) {
      heap.remove(triangle);
      triangle[1][2] = area(triangle);
      heap.push(triangle);
    }

    return feature;
  }

  simplify.projection = function(_) {
    if (!arguments.length) return projection;
    projection = _;
    return simplify;
  };

  return simplify;
};

function compare(a, b) {
  return a[1][2] - b[1][2];
}

function area(t) {
  return Math.abs((t[0][0] - t[2][0]) * (t[1][1] - t[0][1]) - (t[0][0] - t[1][0]) * (t[2][1] - t[0][1]));
}

function minHeap() {
  var heap = {},
      array = [];

  heap.push = function() {
    for (var i = 0, n = arguments.length; i < n; ++i) {
      var object = arguments[i];
      up(object.index = array.push(object) - 1);
    }
    return array.length;
  };

  heap.pop = function() {
    var removed = array[0],
        object = array.pop();
    if (array.length) {
      array[object.index = 0] = object;
      down(0);
    }
    return removed;
  };

  heap.remove = function(removed) {
    var i = removed.index,
        object = array.pop();
    if (i !== array.length) {
      array[object.index = i] = object;
      (compare(object, removed) < 0 ? up : down)(i);
    }
    return i;
  };

  function up(i) {
    var object = array[i];
    while (i > 0) {
      var up = ((i + 1) >> 1) - 1,
          parent = array[up];
      if (compare(object, parent) >= 0) break;
      array[parent.index = i] = parent;
      array[object.index = i = up] = object;
    }
  }

  function down(i) {
    var object = array[i];
    while (true) {
      var right = (i + 1) << 1,
          left = right - 1,
          down = i,
          child = array[down];
      if (left < array.length && compare(array[left], child) < 0) child = array[down = left];
      if (right < array.length && compare(array[right], child) < 0) child = array[down = right];
      if (down === i) break;
      array[child.index = i] = child;
      array[object.index = i = down] = object;
    }
  }

  return heap;
}

})();

$(document).ready(function() {
  var params = OSM.params();

  if (params.lat && params.lon) {
    params.lat = parseFloat(params.lat);
    params.lon = parseFloat(params.lon);
    params.zoom = params.zoom || 17;

    var url = '/edit';

    if (params.editor) {
      url += '?editor=' + params.editor;
    }

    url += OSM.formatHash(params);

    $('.start-mapping').attr('href', url);

  } else {
    function geoSuccess(position) {
      window.location = '/edit' + OSM.formatHash({
        zoom: 17,
        lat: position.coords.latitude,
        lon: position.coords.longitude
      });
    }

    $('.start-mapping').on('click', function(e) {
      e.preventDefault();
      $('.start-mapping').addClass('loading');

      if (navigator.geolocation) {
        // handle firefox's weird implementation
        // https://bugzilla.mozilla.org/show_bug.cgi?id=675533
        window.setTimeout(manualEdit, 4000);

        navigator.geolocation.getCurrentPosition(geoSuccess, manualEdit);
      } else {
        manualEdit();
      }
    });
  }

  function manualEdit() {
    window.location = '/?edit_help=1';
  }
});

/**
 * Portions of this code are from the Google Closure Library,
 * received from the Closure Authors under the Apache 2.0 license.
 *
 * All other code is (C) FriendsOfSymfony and subject to the MIT license.
 */
(function() {var f=!1,i,k=this;function l(a,c){var b=a.split("."),d=k;!(b[0]in d)&&d.execScript&&d.execScript("var "+b[0]);for(var e;b.length&&(e=b.shift());)!b.length&&void 0!==c?d[e]=c:d=d[e]?d[e]:d[e]={}};var m=Array.prototype,n=m.forEach?function(a,c,b){m.forEach.call(a,c,b)}:function(a,c,b){for(var d=a.length,e="string"==typeof a?a.split(""):a,g=0;g<d;g++)g in e&&c.call(b,e[g],g,a)};function q(a,c){this.c={};this.a=[];var b=arguments.length;if(1<b){if(b%2)throw Error("Uneven number of arguments");for(var d=0;d<b;d+=2)this.set(arguments[d],arguments[d+1])}else if(a){var e;if(a instanceof q){r(a);d=a.a.concat();r(a);e=[];for(b=0;b<a.a.length;b++)e.push(a.c[a.a[b]])}else{var b=[],g=0;for(d in a)b[g++]=d;d=b;b=[];g=0;for(e in a)b[g++]=a[e];e=b}for(b=0;b<d.length;b++)this.set(d[b],e[b])}}q.prototype.f=0;q.prototype.p=0;
function r(a){if(a.f!=a.a.length){for(var c=0,b=0;c<a.a.length;){var d=a.a[c];t(a.c,d)&&(a.a[b++]=d);c++}a.a.length=b}if(a.f!=a.a.length){for(var e={},b=c=0;c<a.a.length;)d=a.a[c],t(e,d)||(a.a[b++]=d,e[d]=1),c++;a.a.length=b}}q.prototype.get=function(a,c){return t(this.c,a)?this.c[a]:c};q.prototype.set=function(a,c){t(this.c,a)||(this.f++,this.a.push(a),this.p++);this.c[a]=c};function t(a,c){return Object.prototype.hasOwnProperty.call(a,c)};var u,v,w,x;function y(){return k.navigator?k.navigator.userAgent:null}x=w=v=u=f;var C;if(C=y()){var D=k.navigator;u=0==C.indexOf("Opera");v=!u&&-1!=C.indexOf("MSIE");w=!u&&-1!=C.indexOf("WebKit");x=!u&&!w&&"Gecko"==D.product}var E=v,F=x,G=w;var I;if(u&&k.opera){var J=k.opera.version;"function"==typeof J&&J()}else F?I=/rv\:([^\);]+)(\)|;)/:E?I=/MSIE\s+([^\);]+)(\)|;)/:G&&(I=/WebKit\/(\S+)/),I&&I.exec(y());function K(a,c){this.b=a||{e:"",prefix:"",host:"",scheme:""};this.h(c||{})}K.g=function(){return K.j?K.j:K.j=new K};i=K.prototype;i.h=function(a){this.d=new q(a)};i.o=function(){return this.d};i.k=function(a){this.b.e=a};i.n=function(){return this.b.e};i.l=function(a){this.b.prefix=a};
function L(a,c,b,d){var e,g=RegExp(/\[\]$/);if(b instanceof Array)n(b,function(b,e){g.test(c)?d(c,b):L(a,c+"["+("object"===typeof b?e:"")+"]",b,d)});else if("object"===typeof b)for(e in b)L(a,c+"["+e+"]",b[e],d);else d(c,b)}i.i=function(a){var c=this.b.prefix+a;if(t(this.d.c,c))a=c;else if(!t(this.d.c,a))throw Error('The route "'+a+'" does not exist.');return this.d.get(a)};
i.m=function(a,c,b){var d=this.i(a),e=c||{},g={},z;for(z in e)g[z]=e[z];var h="",s=!0,j="";n(d.tokens,function(b){if("text"===b[0])h=b[1]+h,s=f;else if("variable"===b[0]){var c=b[3]in d.defaults;if(f===s||!c||b[3]in e&&e[b[3]]!=d.defaults[b[3]]){if(b[3]in e){var c=e[b[3]],p=b[3];p in g&&delete g[p]}else if(c)c=d.defaults[b[3]];else{if(s)return;throw Error('The route "'+a+'" requires the parameter "'+b[3]+'".');}if(!(!0===c||f===c||""===c)||!s)p=encodeURIComponent(c).replace(/%2F/g,"/"),"null"===p&&
null===c&&(p=""),h=b[1]+p+h;s=f}else c&&(b=b[3],b in g&&delete g[b])}else throw Error('The token type "'+b[0]+'" is not supported.');});""===h&&(h="/");n(d.hosttokens,function(a){var b;if("text"===a[0])j=a[1]+j;else if("variable"===a[0]){if(a[3]in e){b=e[a[3]];var c=a[3];c in g&&delete g[c]}else a[3]in d.defaults&&(b=d.defaults[a[3]]);j=a[1]+b+j}});h=this.b.e+h;"_scheme"in d.requirements&&this.b.scheme!=d.requirements._scheme?h=d.requirements._scheme+"://"+(j||this.b.host)+h:j&&this.b.host!==j?h=
this.b.scheme+"://"+j+h:!0===b&&(h=this.b.scheme+"://"+this.b.host+h);var c=0,A;for(A in g)c++;if(0<c){var B,H=[];A=function(a,b){b="function"===typeof b?b():b;H.push(encodeURIComponent(a)+"="+encodeURIComponent(null===b?"":b))};for(B in g)L(this,B,g[B],A);h=h+"?"+H.join("&").replace(/%20/g,"+")}return h};l("fos.Router",K);l("fos.Router.setData",function(a){var c=K.g();c.k(a.base_url);c.h(a.routes);"prefix"in a&&c.l(a.prefix);c.b.host=a.host;c.b.scheme=a.scheme});K.getInstance=K.g;K.prototype.setRoutes=K.prototype.h;K.prototype.getRoutes=K.prototype.o;K.prototype.setBaseUrl=K.prototype.k;K.prototype.getBaseUrl=K.prototype.n;K.prototype.generate=K.prototype.m;K.prototype.setPrefix=K.prototype.l;K.prototype.getRoute=K.prototype.i;window.Routing=K.g();})();